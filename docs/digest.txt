Directory structure:
└── any2/
    ├── README.md
    ├── LICENSE
    ├── Night.sln
    ├── .editorconfig
    ├── .pre-commit-config.yaml
    ├── docs/
    │   ├── API.md
    │   ├── NOTICE.md
    │   ├── PRD.md
    │   ├── operational-guidelines.md
    │   ├── testing-plan.md
    │   ├── epics/
    │   │   ├── epic10.md
    │   │   └── archive/
    │   │       ├── epic1.md
    │   │       ├── epic2.md
    │   │       ├── epic3.md
    │   │       ├── epic4.md
    │   │       ├── epic5.md
    │   │       ├── epic6.md
    │   │       ├── epic7-design.md
    │   │       ├── epic7.md
    │   │       ├── epic8.md
    │   │       └── epic9.md
    │   └── love2d-api/
    │       ├── roadmap.md
    │       └── modules/
    │           ├── audio.md
    │           ├── data.md
    │           ├── event.md
    │           ├── filesystem.md
    │           ├── font.md
    │           ├── graphics.md
    │           ├── image.md
    │           ├── joystick.md
    │           ├── keyboard.md
    │           ├── love.md
    │           ├── math.md
    │           ├── mouse.md
    │           ├── sound.md
    │           ├── system.md
    │           ├── thread.md
    │           ├── timer.md
    │           ├── touch.md
    │           ├── video.md
    │           └── window.md
    ├── lib/
    ├── scripts/
    │   ├── sync_sdl3.py
    │   ├── update_api_doc.py
    │   └── update_tools.py
    ├── src/
    │   ├── Night/
    │   │   ├── ErrorHandler.cs
    │   │   ├── FrameworkLoop.cs
    │   │   ├── Night.csproj
    │   │   ├── Types.cs
    │   │   ├── Configuration/
    │   │   │   ├── ConfigurationManager.cs
    │   │   │   └── GameConfig.cs
    │   │   ├── Engine/
    │   │   │   └── .gitkeep
    │   │   ├── Filesystem/
    │   │   │   ├── Enums.cs
    │   │   │   ├── Filesystem.cs
    │   │   │   └── Types.cs
    │   │   ├── Graphics/
    │   │   │   ├── Enums.cs
    │   │   │   ├── Graphics.cs
    │   │   │   ├── Structs.cs
    │   │   │   └── Types.cs
    │   │   ├── Keyboard/
    │   │   │   ├── Enums.cs
    │   │   │   └── Keyboard.cs
    │   │   ├── Mouse/
    │   │   │   ├── Enums.cs
    │   │   │   └── Mouse.cs
    │   │   ├── SDL/
    │   │   │   └── NightSDL.cs
    │   │   ├── System/
    │   │   │   └── System.cs
    │   │   ├── Timer/
    │   │   │   └── Timer.cs
    │   │   ├── Window/
    │   │   │   ├── Enums.cs
    │   │   │   ├── Structs.cs
    │   │   │   └── Window.cs
    │   │   ├── bin/
    │   │   │   └── Debug/
    │   │   │       └── net9.0/
    │   │   │           └── Night.deps.json
    │   │   └── obj/
    │   │       ├── Night.csproj.nuget.dgspec.json
    │   │       ├── Night.csproj.nuget.g.props
    │   │       ├── Night.csproj.nuget.g.targets
    │   │       ├── project.assets.json
    │   │       ├── project.nuget.cache
    │   │       └── Debug/
    │   │           └── net9.0/
    │   │               ├── Night.AssemblyInfo.cs
    │   │               ├── Night.AssemblyInfoInputs.cache
    │   │               ├── Night.GeneratedMSBuildEditorConfig.editorconfig
    │   │               ├── Night.GlobalUsings.g.cs
    │   │               ├── Night.assets.cache
    │   │               ├── Night.csproj.AssemblyReference.cache
    │   │               ├── Night.csproj.CoreCompileInputs.cache
    │   │               ├── Night.sourcelink.json
    │   │               ├── .NETCoreApp,Version=v9.0.AssemblyAttributes.cs
    │   │               ├── ref/
    │   │               └── refint/
    │   └── SampleGame/
    │       ├── Night.SampleGame.csproj
    │       ├── Player.cs
    │       ├── Program.cs
    │       ├── config.json
    │       ├── Samples/
    │       │   └── Program.cs
    │       ├── assets/
    │       │   ├── data/
    │       │   └── images/
    │       │       ├── pixel_green.pixi
    │       │       └── player_sprite_blue_32x64.aseprite
    │       ├── bin/
    │       │   └── Debug/
    │       │       └── net9.0/
    │       │           ├── Night.SampleGame
    │       │           ├── Night.SampleGame.deps.json
    │       │           ├── Night.SampleGame.runtimeconfig.json
    │       │           ├── config.json
    │       │           └── assets/
    │       │               ├── data/
    │       │               └── images/
    │       │                   ├── pixel_green.pixi
    │       │                   └── player_sprite_blue_32x64.aseprite
    │       └── obj/
    │           ├── Night.SampleGame.csproj.nuget.dgspec.json
    │           ├── Night.SampleGame.csproj.nuget.g.props
    │           ├── Night.SampleGame.csproj.nuget.g.targets
    │           ├── project.assets.json
    │           ├── project.nuget.cache
    │           └── Debug/
    │               └── net9.0/
    │                   ├── Night.Sa.E6945040.Up2Date
    │                   ├── Night.SampleGame.AssemblyInfo.cs
    │                   ├── Night.SampleGame.AssemblyInfoInputs.cache
    │                   ├── Night.SampleGame.GeneratedMSBuildEditorConfig.editorconfig
    │                   ├── Night.SampleGame.GlobalUsings.g.cs
    │                   ├── Night.SampleGame.assets.cache
    │                   ├── Night.SampleGame.csproj.AssemblyReference.cache
    │                   ├── Night.SampleGame.csproj.CoreCompileInputs.cache
    │                   ├── Night.SampleGame.genruntimeconfig.cache
    │                   ├── Night.SampleGame.sourcelink.json
    │                   ├── apphost
    │                   ├── .NETCoreApp,Version=v9.0.AssemblyAttributes.cs
    │                   ├── ref/
    │                   └── refint/
    ├── tests/
    │   └── Night.Tests/
    │       ├── FilesystemTests.cs
    │       ├── Night.Tests.csproj
    │       ├── UnitTest1.cs
    │       ├── bin/
    │       │   └── Debug/
    │       │       └── net9.0/
    │       │           ├── CoverletSourceRootsMapping_Night.Tests
    │       │           ├── Night.Tests.deps.json
    │       │           ├── Night.Tests.runtimeconfig.json
    │       │           ├── .msCoverageSourceRootsMapping_Night.Tests
    │       │           ├── cs/
    │       │           ├── de/
    │       │           ├── es/
    │       │           ├── fr/
    │       │           ├── it/
    │       │           ├── ja/
    │       │           ├── ko/
    │       │           ├── pl/
    │       │           ├── pt-BR/
    │       │           ├── ru/
    │       │           ├── tr/
    │       │           ├── zh-Hans/
    │       │           └── zh-Hant/
    │       └── obj/
    │           ├── Night.Tests.csproj.nuget.dgspec.json
    │           ├── Night.Tests.csproj.nuget.g.props
    │           ├── Night.Tests.csproj.nuget.g.targets
    │           ├── project.assets.json
    │           ├── project.nuget.cache
    │           └── Debug/
    │               └── net9.0/
    │                   ├── Night.Te.8CE7B445.Up2Date
    │                   ├── Night.Tests.AssemblyInfo.cs
    │                   ├── Night.Tests.AssemblyInfoInputs.cache
    │                   ├── Night.Tests.GeneratedMSBuildEditorConfig.editorconfig
    │                   ├── Night.Tests.GlobalUsings.g.cs
    │                   ├── Night.Tests.assets.cache
    │                   ├── Night.Tests.csproj.AssemblyReference.cache
    │                   ├── Night.Tests.csproj.CoreCompileInputs.cache
    │                   ├── Night.Tests.genruntimeconfig.cache
    │                   ├── Night.Tests.sourcelink.json
    │                   ├── .NETCoreApp,Version=v9.0.AssemblyAttributes.cs
    │                   ├── ref/
    │                   └── refint/
    ├── tools/
    │   ├── manifest.json
    │   ├── codegen/
    │   │   ├── PRD.md
    │   │   └── example.json
    │   └── crunch/
    │       ├── linux/
    │       │   └── crunch
    │       ├── macos/
    │       │   └── crunch
    │       └── windows/
    ├── .cursor/
    ├── .github/
    │   ├── CODEOWNERS
    │   ├── copilot-instructions.md
    │   ├── dependabot.yml
    │   ├── deactivated/
    │   │   └── release.yml
    │   ├── scripts/
    │   │   └── determine_next_version.py
    │   └── workflows/
    │       ├── ci.yml
    │       ├── codeql-analysis.yml
    │       ├── dependency-review.yml
    │       └── scorecard.yml
    ├── .roo/
    └── .windsurf/

================================================
File: README.md
================================================
# Night Engine

A C# game engine built on top of SDL3.

This project aims to provide a "batteries-included," in code editor experience to game development. A near-parity Love2D-inspired API for C# developers serves as the framework base. On top of this framework, there is an (optional) engine that will provide opinionated solutions for the engine so game designers can focus on building games.

This project also intends to be AI friendly so that non-programmer game designers can build games faster.

## Library Structure

The core of the project is the `Night.dll` library. This assembly contains:

- The `Night` namespace: Provides the Love2D-inspired framework API for low-level game development tasks.
- The `Night.Engine` namespace: Will house higher-level, more opinionated game engine components (e.g., Scene Management, ECS) built upon the `Night` framework.

## Features

### Project

- [ ] Near-parity Love2D-inspired API
- [ ] LLM friendly documentation automagically generated
- [ ] Game samples

### Engine-Specific Features

- [ ] Manager system (Assets, Scenes, Joystick, etc.)
- [ ] ECS

## Getting Started (Development)

1. Ensure [mise](https://mise.jdx.dev/) is installed.
2. Clone repository

### macOS Development Notes

#### VS Code and `mise` for .NET SDK Versioning

If you are using `mise` to manage your .NET SDK versions on macOS, you might encounter issues where VS Code (when launched via its `.app` bundle, e.g., from Finder, Spotlight, or Raycast) does not correctly pick up the `mise`-activated .NET SDK. This can lead to:

- Linter errors complaining about incorrect .NET versions or missing fundamental types.
- NuGet restore failures (e.g., `NETSDK1045` error) because VS Code's C# Dev Kit attempts to use a globally installed .NET SDK (like .NET 8) instead of the project-specified one (e.g., .NET 9).

This happens because GUI-launched applications on macOS do not typically inherit the full shell environment (like `PATH` modifications) that `mise` sets up in your terminal.

##### Solution: Wrapper Script for Launching VS Code

To ensure VS Code launches with the correct `mise`-managed environment, you can use a wrapper shell script. This script explicitly sets up the environment before launching VS Code.

1. **Create the script** (e.g., save as `~/vscode-launcher.sh` or `~/bin/vscode-launcher.sh`):

    ```zsh
    #!/bin/zsh

    # Wrapper script to launch VS Code with the mise-managed environment.

    # Add mise shims directory to PATH
    MISE_SHIMS_PATH="$HOME/.local/share/mise/shims"
    export PATH="$MISE_SHIMS_PATH:$PATH"

    # Optional: Navigate to your specific project directory if desired
    # cd "/path/to/your/project"

    # Launch VS Code, passing through any arguments
    exec code "$@"
    ```

2. **Make it executable:**

    ```bash
    chmod +x /path/to/your/vscode-launcher.sh
    ```

3. **Configure your launcher** (e.g., Raycast, Alfred, or even a custom Dock icon) to execute this script instead of `Visual Studio Code.app` directly.

This ensures that VS Code and its extensions (like the C# Dev Kit) inherit the correct PATH and use the .NET SDK version specified by `mise` for your project.

## License

This project is licensed under the zlib License. See [LICENSE](LICENSE) for details. Third-party library licences can be found in [NOTICE](docs/NOTICE.md).



================================================
File: LICENSE
================================================
zlib License

Copyright (c) 2025 Danny Solivan, Night Circle

This software is provided ‘as-is’, without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software
in a product, an acknowledgment in the product documentation would be
appreciated but is not required.

2. Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.

3. This notice may not be removed or altered from any source
distribution.



================================================
File: Night.sln
================================================
﻿Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.31903.59
MinimumVisualStudioVersion = 10.0.40219.1
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "src", "src", "{827E0CD3-B72D-47B6-A68D-7590B98EB39B}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Night", "src\Night\Night.csproj", "{259774D0-6C26-4CD6-8611-D184D8D04BF4}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Night.SampleGame", "src\SampleGame\Night.SampleGame.csproj", "{665B8256-5042-4354-99DC-25D560A0DF8B}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "tests", "tests", "{0AB3BF05-4346-4AA6-1389-037BE0695223}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Night.Tests", "tests\Night.Tests\Night.Tests.csproj", "{D9CEF2DF-0142-4130-8F26-E580B0B36D9E}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|Any CPU = Release|Any CPU
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{259774D0-6C26-4CD6-8611-D184D8D04BF4}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{259774D0-6C26-4CD6-8611-D184D8D04BF4}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{259774D0-6C26-4CD6-8611-D184D8D04BF4}.Debug|x64.ActiveCfg = Debug|Any CPU
		{259774D0-6C26-4CD6-8611-D184D8D04BF4}.Debug|x64.Build.0 = Debug|Any CPU
		{259774D0-6C26-4CD6-8611-D184D8D04BF4}.Debug|x86.ActiveCfg = Debug|Any CPU
		{259774D0-6C26-4CD6-8611-D184D8D04BF4}.Debug|x86.Build.0 = Debug|Any CPU
		{259774D0-6C26-4CD6-8611-D184D8D04BF4}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{259774D0-6C26-4CD6-8611-D184D8D04BF4}.Release|Any CPU.Build.0 = Release|Any CPU
		{259774D0-6C26-4CD6-8611-D184D8D04BF4}.Release|x64.ActiveCfg = Release|Any CPU
		{259774D0-6C26-4CD6-8611-D184D8D04BF4}.Release|x64.Build.0 = Release|Any CPU
		{259774D0-6C26-4CD6-8611-D184D8D04BF4}.Release|x86.ActiveCfg = Release|Any CPU
		{259774D0-6C26-4CD6-8611-D184D8D04BF4}.Release|x86.Build.0 = Release|Any CPU
		{665B8256-5042-4354-99DC-25D560A0DF8B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{665B8256-5042-4354-99DC-25D560A0DF8B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{665B8256-5042-4354-99DC-25D560A0DF8B}.Debug|x64.ActiveCfg = Debug|Any CPU
		{665B8256-5042-4354-99DC-25D560A0DF8B}.Debug|x64.Build.0 = Debug|Any CPU
		{665B8256-5042-4354-99DC-25D560A0DF8B}.Debug|x86.ActiveCfg = Debug|Any CPU
		{665B8256-5042-4354-99DC-25D560A0DF8B}.Debug|x86.Build.0 = Debug|Any CPU
		{665B8256-5042-4354-99DC-25D560A0DF8B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{665B8256-5042-4354-99DC-25D560A0DF8B}.Release|Any CPU.Build.0 = Release|Any CPU
		{665B8256-5042-4354-99DC-25D560A0DF8B}.Release|x64.ActiveCfg = Release|Any CPU
		{665B8256-5042-4354-99DC-25D560A0DF8B}.Release|x64.Build.0 = Release|Any CPU
		{665B8256-5042-4354-99DC-25D560A0DF8B}.Release|x86.ActiveCfg = Release|Any CPU
		{665B8256-5042-4354-99DC-25D560A0DF8B}.Release|x86.Build.0 = Release|Any CPU
		{D9CEF2DF-0142-4130-8F26-E580B0B36D9E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{D9CEF2DF-0142-4130-8F26-E580B0B36D9E}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{D9CEF2DF-0142-4130-8F26-E580B0B36D9E}.Debug|x64.ActiveCfg = Debug|Any CPU
		{D9CEF2DF-0142-4130-8F26-E580B0B36D9E}.Debug|x64.Build.0 = Debug|Any CPU
		{D9CEF2DF-0142-4130-8F26-E580B0B36D9E}.Debug|x86.ActiveCfg = Debug|Any CPU
		{D9CEF2DF-0142-4130-8F26-E580B0B36D9E}.Debug|x86.Build.0 = Debug|Any CPU
		{D9CEF2DF-0142-4130-8F26-E580B0B36D9E}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{D9CEF2DF-0142-4130-8F26-E580B0B36D9E}.Release|Any CPU.Build.0 = Release|Any CPU
		{D9CEF2DF-0142-4130-8F26-E580B0B36D9E}.Release|x64.ActiveCfg = Release|Any CPU
		{D9CEF2DF-0142-4130-8F26-E580B0B36D9E}.Release|x64.Build.0 = Release|Any CPU
		{D9CEF2DF-0142-4130-8F26-E580B0B36D9E}.Release|x86.ActiveCfg = Release|Any CPU
		{D9CEF2DF-0142-4130-8F26-E580B0B36D9E}.Release|x86.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{259774D0-6C26-4CD6-8611-D184D8D04BF4} = {827E0CD3-B72D-47B6-A68D-7590B98EB39B}
		{665B8256-5042-4354-99DC-25D560A0DF8B} = {827E0CD3-B72D-47B6-A68D-7590B98EB39B}
		{D9CEF2DF-0142-4130-8F26-E580B0B36D9E} = {0AB3BF05-4346-4AA6-1389-037BE0695223}
	EndGlobalSection
EndGlobal



================================================
File: .editorconfig
================================================
# top-most EditorConfig file
root = true

# Unix-style newlines with a newline ending every file
[*]
end_of_line = lf
insert_final_newline = true
trim_trailing_whitespace = true

[*.{cs}]
indent_style = space
indent_size = 2
csharp_max_line_length = 100
dotnet_sort_system_directives_first = true
dotnet_separate_import_directive_groups = true
csharp_preferred_using_directive_placement = outside_namespace:error

# Style - Naming Conventions
dotnet_diagnostic.IDE1006.severity = error # Naming rule violation (covers PascalCase, camelCase, _camelCase based on symbols)
dotnet_diagnostic.IDE0051.severity = warning # Remove unused private members
dotnet_diagnostic.IDE0052.severity = warning # Remove unread private members
dotnet_diagnostic.IDE0060.severity = warning # Remove unused parameter

# Style - Code Clarity and Consistency
dotnet_diagnostic.IDE0003.severity = suggestion # Add 'this.' or 'Me.' qualification
dotnet_diagnostic.IDE0009.severity = suggestion # Add 'this.' or 'Me.' qualification (for members)
dotnet_diagnostic.IDE0011.severity = suggestion # Add braces
dotnet_diagnostic.IDE0017.severity = suggestion # Simplify object initialization
dotnet_diagnostic.IDE0028.severity = suggestion # Simplify collection initialization
dotnet_diagnostic.IDE0036.severity = suggestion # Order modifiers
dotnet_diagnostic.IDE0040.severity = suggestion # Add accessibility modifiers
dotnet_diagnostic.IDE0041.severity = warning # Use 'is null' check
dotnet_diagnostic.IDE0044.severity = suggestion # Make field readonly
dotnet_diagnostic.IDE0055.severity = error # Format document (enforce dotnet format)
dotnet_diagnostic.IDE0058.severity = warning # Remove unnecessary expression value
dotnet_diagnostic.IDE0059.severity = warning # Remove unnecessary value assignment
dotnet_diagnostic.IDE0063.severity = suggestion # Use simple 'using' statement
dotnet_diagnostic.IDE0066.severity = suggestion # Use switch expression
dotnet_diagnostic.IDE0074.severity = suggestion # Use coalesce compound assignment
dotnet_diagnostic.IDE0090.severity = suggestion # Simplify 'new' expression

# Style - Expression-bodied members (preference for conciseness where appropriate)
dotnet_style_prefer_expression_bodied_constructors = false
dotnet_style_prefer_expression_bodied_methods = true:suggestion
dotnet_style_prefer_expression_bodied_operators = true:suggestion
dotnet_style_prefer_expression_bodied_properties = true:suggestion
dotnet_style_prefer_expression_bodied_indexers = true:suggestion
dotnet_style_prefer_expression_bodied_accessors = true:suggestion
dotnet_style_prefer_expression_bodied_lambdas = true:suggestion
dotnet_style_prefer_expression_bodied_local_functions = true:suggestion

# Quality - General
dotnet_diagnostic.CA1822.severity = warning # Mark members as static (if no instance data is accessed)
dotnet_diagnostic.CA2211.severity = warning # Non-constant fields should not be visible

# use 2-spaces for csproj
[*.{csproj,vbproj,vcxproj,vcxproj.filters,proj,nativeproj,locproj}]
indent_style = space
indent_size = 2



================================================
File: .pre-commit-config.yaml
================================================
# Top-level pre-commit config for C# project
repos:
  - repo: local
    hooks:
      - id: dotnet-format
        name: dotnet format
        entry: dotnet format Night.sln --verify-no-changes
        language: system
        types: [csharp]
        pass_filenames: false # Run on the whole solution if any C# file changes
        always_run: false
  - repo: https://github.com/gitleaks/gitleaks
    rev: v8.18.2 # Updated to a more recent version
    hooks:
      - id: gitleaks
  - repo: https://github.com/jumanjihouse/pre-commit-hooks
    rev: 3.0.0
    hooks:
      - id: shellcheck
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.6.0 # Updated to a more recent version
    hooks:
      - id: end-of-file-fixer
      - id: trailing-whitespace
      - id: check-yaml
      - id: check-json
      - id: check-merge-conflict
      - id: check-case-conflict
      - id: check-added-large-files



================================================
File: docs/API.md
================================================
# Night / Love2D API

## Filesystem

### Types (Filesystem)

- FileSystemInfo

### Functions (Filesystem)

- GetInfo() - love.filesystem.getInfo
  - GetInfo(string path, FileSystemInfo info)
  - GetInfo(string path, FileType filterType, FileSystemInfo info)
  - GetInfo(string path, FileType? filterType)
- ReadBytes() - love.filesystem.readBytes
  - ReadBytes(string path)
- ReadText() - love.filesystem.readText
  - ReadText(string path)

### Enums (Filesystem)

- FileMode
- FileType

## Graphics

### Types (Graphics)

- Sprite

### Functions (Graphics)

- Circle() - love.graphics.circle
  - Circle(DrawMode mode, float x, float y, float radius, int segments)
- Clear() - love.graphics.clear
  - Clear(Color color)
- Draw() - love.graphics.draw
  - Draw(Sprite sprite, float x, float y, float rotation, float scaleX, float scaleY, float offsetX, float offsetY)
- Line() - love.graphics.line
  - Line(PointF[] points)
  - Line(float x1, float y1, float x2, float y2)
- NewImage() - love.graphics.newImage
  - NewImage(string filePath)
- Polygon() - love.graphics.polygon
  - Polygon(DrawMode mode, PointF[] vertices)
- Present() - love.graphics.present
- Rectangle() - love.graphics.rectangle
  - Rectangle(DrawMode mode, float x, float y, float width, float height)
- SetColor() - love.graphics.setColor
  - SetColor(Color color)
  - SetColor(byte r, byte g, byte b, byte a)

### Enums (Graphics)

- DrawMode

## Keyboard

### Functions (Keyboard)

- IsDown() - love.keyboard.isDown
  - IsDown(KeyCode key)

### Enums (Keyboard)

- KeyCode
- KeySymbol

## Mouse

### Functions (Mouse)

- GetPosition() - love.mouse.getPosition
- IsDown() - love.mouse.isDown
  - IsDown(MouseButton button)
- SetGrabbed() - love.mouse.setGrabbed
  - SetGrabbed(bool grabbed)
- SetRelativeMode() - love.mouse.setRelativeMode
  - SetRelativeMode(bool enabled)
- SetVisible() - love.mouse.setVisible
  - SetVisible(bool visible)

### Enums (Mouse)

- MouseButton

## System

### Functions (System)

- GetClipboardText() - love.system.getClipboardText
- SetClipboardText() - love.system.setClipboardText
  - SetClipboardText(string text)

## Timer

### Functions (Timer)

- GetAverageDelta() - love.timer.getAverageDelta
- GetDelta() - love.timer.getDelta
- GetFPS() - love.timer.getFPS
- GetTime() - love.timer.getTime
- Sleep() - love.timer.sleep
  - Sleep(double seconds)
- Step() - love.timer.step

## Window

### Functions (Window)

- Close() - love.window.close
- FromPixels() - love.window.fromPixels
  - FromPixels(float value)
- GetDPIScale() - love.window.getDPIScale
- GetDesktopDimensions() - love.window.getDesktopDimensions
  - GetDesktopDimensions(int displayIndex)
- GetDisplayCount() - love.window.getDisplayCount
- GetFullscreen() - love.window.getFullscreen
- GetFullscreenModes() - love.window.getFullscreenModes
  - GetFullscreenModes(int displayIndex)
- GetMode() - love.window.getMode
- IsOpen() - love.window.isOpen
- SetFullscreen() - love.window.setFullscreen
  - SetFullscreen(bool fullscreen, FullscreenType fsType)
- SetMode() - love.window.setMode
  - SetMode(int width, int height, SDL.WindowFlags flags)
- SetTitle() - love.window.setTitle
  - SetTitle(string title)
- ToPixels() - love.window.toPixels
  - ToPixels(float value)

### Enums (Window)

- FullscreenType



================================================
File: docs/NOTICE.md
================================================
# Third-Party Software Notices

This project incorporates copyrighted material from the following third-party projects.

## Libraries

### SDL

- Copyright (C) 1997-2025 Sam Lantinga <slouken@libsdl.org>
- License: zlib
- Website: [https://www.libsdl.org/](https://www.libsdl.org/)

### SDL_image (SDL Image Library)

- Copyright (C) 1997-2025 Sam Lantinga <slouken@libsdl.org>
- License: zlib
- Website: [https://github.com/libsdl-org/SDL_mixer](https://github.com/libsdl-org/SDL_mixer)

### SDL_mixer (SDL Audio Mixer Library)

- Copyright (C) 1997-2025 Sam Lantinga <slouken@libsdl.org>
- License: zlib
- Website: [https://github.com/libsdl-org/SDL_mixer](https://github.com/libsdl-org/SDL_mixer)

### SDL_ttf (SDL TrueType Font Library)

- Copyright (C) 1997-2025 Sam Lantinga <slouken@libsdl.org> and contributors
- License: zlib
- Website: [https://github.com/libsdl-org/SDL_ttf](https://github.com/libsdl-org/SDL_ttf)
- Dependency licenses:
  - FreeType, licensed under [FTL](https://gitlab.freedesktop.org/freetype/freetype/-/blob/master/docs/FTL.TXT)
  - HarfBuzz licensed under the [MIT license](https://github.com/harfbuzz/harfbuzz/blob/main/COPYING)
  - PlutoSVG, licensed under the [MIT license](https://github.com/sammycage/plutosvg/blob/master/LICENSE)
  - PlutoVG, licensed under the [MIT license](https://github.com/sammycage/plutovg/blob/master/LICENSE)

### SDL3# (SDL3 C# Bindings)

- Copyright (C) 2024-2025 Eduard Gushchin <eduardgushchin@yandex.ru>
- License: zlib
- Website: [https://github.com/edwardgushchin/SDL3-CS](https://github.com/edwardgushchin/SDL3-CS)

## License Text

### zlib

```plaintext
This software is provided ‘as-is’, without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software
in a product, an acknowledgment in the product documentation would be
appreciated but is not required.

2. Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.

3. This notice may not be removed or altered from any source
distribution.
```

### FTL

```plaintext
                    The FreeType Project LICENSE
                    ----------------------------

                            2006-Jan-27

                    Copyright 1996-2002, 2006 by
          David Turner, Robert Wilhelm, and Werner Lemberg



Introduction
============

  The FreeType  Project is distributed in  several archive packages;
  some of them may contain, in addition to the FreeType font engine,
  various tools and  contributions which rely on, or  relate to, the
  FreeType Project.

  This  license applies  to all  files found  in such  packages, and
  which do not  fall under their own explicit  license.  The license
  affects  thus  the  FreeType   font  engine,  the  test  programs,
  documentation and makefiles, at the very least.

  This  license   was  inspired  by  the  BSD,   Artistic,  and  IJG
  (Independent JPEG  Group) licenses, which  all encourage inclusion
  and  use of  free  software in  commercial  and freeware  products
  alike.  As a consequence, its main points are that:

    o We don't promise that this software works. However, we will be
      interested in any kind of bug reports. (`as is' distribution)

    o You can  use this software for whatever you  want, in parts or
      full form, without having to pay us. (`royalty-free' usage)

    o You may not pretend that  you wrote this software.  If you use
      it, or  only parts of it,  in a program,  you must acknowledge
      somewhere  in  your  documentation  that  you  have  used  the
      FreeType code. (`credits')

  We  specifically  permit  and  encourage  the  inclusion  of  this
  software, with  or without modifications,  in commercial products.
  We  disclaim  all warranties  covering  The  FreeType Project  and
  assume no liability related to The FreeType Project.


  Finally,  many  people  asked  us  for  a  preferred  form  for  a
  credit/disclaimer to use in compliance with this license.  We thus
  encourage you to use the following text:

   """
    Portions of this software are copyright © <year> The FreeType
    Project (www.freetype.org).  All rights reserved.
   """

  Please replace <year> with the value from the FreeType version you
  actually use.


Legal Terms
===========

0. Definitions
--------------

  Throughout this license,  the terms `package', `FreeType Project',
  and  `FreeType  archive' refer  to  the  set  of files  originally
  distributed  by the  authors  (David Turner,  Robert Wilhelm,  and
  Werner Lemberg) as the `FreeType Project', be they named as alpha,
  beta or final release.

  `You' refers to  the licensee, or person using  the project, where
  `using' is a generic term including compiling the project's source
  code as  well as linking it  to form a  `program' or `executable'.
  This  program is  referred to  as  `a program  using the  FreeType
  engine'.

  This  license applies  to all  files distributed  in  the original
  FreeType  Project,   including  all  source   code,  binaries  and
  documentation,  unless  otherwise  stated   in  the  file  in  its
  original, unmodified form as  distributed in the original archive.
  If you are  unsure whether or not a particular  file is covered by
  this license, you must contact us to verify this.

  The FreeType  Project is copyright (C) 1996-2000  by David Turner,
  Robert Wilhelm, and Werner Lemberg.  All rights reserved except as
  specified below.

1. No Warranty
--------------

  THE FREETYPE PROJECT  IS PROVIDED `AS IS' WITHOUT  WARRANTY OF ANY
  KIND, EITHER  EXPRESS OR IMPLIED,  INCLUDING, BUT NOT  LIMITED TO,
  WARRANTIES  OF  MERCHANTABILITY   AND  FITNESS  FOR  A  PARTICULAR
  PURPOSE.  IN NO EVENT WILL ANY OF THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE  FOR ANY DAMAGES CAUSED  BY THE USE OR  THE INABILITY TO
  USE, OF THE FREETYPE PROJECT.

2. Redistribution
-----------------

  This  license  grants  a  worldwide, royalty-free,  perpetual  and
  irrevocable right  and license to use,  execute, perform, compile,
  display,  copy,   create  derivative  works   of,  distribute  and
  sublicense the  FreeType Project (in  both source and  object code
  forms)  and  derivative works  thereof  for  any  purpose; and  to
  authorize others  to exercise  some or all  of the  rights granted
  herein, subject to the following conditions:

    o Redistribution of  source code  must retain this  license file
      (`FTL.TXT') unaltered; any  additions, deletions or changes to
      the original  files must be clearly  indicated in accompanying
      documentation.   The  copyright   notices  of  the  unaltered,
      original  files must  be  preserved in  all  copies of  source
      files.

    o Redistribution in binary form must provide a  disclaimer  that
      states  that  the software is based in part of the work of the
      FreeType Team,  in  the  distribution  documentation.  We also
      encourage you to put an URL to the FreeType web page  in  your
      documentation, though this isn't mandatory.

  These conditions  apply to any  software derived from or  based on
  the FreeType Project,  not just the unmodified files.   If you use
  our work, you  must acknowledge us.  However, no  fee need be paid
  to us.

3. Advertising
--------------

  Neither the  FreeType authors and  contributors nor you  shall use
  the name of the  other for commercial, advertising, or promotional
  purposes without specific prior written permission.

  We suggest,  but do not require, that  you use one or  more of the
  following phrases to refer  to this software in your documentation
  or advertising  materials: `FreeType Project',  `FreeType Engine',
  `FreeType library', or `FreeType Distribution'.

  As  you have  not signed  this license,  you are  not  required to
  accept  it.   However,  as  the FreeType  Project  is  copyrighted
  material, only  this license, or  another one contracted  with the
  authors, grants you  the right to use, distribute,  and modify it.
  Therefore,  by  using,  distributing,  or modifying  the  FreeType
  Project, you indicate that you understand and accept all the terms
  of this license.

4. Contacts
-----------

  There are two mailing lists related to FreeType:

    o freetype@nongnu.org

      Discusses general use and applications of FreeType, as well as
      future and  wanted additions to the  library and distribution.
      If  you are looking  for support,  start in  this list  if you
      haven't found anything to help you in the documentation.

    o freetype-devel@nongnu.org

      Discusses bugs,  as well  as engine internals,  design issues,
      specific licenses, porting, etc.

  Our home page can be found at

    https://www.freetype.org
```

### MIT

```plaintext
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
```



================================================
File: docs/PRD.md
================================================
# Night Engine - Product Requirements Document

## 1. Introduction

- **Project Idea:** Night Engine is a C# game engine built on SDL3, designed to provide a "batteries-included" development experience. It features a Love2D-inspired API for its foundational framework (`Night.Framework`), with plans for a more opinionated, higher-level engine (`Night.Engine`) to be built on top, offering common game systems. The project also aims to be AI-friendly to assist non-programmers in game development.

- **Problem/Need:** The primary goal is to offer C# developers a streamlined and efficient workflow for game and multimedia development. `Night.Framework` provides direct, SDL3-powered capabilities through a familiar API style, reducing context switching. The future `Night.Engine` will further simplify complex game development tasks.

- **Development Goal:** The current development phase focuses on completing the core features of `Night.Framework` to align with Version 0.1.0 of the API roadmap, providing a robust C# wrapper layer that leverages SDL3's capabilities with an API style reminiscent of Love2D. Future phases will concentrate on building out `Night.Engine` components and subsequent roadmap versions.

## 2. Core Features

### Night.Framework (Love2D-style API)

The following features are largely implemented for the foundational framework:

- **Feature 0: Project Foundation & SDL3 Integration:**

  - **Description:** Established C# project structure for `Night.Engine` (which encompasses `Night.Framework` and placeholders for future engine components) and `Night.SampleGame`. Utilizes `SDL3-CS` C# bindings (via NuGet package) for SDL3 integration. Native SDL3 libraries (for core, image, mixer, ttf) are fetched using the `scripts/sync_sdl3.py` script into `lib/SDL3-Prebuilt/` and included in the `Night.SampleGame` build.

  - **Status:** Mostly Complete (Epics 1 & 8).

- **Feature 1: Window Management (`Night.Window`):**

  - **Description:** Provides capabilities to create, configure (mode, title), and manage the application window (check if open, close). Uses the `Night` namespace with an API style similar to Love2D's `love.window`.

  - **Implemented Functions:** `SetMode`, `SetTitle`, `IsOpen`, `Close`, internal `Shutdown`.

  - **Status:** Largely Complete (Epic 3).

- **Feature 2: Input Handling (Keyboard and Mouse):**

  - **Description:** Allows polling of keyboard (`Night.Keyboard`) and mouse (`Night.Mouse`) states. Mirrors Love2D's `love.keyboard` and `love.mouse` modules.

  - **Implemented Functions:** `Night.Keyboard.IsDown`, `Night.Mouse.IsDown`, `Night.Mouse.GetPosition`. Event `IGame.KeyPressed` is also implemented.

  - **Status:** Largely Complete (Epic 4).

- **Feature 3: 2D Graphics Rendering (`Night.Graphics`):**

  - **Description:** Enables loading images (`.png` via SDL_image) as sprites and drawing them. Includes screen clearing and frame presentation. Leverages SDL_Renderer.

  - **Implemented Functions:** `NewImage` (for sprites), `Draw` (for sprites with transformations), `Clear`, `Present`.

  - **Status:** Largely Complete (Epic 5).

- **Feature 4: Game Loop Structure (`Night.Framework.Run`):**

  - **Description:** Provides a pre-defined game loop managed by `Night.Framework`. Developers implement `Night.IGame` interface callbacks (`Load`, `Update`, `Draw`, `KeyPressed`). Includes delta time calculation and event polling (Quit, KeyDown).

  - **Status:** Largely Complete (Epic 6).

- **Feature 5: Sample Game & Integration Testing (`Night.SampleGame`):**

  - **Description:** A simple platformer game demonstrating the use of `Night.Framework` features. Includes player movement, collision, and basic level structure. Platform message simplification for macOS also completed.

  - **Status:** Implemented (Epics 7 & 9).

### Night.Engine (Future - High-Level Opinionated Systems)

These are planned features for the higher-level engine, to be built upon `Night.Framework`:

- Entity Component System (ECS)

- Scene Management & Scene Graph

- Advanced Asset Management

- Physics Integration (Optional)

- Joystick Manager

## 3. Technical Specifications

- **Primary Language(s):** C# 13 (using .NET 9).

- **Key Frameworks/Libraries:**

  - SDL3 (latest version).

  - C# Bindings: `edwardgushchin/SDL3-CS` (SDL3#) via NuGet package (`SDL3-CS`).

  - Native Binaries:

    - SDL3 (core, SDL_image, SDL_mixer, SDL_ttf) native libraries are fetched by the `scripts/sync_sdl3.py` script into the `lib/SDL3-Prebuilt/` directory.

    - The `Night.SampleGame` project copies these required native binaries (e.g., `SDL3.dll`, `SDL3_image.dll`) to its output directory during build to ensure they are available at runtime.

  - No other external runtime libraries are currently planned for `Night.Framework`.

- **Database:** None.

- **Key APIs/Integrations:** Direct interaction with SDL3 via SDL3-CS C# bindings.

- **Rendering Backend:**

  - `Night.Framework` utilizes SDL_Renderer for 2D graphics operations.

  - Future consideration: Migration to SDL_GPU.

- **Deployment Target:**

  - `Night` (containing `Night.Framework` and `Night.Engine`) is a C# class library (DLL named `Night.dll`).

  - `Night.SampleGame` is a C# console application that consumes `Night`.

- **Target Platforms:** Current focus on Windows, macOS, Linux. Long-term goals include iOS and Android. Console support is a distant stretch goal.

- **High-Level Architectural Approach:**

  - **Night.Framework:** A C# library providing a static API, stylistically similar to Love2D, over the SDL3 native library (via SDL3-CS). Public API primarily within the `Night` C# namespace. This is part of the `Night.dll`.

  - **Night.Engine:** (Future) A C# library providing opinionated game development constructs (e.g., ECS, scene management), using `Night.Framework` for low-level operations. This will also be part of `Night.dll` under the `Night.Engine` namespace.

- **Critical Technical Decisions/Constraints:**

  - The public API of `Night.Framework` aims to mirror the Love2D API where practical and idiomatic for C#.

  - All interactions with SDL3 within `Night.Framework` are through the SDL3-CS bindings. `Night.Engine` will not use SDL3-CS directly.

  - Simplicity and achieving the core Love2D-like developer experience are primary focuses for `Night.Framework`.

## 4. Project Structure

```mermaid
graph TD
    A(any2) --> B(README.md);
    A --> C(LICENSE);
    A --> D(Night.sln);
    A --> E(.editorconfig);
    A --> F(.pre-commit-config.yaml);
    A --> G(docs);
    A --> H(lib);
    A --> I(licenses);
    A --> J(scripts);
    A --> K(src);
    A --> L(.cursor);
    A --> M(.github);
    A --> N(.roo);
    A --> O(.windsurf);

    G --> G1(NOTICE.md);
    G --> G2(PRD.md);
    G --> G3(operational-guidelines.md);
    G --> G4(epics);
    G4 --> G4_1(epic1.md);
    G4 --> G4_2(epic2.md);
    G4 --> G4_3(epic3.md);
    G4 --> G4_4(epic4.md);
    G4 --> G4_5(epic5.md);
    G4 --> G4_6(epic6.md);
    G4 --> G4_7("epic7-design.md");
    G4 --> G4_8(epic7.md);
    G4 --> G4_9(epic8.md);
    G4 --> G4_10(epic9.md);
    G --> G5(love2d-api);
    G5 --> G5_1(roadmap.md);
    G5 --> G5_2(modules);
    G5_2 --> G5_2_1(audio.md);
    G5_2 --> G5_2_2(data.md);
    G5_2 --> G5_2_3(event.md);
    G5_2 --> G5_2_4(filesystem.md);
    G5_2 --> G5_2_5(font.md);
    G5_2 --> G5_2_6(graphics.md);
    G5_2 --> G5_2_7(image.md);
    G5_2 --> G5_2_8(joystick.md);
    G5_2 --> G5_2_9(keyboard.md);
    G5_2 --> G5_2_10(love.md);
    G5_2 --> G5_2_11(math.md);
    G5_2 --> G5_2_12(mouse.md);
    G5_2 --> G5_2_13(sound.md);
    G5_2 --> G5_2_14(system.md);
    G5_2 --> G5_2_15(thread.md);
    G5_2 --> G5_2_16(timer.md);
    G5_2 --> G5_2_17(touch.md);
    G5_2 --> G5_2_18(video.md);
    G5_2 --> G5_2_19(window.md);

    J --> J1(sync_sdl3.py);

    K --> K1(src/Night);
    K1 --> K1_1(FrameworkLoop.cs);
    K1 --> K1_2(Night.csproj);
    K1 --> K1_3(Types.cs);
    K1 --> K1_4(Engine);
    K1_4 --> K1_4_1(.gitkeep);
    K1 --> K1_M_Graphics(Graphics/);
    K1_M_Graphics --> K1_M_G_Graphics_cs(Graphics.cs);
    K1 --> K1_M_Window(Window/);
    K1_M_Window --> K1_M_W_Window_cs(Window.cs);
    K1 --> K1_6(Utilities);
    K1_6 --> K1_6_1(.gitkeep);
    K1 --> K1_7(bin);
    K1 --> K1_8(obj);

    K --> K2(Night.SampleGame);
    K2 --> K2_1(Night.SampleGame.csproj);
    K2 --> K2_2(Player.cs);
    K2 --> K2_3(Program.cs);
    K2 --> K2_4(Samples);
    K2_4 --> K2_4_1(Platformer.cs);
    K2 --> K2_5(assets);
    K2_5 --> K2_5_1(images);
    K2_5_1 --> K2_5_1_1(pixel_green.pixi);
    K2_5_1 --> K2_5_1_2(player_sprite_blue_32x64.aseprite);
    K2 --> K2_6(bin);
    K2 --> K2_7(obj);

    M --> M1(CODEOWNERS);
    M --> M2(copilot-instructions.md);
    M --> M3(dependabot.yml);
    M --> M4(deactivated);
    M4 --> M4_1(build-sdl3.yml);
    M4 --> M4_2(ci.yml);
    M4 --> M4_3(codeql.yml);
    M4 --> M4_4(dependency-review.yml);
    M4 --> M4_5(release.yml);
    M4 --> M4_6(scorecard.yml);
    M --> M5(scripts);
    M5 --> M5_1(determine_next_version.py);
```

- `/docs`: Project documentation (PRD, operational guidelines, epics, API mapping, etc.).

- `/lib`: Contains `SDL3-Prebuilt/` populated by `sync_sdl3.py` and potentially other third-party libraries.

- `/scripts`: Utility scripts for the project (e.g., `sync_sdl3.py`).

- `/src`: Contains all C# source code.

  - `/src/Night`: C# class library project for `Night.Framework` and future `Night.Engine` components. This project references the `SDL3-CS` NuGet package and produces `Night.dll`.

    - `Night.csproj`: MSBuild project file.

    - `FrameworkLoop.cs`: Manages the main game loop (`Night.Framework.Run()`) and event polling.

    - `Types.cs`: Defines core data types and interfaces (e.g., `Night.Color`, `Night.KeyCode`, `Night.KeySymbol`, `Night.Sprite`, `Night.IGame`, `Night.MouseButton`, `Night.Rectangle`).

    - Module directories (e.g., `/Graphics/`, `/Window/`): Contain individual C# files for each Love2D-like framework module (e.g., `Graphics.cs`, `Window.cs`). These primarily contain static classes within the `Night` namespace or sub-namespaces like `Night.Graphics`.

    - `/Engine/`: Directory for future high-level engine components, which will reside in the `Night.Engine` namespace. Contains `.gitkeep`.

    - `/Utilities/`: Placeholder for utility classes. Contains `.gitkeep`.

  - `/src/Night.SampleGame`: C# console application project demonstrating the use of `Night.Framework`.

    - `Night.SampleGame.csproj`: MSBuild project file. References `Night` (the `Night.dll`) and includes native SDL binary deployment logic.

    - `Program.cs`: Main entry point and `IGame` implementation for the sample game.

    - `Player.cs`: Player logic for the sample platformer game.

    - `/Samples/Platformer.cs`: Contains an alternative or modularized `Platformer` game class.

    - `/assets`: Game assets (images, etc.) for the sample game.

- `Night.sln`: Visual Studio solution file.

- `README.md`: Main project readme.

- `.github/`: GitHub-specific files including active `dependabot.yml` and `CODEOWNERS`, plus deactivated workflows.

- `.editorconfig`, `.pre-commit-config.yaml`: Code style and pre-commit hook configurations.

## 5. File Descriptions

- **`Night.sln`**: Visual Studio Solution file grouping `Night.Engine` and `Night.SampleGame` projects. Defines project paths and configurations.

- **`src/Night/Night.csproj`**: The MSBuild project file for the main `Night` C# class library. This library, `Night.dll`, includes the `Night` namespace (for the Love2D-like framework) and the `Night.Engine` namespace (for future higher-level engine features).

- **`src/Night.SampleGame/Night.SampleGame.csproj`**: MSBuild project file for the sample game application. References `Night` (the `Night.dll`) and includes steps to copy native SDL3 binaries (from `lib/SDL3-Prebuilt/`) to the output directory.

## 6. Future Considerations (Post Version 0.1.0)

**Out of Scope for Version 0.1.0 (Night.Framework):** (Based on `roadmap.md` and existing "Out of Scope" items from `docs/love2d-api/modules/*.md` for modules beyond 0.1.0, and previous PRD version)

- **Full Love2D API Parity:** Modules and features beyond those specified for v0.1.0 in `roadmap.md`. This includes:

  - `love.audio` and `love.sound` (Audio playback, recording, effects, decoding).

  - `love.joystick` (Gamepad/joystick support).

  - `love.event` (User-managed event queue, custom event pushing beyond basic callbacks).

  - `love.font` (Advanced font rendering, rasterizers beyond basic text if not part of Graphics 0.1.0).

  - `love.thread` (User-managed threading abstractions).

  - `love.touch` (Touchscreen input).

  - `love.video` (Video playback).

  - `love.data` (Compression, encoding, hashing beyond standard .NET libraries if specific Love2D behavior is needed).

  - `love.math` (Advanced math functions like noise, triangulation, Bezier curves beyond System.Math).

  - `love.system` (Clipboard, power info, openURL, etc., beyond basic OS info).

- **Advanced Rendering in Night.Framework:** Custom shaders, 3D graphics, complex lighting, particle systems beyond what SDL_Renderer offers for 2D and what's planned for 0.1.0 graphics.

- **Game Packaging/Distribution Tools, Editor/GUI Tools:** Not included.

**Potential Future Enhancements (Post-0.1.0, or as part of Night.Engine):**

- **Night.Engine Core:**

  - Entity Component System (ECS) Architecture.

  - Scene Management & Scene Graph.

  - Advanced Game State Management.

- **Expanded Night.Framework Modules (as per roadmap.md versions > 0.1.0):**

  - Audio Module (`Night.Audio`)

  - Font Rendering (`Night.Font`)

  - Expanded Input (`Night.Joystick`, `Night.Touch`)

  - More Graphics Primitives & Features in `Night.Graphics` (shapes, basic shader integration, camera).

  - Filesystem Abstraction (`Night.Filesystem` - beyond basic 0.1.0 needs).

  - Timing Module (`Night.Timer` - beyond basic 0.1.0 needs).

- **Tooling & Developer Experience:**

  - Dear ImGui Integration.

  - Quake-Style Debug Console.

  - Lua Scripting Interface.

- **General:**

  - Improved Error Handling & Debugging Tools.

  - Performance Profiling and Optimization.

  - Expanded Platform Support Verification (Android, iOS).

  - Community Building: Tutorials, more examples, comprehensive documentation.



================================================
File: docs/operational-guidelines.md
================================================
# Operational Guidelines

The "Night" engine project will ALWAYS adhere to the **Google C# Style Guide**. Key aspects of this guide, supplemented by project-specific interpretations, are outlined below.

- **Formatting & Style:**
  - **Indentation:** 2 spaces, no tabs.
  - **Column Limit:** 100 characters.
  - **Whitespace, Braces, Line Wrapping:** Adhere to the detailed rules in the Google C# Style Guide. This includes rules like no line break before an opening brace, and braces used even when optional.
  - **Tooling:**
    - `dotnet format` will be used to help enforce formatting rules.
    - An `.editorconfig` file will be added to the project root, configured to align with the Google C# Style Guide's formatting and style rules (e.g., indentation, column limit, using directives order).
  - Format the `using` directives with specific spacing. Place all System.* directives first, followed by a blank line. Then, group other using directives (like third-party libraries or project-specific namespaces) logically, and insert a blank line between each distinct group. For example, list System usings, then a blank line, then Night usings, then a blank line, then SDL3 usings, rather than listing them all contiguously.
  -`using` directives should NEVER have any comments associated with them or on the same line
- **Linting:**
  - **Tooling:** Utilize Roslyn Analyzers provided with the .NET SDK.
  - The `.editorconfig` file will be configured to enable and set the severity of analyzer rules to align with the principles of the Google C# Style Guide. This includes rules related to naming, organization, and other code quality aspects.
- **Naming Conventions:**
  - **General Rules Summary:**
    - Names of classes, methods, enumerations, public fields, public properties, namespaces: `PascalCase`.
    - Names of local variables, parameters: `camelCase`.
    - Names of private, protected, internal, and protected internal fields and properties: `_camelCase` (e.g., `_privateField`).
    - Naming convention is unaffected by modifiers such as `const`, `static`, `readonly`, etc..
    - For casing, a “word” is anything written without internal spaces, including acronyms (e.g., `MyRpc` not `MyRPC`).
    - Names of interfaces start with `I` (e.g., `IInterface`).
    - Filenames and directory names are `PascalCase` (e.g., `MyFile.cs`).
  - **Project Specific (API Design):** When naming public API elements for "Night" intended to mirror Love2D functions (e.g., `love.window.setTitle`), use the `PascalCase` version adhering to the above rules (e.g., `Night.Window.SetTitle(...)`).
- **Code Organization:**
  - **Modifier Order:** `public protected internal private new abstract virtual override sealed static readonly extern unsafe volatile async`.
  - **Namespace `using` Declarations:** Place at the top of the file, before any namespace declarations. Order alphabetically, with `System` imports always first.
  - **Class Member Ordering:** Follow the prescribed order: Nested types, static/const/readonly fields, instance fields/properties, constructors/finalizers, methods. Within each group, elements are ordered by access: Public, Internal, Protected internal, Protected, Private.
- **Key Principles (Project-Specific additions and emphasis):**
  - **API Design (Night Engine):** Strive for an API design that is idiomatic to C# while closely mirroring the spirit, structure, and ease of use of the Love2D API for the features being implemented.
  - **Clarity over Premature Optimization:** For the prototype, prioritize clear, understandable, and maintainable code.
  - **Scope Adherence:** Focus strictly on implementing the agreed-upon features (0-4) for this prototype.
- **Testing (if applicable for prototype):**
  - **Primary Integration Test:** The `Night.SampleGame` project will serve as the main method for testing the integration and functionality of the `Night.Framework`/`Night.Engine` features. Write the necessary code to test out new functionality in the SampleGame project to allow the user to manually verify. The `Program.cs` file in the SampleGame project is the best place to put this code.
  - **Unit Tests (Optional):** Consider adding basic unit tests for any complex internal helper functions or critical non-P/Invoke logic within `Night.Framework`.
  - **Manual Verification:** Manual testing of the sample game against the defined user actions and outcomes for each feature in the PRD will be essential.

## Mapping Native SDL3 Functions to SDL3-CS (C#) Bindings

When working with the `lib/SDL3-CS` C# wrapper for SDL3, it's often necessary to find the C# equivalent of a native SDL3 C function, enum, or struct. This section provides guidance on that process. The `lib/SDL3-CS` bindings are located in the `lib/SDL3-CS/SDL3-CS/` directory.

**1. Naming Conventions:**

*   **Functions:** Native SDL3 functions (e.g., `SDL_CreateWindow`, `SDL_PollEvent`) are generally mapped to C# methods within the static `SDL` class using PascalCase. The `SDL_` prefix is removed, and the rest of the name is converted to PascalCase.
    *   `SDL_CreateWindow` becomes `SDL.CreateWindow()`
    *   `SDL_PollEvent` becomes `SDL.PollEvent()`
*   **Enums and Structs:** Native SDL3 enums and structs (e.g., `SDL_WindowFlags`, `SDL_Event`, `SDL_Keycode`) are typically mapped to C# enums or structs within the `SDL` static class (or directly in the `SDL3` namespace if they are complex types used by the static class members), also using PascalCase.
    *   `SDL_WindowFlags` becomes `SDL.WindowFlags` (enum)
    *   `SDL_Event` becomes `SDL.Event` (struct)
    *   `SDL_Keycode` becomes `SDL.Keycode` (enum)
*   **Constants:** Native SDL3 `#define` constants (e.g., `SDL_INIT_VIDEO`) are usually mapped to enum members or `public const int` fields within the relevant C# enum or static class.
    *   `SDL_INIT_VIDEO` becomes `SDL.InitFlags.Video`

**2. File Structure of `lib/SDL3-CS/SDL3-CS/SDL/`:**

The C# source files for the core SDL3 bindings are primarily located under `lib/SDL3-CS/SDL3-CS/SDL/`. This directory is further organized into subdirectories that often mirror SDL3's own categorization of its API (e.g., `Basics`, `Video`, `Audio`, `Input Events`, `GPU`).

*   **P/Invoke Declarations:** The actual `[LibraryImport]` or `[DllImport]` attributes for native functions are often found in files named `PInvoke.cs` within the relevant subdirectory (e.g., [`lib/SDL3-CS/SDL3-CS/SDL/Basics/init/PInvoke.cs`](lib/SDL3-CS/SDL3-CS/SDL/Basics/init/PInvoke.cs:1) for `SDL_Init`, [`lib/SDL3-CS/SDL3-CS/SDL/Video/video/PInvoke.cs`](lib/SDL3-CS/SDL3-CS/SDL/Video/video/PInvoke.cs:1) for windowing functions).
*   **Enum and Struct Definitions:** These are typically in their own dedicated `.cs` files, named after the type (e.g., [`lib/SDL3-CS/SDL3-CS/SDL/Video/video/WindowFlags.cs`](lib/SDL3-CS/SDL3-CS/SDL/Video/video/WindowFlags.cs:1), [`lib/SDL3-CS/SDL3-CS/SDL/Input Events/events/Event.cs`](lib/SDL3-CS/SDL3-CS/SDL/Input%20Events/events/Event.cs:1), [`lib/SDL3-CS/SDL3-CS/SDL/Input Events/keycode/Keycode.cs`](lib/SDL3-CS/SDL3-CS/SDL/Input%20Events/keycode/Keycode.cs:1)).
*   **Partial Class `SDL`:** The main C# static class `SDL` (in the `SDL3` namespace) is defined as a `partial class`. This means its members (P/Invoke methods, nested enums/structs, helper functions) are spread across multiple files within these subdirectories but are all part of the single `SDL3.SDL` static class from the perspective of an API consumer.

**3. Strategy for Finding C# Equivalents:**

*   **Identify the Native SDL3 Element:** Start with the name of the native C function, enum, struct, or constant you need (e.g., `SDL_GetWindowFlags`, `SDL_EventType`, `SDL_SCANCODE_A`).
*   **Apply C# Naming Conventions:**
    *   Remove `SDL_` prefix.
    *   Convert to `PascalCase` (e.g., `GetWindowFlags`, `EventType`, `ScancodeA`). Note that for constants like scancodes, the C# enum member might be simpler (e.g. `SDL.Scancode.A`).
*   **Determine the SDL Subsystem:** Understand which part of SDL the function belongs to (e.g., Video, Events, Keyboard, Mouse). This will guide you to the likely subdirectory in `lib/SDL3-CS/SDL3-CS/SDL/`.
    *   Example: `SDL_CreateWindow` is a Video function. Look in `lib/SDL3-CS/SDL3-CS/SDL/Video/video/`.
    *   Example: `SDL_PollEvent` is an Event function. Look in `lib/SDL3-CS/SDL3-CS/SDL/Input Events/events/`.
*   **Search within the Subsystem Directory:**
    *   For functions, check `PInvoke.cs` files first.
    *   For enums/structs, look for a `.cs` file matching the PascalCase name (e.g., `EventType.cs`, `WindowFlags.cs`).
    *   The C# equivalent will typically be a static method or nested type of `SDL3.SDL` (e.g., `SDL.CreateWindow()`, `SDL.EventType`, `SDL.WindowFlags`).
*   **Use Code Search:** If the location isn't immediately obvious:
    *   Use your IDE's search functionality (or a command-line tool like `grep` or `rg`) within the `lib/SDL3-CS/SDL3-CS/SDL/` directory.
    *   Search for the PascalCase C# name (e.g., `CreateWindow`).
    *   Search for the native C name (e.g., `SDL_CreateWindow`) as it often appears in comments or `EntryPoint` attributes of P/Invoke declarations (e.g., `[LibraryImport(SDLLibrary, EntryPoint = "SDL_CreateWindow")]`).
*   **Consult SDL3 Wiki & SDL3-CS Examples:**
    *   The official [SDL Wiki](https://wiki.libsdl.org/SDL3/FrontPage) provides documentation for the native SDL3 API. Understanding the native function's purpose and parameters helps.
    *   The `SDL3-CS` repository includes examples in `lib/SDL3-CS/SDL3-CS.Examples/` which demonstrate common usage patterns.

**4. Key C# Idioms and Marshalling in SDL3-CS:**

Be aware of common C# idioms used in the bindings:

*   **Return Values for Success/Failure:** Many SDL C functions return `0` for success and a negative value for error. In SDL3-CS, these are often converted to `bool`, where `true` indicates success and `false` indicates failure. Use `SDL.GetError()` to get detailed error information. (e.g., `SDL.Init()` returns `bool`).
*   **String Marshalling:**
    *   `const char*` input parameters in C are often marshalled as `string` in C#.
    *   `char*` (for output strings from SDL) or `const char*` return values from SDL might be marshalled as `string`, or sometimes as `IntPtr` requiring manual marshalling (e.g., using `Marshal.PtrToStringUTF8()` or `SDL.PtrToStringUTF8()` if available). SDL3-CS aims for direct `string` usage where idiomatic.
*   **Pointer Parameters (`*`, `**`):**
    *   Pointers to simple types or structs passed by value to C functions might become `ref` or `out` parameters in C# for structs, or direct value types (`int`, `float`).
    *   `SDL_Event*` in C (like in `SDL_PollEvent(SDL_Event* event)`) becomes `out SDL.Event e` or `ref SDL.Event e` in C#.
    *   Opaque pointers (handles like `SDL_Window*`, `SDL_Renderer*`) are typically represented as `IntPtr` in C# or wrapped in dedicated C# classes/structs if the binding provides higher-level abstractions. SDL3-CS often uses `IntPtr` for these handles.
*   **Enums:** C enums are mapped to C# enums, often with the `[Flags]` attribute if they are bitmasks.
*   **Callbacks:** C function pointers for callbacks are mapped to C# delegates.
*   **Helper Methods:** The `SDL` static class in SDL3-CS includes various helper methods for marshalling and pointer manipulation (e.g., `SDL.PointerToStructure<T>()`, `SDL.StructureToPointer<T>()`, `SDL.StringToPointer()`). These can be useful if you need to interact with more complex native patterns not fully abstracted by a direct C# method.

*   **Troubleshooting SDL Extension Libraries (e.g., SDL3_image, SDL3_ttf) with SDL3-CS:**
    *   SDL extension libraries (like `SDL3_image` for image loading or `SDL3_ttf` for font rendering) provide specialized functionality on top of the core SDL3 library. While `SDL3-CS` provides bindings for these, their interaction with core SDL3 features (like the properties system for `SDL_Texture`) might not always be straightforward or fully documented externally.
    *   **Problem Identification:** If a function from an SDL extension library (e.g., `SDL3.Image.LoadTexture()`) returns an SDL object (like an `SDL_Texture`), but subsequent attempts to use standard SDL3 mechanisms on that object (e.g., `SDL.GetTextureProperties()` to get dimensions) fail or don't yield expected results, it might indicate that the extension library handles or exposes information differently.
    *   **Investigation Strategy:**
        1.  **Consult Official SDL Wiki:** First, check the official SDL Wiki (or the specific extension library's documentation, if available and linked) for guidance on the function in question and how it interacts with core SDL types. However, be aware that C# binding specifics might not be covered.
        2.  **Examine SDL3-CS Bindings Directly:** If official documentation is insufficient or doesn't clarify the C# binding behavior, the most reliable source of truth is the `SDL3-CS` library's source code itself (located in `lib/SDL3-CS/SDL3-CS/`).
            *   Look for the C# wrapper function corresponding to the native SDL extension library function you're using (e.g., in `lib/SDL3-CS/SDL3-CS/Image/PInvoke.cs` for `SDL3_image` functions).
            *   See if the extension library offers alternative C# functions within its own namespace (e.g., `SDL3.Image.Load()` to load to an `SDL_Surface` first, from which dimensions can be reliably obtained before converting to an `SDL_Texture`).
            *   Check how the C# structs for relevant types (e.g., `SDL.Surface` in `lib/SDL3-CS/SDL3-CS/SDL/Video/surface/Surface.cs`) are defined to understand how to access their members (like `Width`, `Height`) after marshalling an `IntPtr`.
        3.  **Consider Intermediate Steps:** Sometimes, an extension library might require or work more reliably with an intermediate step. For example, instead of directly loading an image to an `SDL_Texture`, loading it to an `SDL_Surface` first (using a function from the image extension library), then getting information from the `SDL_Surface` (which is a well-defined core SDL structure), and finally creating the `SDL_Texture` from the `SDL_Surface` using a core SDL function (e.g., `SDL.CreateTextureFromSurface()`) can be a more robust approach. Remember to manage the lifecycle of intermediate objects (like freeing the `SDL_Surface` after the texture is created).
        4.  **Error Checking:** Always check return values from SDL functions. For functions from extension libraries, use the standard `SDL.GetError()` to retrieve error messages, as specific `Extension.GetError()` functions may not exist or be necessary.
By understanding these conventions and the structure of the `lib/SDL3-CS` library, an AI (or human developer) can more effectively locate and utilize the C# equivalents of native SDL3 functionalities.



================================================
File: docs/testing-plan.md
================================================
# Night.Engine Testing Plan

## 1. Introduction and Philosophy

This document outlines the testing strategy for the `Night.Engine` project, specifically focusing on unit testing its constituent modules. The primary goal is to ensure the reliability and correctness of individual components within the engine.

The testing philosophy draws inspiration from Love2D's module-based testing approach, aiming to test each logical module of `Night.Engine` as independently as possible. We will use xUnit as the primary testing framework for C#.

This plan adheres to the standards and guidelines set forth in the `operational-guidelines.md` and aligns with the project goals detailed in `PRD.md`.

## 2. Testing Framework

- **Framework:** xUnit.net
- **Assertion Library:** xUnit's built-in assertions.

## 3. Test Project Structure

A dedicated test project will be created for `Night.Engine` tests:

- **Project Name:** `Night.Engine.Tests`
- **Location:** `src/Night.Engine.Tests/` (This is a recommendation; final location to be decided based on solution structure).
- **Dependencies:** This project will reference the `Night.Engine` project.

## 4. Naming Conventions

Consistency in naming is crucial for maintainability and readability of tests.

- **Test Classes:**
    - Named after the class or module being tested, suffixed with `Tests`.
    - Example: `GraphicsTests.cs` for testing `Night.Graphics`, `WindowTests.cs` for `Night.Window`.
- **Test Methods:**
    - Follow the pattern: `[MethodUnderTest]_[ScenarioOrCondition]_[ExpectedBehavior]`
    - `[MethodUnderTest]`: The name of the method being tested.
    - `[ScenarioOrCondition]`: A brief description of the specific test case or input conditions.
    - `[ExpectedBehavior]`: The expected outcome or state.
    - Example: `SetMode_ValidResolution_ReturnsTrue`, `IsOpen_WhenWindowIsActive_ReturnsTrue`, `Draw_NullSprite_ThrowsArgumentNullException`.

## 5. Scope of Testing - Night.Engine Modules

The following modules and components within `Night.Engine` are the primary targets for unit testing. Given that `Night.Engine` (specifically `Night.Framework`) largely consists of static classes providing a Love2D-like API over SDL3, tests will focus on the C# logic, parameter validation, and correct invocation patterns where feasible.

### 5.1. `Night.Framework` Modules:

These modules are typically static classes in the `Night` namespace.

-   **`Night.Window` (`Window.cs`)**
    -   Test methods like `SetMode`, `SetTitle`, `IsOpen`, `Close`.
    -   Focus on parameter validation (e.g., null title, invalid dimensions for `SetMode` if applicable before SDL call).
    -   Testing the actual window manipulation might be difficult in pure unit tests and leans towards integration testing (covered by `Night.SampleGame`). We can, however, test the C# logic paths before SDL calls.
-   **`Night.Graphics` (`Graphics.cs`)**
    -   Test methods like `NewImage`, `Draw`, `Clear`, `Present`.
    -   Parameter validation (e.g., null paths for `NewImage`, null sprites for `Draw`).
    -   Testing actual rendering output is an integration concern. Unit tests should focus on the C# logic (e.g., does `Draw` handle transform parameters correctly before passing to SDL?).
-   **`Night.Keyboard` (`Keyboard.cs`)**
    -   Test methods like `IsDown`.
    -   Focus on validating input parameters (e.g., specific `KeyCode` values).
    -   Directly testing key states requires OS-level interaction, which is beyond typical unit test scope. Tests might focus on internal logic if any exists separate from direct SDL calls.
-   **`Night.Mouse` (`Mouse.cs`)**
    -   Test methods like `IsDown`, `GetPosition`.
    -   Similar to Keyboard, parameter validation for `MouseButton`.
    -   Testing actual mouse states/positions is an integration concern.
-   **`Night.SDL` (`SDL.cs`)**
    -   This module directly wraps SDL3 P/Invoke calls.
    -   Unit testing P/Invoke wrappers is complex and often provides limited value compared to the effort.
    -   Focus should be on any C# helper methods within this class that do not directly call SDL or that perform significant logic before/after an SDL call.
    -   Most testing for `SDL.cs` functionality will be indirect, through the higher-level framework modules and `Night.SampleGame`.
-   **`FrameworkLoop.cs`**
    -   Testing the main game loop (`Run` method) in isolation is challenging.
    -   Focus on unit testing helper methods or individual components within the loop's logic if they can be isolated (e.g., delta time calculation if it's a separate utility).
    -   The overall loop functionality is best tested via `Night.SampleGame`.
-   **`Types.cs`**
    -   Contains data structures (e.g., `Color`, `Rectangle`, `Sprite`) and interfaces (`IGame`).
    -   Test constructors and any methods on these types if they contain logic (e.g., `Color.ToSDLColor`, methods on `Rectangle`).
    -   Interfaces themselves are not tested directly but are implemented by mocks or test classes.

### 5.2. `Night.Engine` (Future High-Level Systems)

As `Night.Engine` evolves with higher-level systems (ECS, Scene Management, etc.), dedicated test classes will be created for each new component, following the same principles.

## 6. Test Case Design

-   **Positive Tests:** Verify that methods work correctly with valid inputs.
-   **Negative Tests (Error Handling):**
    -   Verify behavior with invalid inputs (e.g., null arguments, out-of-range values).
    -   Ensure appropriate exceptions are thrown as per API contracts (e.g., `ArgumentNullException`, `ArgumentOutOfRangeException`).
-   **Edge Cases:** Test boundary conditions and less common scenarios.
-   **Idempotency:** For methods that should be idempotent, verify this behavior.

## 7. Dealing with SDL Dependencies

Directly testing code that relies heavily on SDL3 native calls can be difficult in unit tests, as it often requires an initialized SDL environment and may involve external system state (like window handles or graphics contexts).

-   **Focus on C# Logic:** Prioritize testing the C# logic that wraps or precedes SDL calls. This includes parameter validation, state management within the C# layer, and correct translation of parameters for SDL functions.
-   **Abstraction (If Necessary):** For more complex C# logic interacting with SDL, consider if introducing a thin abstraction over direct SDL calls (internal to the module) could facilitate testing. This should be weighed against added complexity.
-   **Integration Tests as a Complement:** Acknowledge that `Night.SampleGame` serves as the primary integration test suite where the full interaction with SDL is validated. Unit tests are meant to catch issues at a more granular C# level.
-   **Mocking/Faking SDL (Use with Caution):**
    -   Creating mocks or fakes for SDL functions is possible but can be very time-consuming and complex to maintain.
    -   This approach should generally be avoided unless a critical piece of C# logic cannot be tested otherwise and its correctness is paramount.
    -   If used, these fakes would need to simulate SDL behavior, which can be error-prone.

## 8. Running Tests

-   Tests can be run using the `dotnet test` command from the command line in the solution root or the test project directory.
-   Test runners integrated into IDEs (like Visual Studio, VS Code, Rider) can also be used.

## 9. Test Maintenance

-   Tests should be kept up-to-date with code changes.
-   Refactor tests along with production code to maintain clarity and relevance.
-   Remove or update tests for deprecated or changed functionality.

## 10. Continuous Integration (Future)

Once a CI/CD pipeline is established, automated execution of these unit tests will be a key component to ensure code quality with every change.

This testing plan provides a foundation for building a robust suite of unit tests for `Night.Engine`. It will evolve as the engine grows and new features are added. 


================================================
File: docs/epics/epic10.md
================================================
# Epic 10: Achieving Roadmap Version 0.1.0

**Goal:** Implement the remaining core features and functionalities outlined for Version 0.1.0 in `docs/love2d-api/roadmap.md`. This epic focuses on API completion for the initial public feature set of Night.Framework.

**User Stories:**

- As a game developer using Night Engine, I want a `love.filesystem`-like API to manage game assets and data.
- As a game developer, I want to draw basic 2D shapes (rectangles, circles, lines) using `Night.Graphics`.
- As a game developer, I need to query timing information like FPS and total elapsed time via a `love.timer`-like API.
- As a game developer, I want more complete keyboard and mouse event callbacks (`KeyReleased`, `MousePressed`, `MouseReleased`).
- As a game developer, I need to manage window properties like dimensions, desktop info, and fullscreen modes via a `love.window`-like API.
- As a project maintainer, I want automated documentation generation and a basic CI setup.
- As a game developer, I want a way to handle errors originating from my game code gracefully via a `love.errorhandler`-like mechanism.
- As a game developer, I want to be able to configure basic game settings through a configuration file.

**Version 0.1.0 Roadmap Items to Address:**
(Reference: `docs/love2d-api/roadmap.md`)

## Tasks

### Phase 1: Core Framework Enhancements

- [x] **Task 10.1: Implement `Night.Filesystem` (Basic)**
  - **Description:** Create the `Night.Filesystem` static class. Implement core functions needed for 0.1.0, focusing on reading files (e.g., for `Graphics.NewImage`), checking file/directory existence. Refer to `docs/love2d-api/modules/filesystem.md` for API inspiration, but scope to essential read operations.
  - **Implementation:**
    - [x] Create `Night.Filesystem` static class
    - [-] ~~Implement `Exists(string path)` - Check if a file or directory exists~~ (Replaced by `GetInfo`)
    - [-] ~~Implement `IsFile(string path)` - Check if path is a file~~ (Replaced by `GetInfo`)
    - [-] ~~Implement `IsDirectory(string path)` - Check if path is a directory~~ (Replaced by `GetInfo`)
    - [x] Implement `ReadBytes(string path)` - Read file as byte array
    - [x] Implement `ReadText(string path)` - Read file as text
    - [x] **Task 10.1.1: Refactor File/Directory Checks to `GetInfo`**
      - **Description:** Replace `Exists`, `IsFile`, and `IsDirectory` with a new `GetInfo(string path, FileType? filterType = null, FileSystemInfo? existingInfo = null)` function, based on `love.filesystem.getInfo`. This new function will provide comprehensive file/directory attributes.
      - **Implementation:**
        - [x] Define `Night.FileType` enum (`File`, `Directory`, `Symlink`, `Other`, `None`).
        - [x] Define `Night.FileSystemInfo` class (with `Type`, `Size`, `ModTime`).
        - [x] Remove `Night.Filesystem.Exists(string path)`.
        - [x] Remove `Night.Filesystem.IsFile(string path)`.
        - [x] Remove `Night.Filesystem.IsDirectory(string path)`.
        - [x] Implement `Night.Filesystem.GetInfo(...)` and its overloads.
        - [x] Update `Night.SampleGame` to use `GetInfo` instead of the removed methods.
      - **Acceptance Criteria:** `Night.Filesystem.GetInfo` correctly returns information for files and directories. `Night.SampleGame` is updated and functions correctly with the new API. The old methods are removed.
      - **Status:** Done
  - **Acceptance Criteria:** Basic file operations are available and usable by other modules (e.g., `Night.Graphics.NewImage` can use it). Sample game can demonstrate reading a simple text file.
  - **Status:** In-Progress

- [x] **Task 10.2: Extend `Night.Graphics` with Basic Shape Drawing**
  - **Description:** Add methods to `Night.Graphics` for drawing 2D primitives.
  - **Implementation:**
    - [x] Define `Night.DrawMode` enum with values:
      - `Fill` - Filled shapes
      - `Line` - Outlined shapes
    - [x] Implement `Rectangle(DrawMode mode, float x, float y, float width, float height)`
    - [x] Implement `Circle(DrawMode mode, float x, float y, float radius, int segments = 12)` (Note: `Color color` param removed to rely on `SetColor`)
    - [x] Implement `Line(float x1, float y1, float x2, float y2)`
    - [x] Implement `Line(DrawMode mode, PointF[] points)` (Note: `List<PointF>` changed to `PointF[]` for consistency)
    - [x] Implement `Polygon(DrawMode mode, PointF[] vertices)`
    - [x] Implement `SetColor(Night.Color color)`
    - [x] Implement `SetColor(byte r, byte g, byte b, byte a = 255)`
    - [x] Update `Night.SampleGame` to demonstrate drawing these shapes
  - **Acceptance Criteria:** Rectangles, circles, and lines can be drawn with specified colors and modes. Sample game showcases this.
  - **Status:** Review

- [x] **Task 10.3: Implement `Night.Timer` Module**
  - **Description:** Create the `Night.Timer` static class.
  - [x] Implement `GetFPS()` and `GetTime()` (time since game start in seconds). Refer to `docs/love2d-api/modules/timer.md`.
  - [x] `GetDeltaTime()` is already available implicitly via `IGame.Update()`, but should be renamed to `GetDelta()`. (Implemented as `Night.Timer.GetDelta()`)
  - [x] Implement `GetAverageDelta()`.
  - [x] Implement `Sleep()` to pause the current thread for the specified amount of time. This function causes the entire thread to pause for the duration of the sleep. Graphics will not draw, input events will not trigger, code will not run, and the window will be unresponsive if you use this as "wait()" in the main thread.
  - [x] Implement `Step()` to measures the time between two frames.
  - **Acceptance Criteria:** `Night.Timer.GetFPS()` returns current FPS. `Night.Timer.GetTime()` returns elapsed game time. Sample game can display these values.
  - **Status:** Done

- [x] **Task 10.4: Implement Remaining Input Event Callbacks**
  - **Description:** Add remaining input event callbacks to handle keyboard and mouse interactions.
  - **Implementation:**
    - [x] Add to `IGame` interface:
      - [x] `KeyReleased(KeySymbol key, KeyCode scancode)`
      - [x] `MousePressed(int x, int y, MouseButton button, bool istouch, int presses)`. Stub istouch for now as a TODO.
      - [x] `MouseReleased(int x, int y, MouseButton button,bool istouch, int presses)`. Stub istouch for now as a TODO.`
    - [x] Update `FrameworkLoop.cs` to handle and dispatch:
      - [x] `SDL.EventType.KeyUp` events
      - [x] `SDL.EventType.MouseButtonDown` events
      - [x] `SDL.EventType.MouseButtonUp` events
  - **Acceptance Criteria:** Sample game can react to key releases, mouse button presses, and mouse button releases, triggering the appropriate `IGame` callbacks.
  - **Status:** Done

- [x] **Task 10.5: Extend `Night.Window` Functionality**
  - **Description:** Implement window management functionality based on `docs/love2d-api/modules/window.md` "In Scope" items.
  - **Implementation:**
    - [x] Core Methods:
      - [x] `GetDesktopDimensions(int displayIndex = 0)` - Get desktop dimensions [cite: 1280]
      - [x] `GetDisplayCount()` - Get number of displays [cite: 1283]
    - [x] Fullscreen Management:
      - [x] `GetFullscreen()` - Check if window is fullscreen. Returns bool fullscreen and FullscreenType fstype. FullscreenType is enumeration `desktop` and `exclusive`. `desktop` is sometimes known as borderless fullscreen windowed mode. A borderless screen-sized window is created which sits on top of all desktop UI elements. The window is automatically resized to match the dimensions of the desktop, and its size cannot be changed. `exclusive` is standard exclusive-fullscreen mode. Changes the display mode (actual resolution) of the monitor.
      - [x] `SetFullscreen(bool fullscreen, FullscreenType type = Desktop)` - Toggle fullscreen. Returns bool success.
      - [x] `GetFullscreenModes(int displayIndex = 0)` - Get available fullscreen modes. Returns table modes. A table of width/height pairs. (Note that this may not be in order.)
      - [x] Define `Night.FullscreenType` struct/class
    - [x] Window State:
      - [x] `GetMode()` - Get current window mode (width, height, flags) [cite: 1295]
    - [x] (Optional Stretch) High DPI Support:
      - [x] `FromPixels` - Converts a number from pixels to density-independent units.
      - [x] `ToPixels` - Converts a number from density-independent units to pixels.
      - [x] `GetDPIScale` - Gets the DPI scale factor associated with the window.
  - **Acceptance Criteria:** Window dimension and mode queries work. Fullscreen can be toggled. Sample game can demonstrate some of these (e.g., printing dimensions).
  - **Status:** Review

### Phase 2: Project Infrastructure & Polish

- [x] **Task 10.6: Implement User-Definable Error Handler**
  - **Description:** Design and implement a mechanism similar to `love.errorhandler`. Allow the user to register a custom error handling function/delegate that `FrameworkLoop.cs` will call when an unhandled exception occurs in `IGame.Load`, `IGame.Update`, `IGame.Draw`, or input callbacks.
  - The handler should receive error details (exception object, message, stack trace).
  - If no custom handler is set, implement the following equivalent from Love2D as the default error handling.
  - **Notes:**
    - The default error handler logs to console, ensures the window is open (or attempts to reopen to 800x600), clears it to a blue color, and resets mouse state (visible, not grabbed, not relative).
    - It then enters a loop allowing the user to quit (Esc key or closing the window) or copy the full error message and stack trace to the clipboard (Ctrl+C).
    - Clipboard functionality uses `Night.System.SetClipboardText(string)`.
    - Due to `Night.Font` not being part of the 0.1.0 scope, the default error handler does *not* render the error text directly into the game window. Users must check the console for the detailed error message.
    - Implemented `Night.Error.SetHandler(ErrorHandlerDelegate)` for users to provide their custom delegate.
    - Added `Night.Mouse.SetVisible(bool)`, `Night.Mouse.SetGrabbed(bool)`, and `Night.Mouse.SetRelativeMode(bool)`.

```lua
local utf8 = require("utf8")

local function error_printer(msg, layer)
 print((debug.traceback("Error: " .. tostring(msg), 1+(layer or 1)):gsub("\n[^\n]+$", "")))
end

function love.errorhandler(msg)
 msg = tostring(msg)

 error_printer(msg, 2)

 if not love.window or not love.graphics or not love.event then
  return
 end

 if not love.graphics.isCreated() or not love.window.isOpen() then
  local success, status = pcall(love.window.setMode, 800, 600)
  if not success or not status then
   return
  end
 end

 -- Reset state.
 if love.mouse then
  love.mouse.setVisible(true)
  love.mouse.setGrabbed(false)
  love.mouse.setRelativeMode(false)
  if love.mouse.isCursorSupported() then
   love.mouse.setCursor()
  end
 end
 if love.joystick then
  -- Stop all joystick vibrations.
  for i,v in ipairs(love.joystick.getJoysticks()) do
   v:setVibration()
  end
 end
 if love.audio then love.audio.stop() end

 love.graphics.reset()
 local font = love.graphics.setNewFont(14)

 love.graphics.setColor(1, 1, 1)

 local trace = debug.traceback()

 love.graphics.origin()

 local sanitizedmsg = {}
 for char in msg:gmatch(utf8.charpattern) do
  table.insert(sanitizedmsg, char)
 end
 sanitizedmsg = table.concat(sanitizedmsg)

 local err = {}

 table.insert(err, "Error\n")
 table.insert(err, sanitizedmsg)

 if #sanitizedmsg ~= #msg then
  table.insert(err, "Invalid UTF-8 string in error message.")
 end

 table.insert(err, "\n")

 for l in trace:gmatch("(.-)\n") do
  if not l:match("boot.lua") then
   l = l:gsub("stack traceback:", "Traceback\n")
   table.insert(err, l)
  end
 end

 local p = table.concat(err, "\n")

 p = p:gsub("\t", "")
 p = p:gsub("%[string \"(.-)\"%]", "%1")

 local function draw()
  if not love.graphics.isActive() then return end
  local pos = 70
  love.graphics.clear(89/255, 157/255, 220/255)
  love.graphics.printf(p, pos, pos, love.graphics.getWidth() - pos)
  love.graphics.present()
 end

 local fullErrorText = p
 local function copyToClipboard()
  if not love.system then return end
  love.system.setClipboardText(fullErrorText)
  p = p .. "\nCopied to clipboard!"
 end

 if love.system then
  p = p .. "\n\nPress Ctrl+C or tap to copy this error"
 end

 return function()
  love.event.pump()

  for e, a, b, c in love.event.poll() do
   if e == "quit" then
    return 1
   elseif e == "keypressed" and a == "escape" then
    return 1
   elseif e == "keypressed" and a == "c" and love.keyboard.isDown("lctrl", "rctrl") then
    copyToClipboard()
   elseif e == "touchpressed" then
    local name = love.window.getTitle()
    if #name == 0 or name == "Untitled" then name = "Game" end
    local buttons = {"OK", "Cancel"}
    if love.system then
     buttons[3] = "Copy to clipboard"
    end
    local pressed = love.window.showMessageBox("Quit "..name.."?", "", buttons)
    if pressed == 1 then
     return 1
    elseif pressed == 3 then
     copyToClipboard()
    end
   end
  end

  draw()

  if love.timer then
   love.timer.sleep(0.1)
  end
 end

end
```

- **Acceptance Criteria:** A user can provide a custom function to `Night.Framework` that gets called on unhandled game code exceptions, allowing custom display or logging.
- **Status:** Done

- [x] **Task 10.7: Basic Game Configuration File Support**
  - **Description:** Implement functionality to load basic game settings from a configuration file (e.g., `config.json`) at startup.
  - Focus on settings like default window width, height, title, vsync toggle.
  - `Night.Framework.Run` or `IGame.Load` could access these.
  - **Implementation:**
    - [x] Create `Night.Configuration.GameConfig` class with nested `WindowConfig`, `AudioConfig`, `ModulesConfig` to define configuration structure and defaults. (`src/Night.Engine/Framework/Configuration/GameConfig.cs`)
    - [x] Create `Night.Configuration.ConfigurationManager` static class to load `config.json` and provide access to `GameConfig`. (`src/Night.Engine/Framework/Configuration/ConfigurationManager.cs`)
    - [x] Modify `Night.FrameworkLoop.Run()` to call `ConfigurationManager.LoadConfig()` before `game.Load()`.
    - [x] Modify `Night.FrameworkLoop.Run()` to initialize the window using `ConfigurationManager.CurrentConfig.Window` settings if `game.Load()` does not create a window. This includes:
      - Window dimensions (width, height)
      - Window title
      - Window flags (Resizable, Borderless, HighDPI)
      - Fullscreen mode (Fullscreen, FullscreenType)
      - VSync
      - Initial window position (X, Y)
    - [x] Update `Night.SampleGame` to demonstrate overriding initial window settings via `config.json`.
    - [ ] TODO: Add handling for `t.window.icon` (requires `Night.Window.SetIcon` to be implemented first, which is out of scope for 0.1.0 according to Task 10.10 notes, but config option should exist).
    - [ ] TODO: Add console message for `t.console = true` on Windows (actual console attachment is a larger task).
    - [ ] TODO: Consider `t.identity` and `t.appendidentity` for `Night.Filesystem` initialization.
    - [ ] TODO: Implement logic for `t.modules.*` flags to actually enable/disable modules (currently placeholder flags).
  - **Acceptance Criteria:** The engine loads `config.json`. If `game.Load()` doesn't open a window, the engine uses `config.json` values (or defaults) for window width, height, title, resizable, borderless, fullscreen, fullscreen type, VSync, and initial position. The sample game can have its initial window settings overridden by a `config.json` file (once sample game is updated).
  - **Status:** In-Progress

- [ ] **Task 10.8: Setup `docfx` Documentation Generation**
  - **Description:** Integrate `docfx` into the project. Configure it to generate API documentation from C# XML comments for `Night.Engine`. Setup a GitHub Actions workflow to build and deploy this documentation to GitHub Pages.
  - **Acceptance Criteria:** API documentation is automatically generated and published to a GitHub Pages site.
  - **Status:** To Do

- [ ] **Task 10.9: Formalize Basic Test Suite**
  - **Description:** Review current testing strategy (`Night.SampleGame` as integration test [cite: 209]). Establish a basic structure for more formal tests if deemed necessary (e.g., a separate test project). Add minimal unit tests for any new complex, non-SDL-dependent logic introduced in this epic (e.g., utility functions in `Night.Filesystem` or `Night.Timer`).
  - **Acceptance Criteria:** A clear testing strategy for 0.1.0 is in place. Any new critical utility functions have basic unit tests.
  - **Status:** In-Progress

- [ ] **Task 10.10: Create Project Logo and Icon**
  - **Description:** Design or procure a logo for Night Engine. Prepare application icon files (e.g., .ico, .icns) and integrate them so the `Night.SampleGame` window uses the icon. `Night.Window.SetIcon()` would be needed if not already planned. (Roadmap `love.window` has `setIcon` [cite: 1291, 1327] as out of scope, may need to be scoped in for this).
  - **Acceptance Criteria:** Project has a logo. Sample game displays a custom window icon.
  - **Status:** To Do

- [ ] **Task 10.11: Establish Basic CI Workflow**
  - **Description:** Review deactivated CI workflows. Create a new, active GitHub Actions workflow that, at a minimum, builds `Night` and `SampleGame` on push/PR to main branch for Windows, Linux, and macOS. Run any automated tests established in Task 10.9.
  - **Acceptance Criteria:** CI workflow successfully builds and (if applicable) tests the project on all target OS upon code changes.
  - **Status:** Done (Basic requirements met by existing `.github/workflows/ci.yml`. Further enhancements can be added.)

- [x] **Task 10.12: Create API Documentation Script**
  - **Description:** Write a new Python script `scripts/get_api.py`. This script will parse all C# files in `src/Night.Engine/Framework` and its subdirectories. It will generate a markdown file listing all public static classes and their public static functions (including overloads). The script should attempt to derive an equivalent Love2D API call for each function.
  - **Output Format:**
    - Modules (classes) should be Header Level 2.
    - Functions should be an unordered list item: `FunctionName() - love.module.functionName`
    - Overloaded functions should have a nested unordered list detailing each overload with parameters:
      - `FunctionName(paramType1 paramName1, paramType2 paramName2)`
  - **Example:**

    ```markdown
    ## filesystem
    - GetInfo() - love.filesystem.getInfo
      - GetInfo(string path, FileSystemInfo info)
      - GetInfo(string path, FileType filterType, FileSystemInfo info)
    ```

  - **Acceptance Criteria:** The script `scripts/get_api.py` is created and generates a markdown file as specified. The markdown file accurately reflects the public API of `src/Night.Engine/Framework`.
  - **Status:** To Do

[x] **Task 10.13: Refactor Project Structure, Naming, and Documentation**

- **Description:** Restructure the project's directories and C# project files to align with the "Night" and "Night.Engine" namespace strategy. Update all relevant documentation to reflect these changes. The goal is to have a primary assembly named `Night.dll` which contains both the `Night` (framework) and `Night.Engine` (engine extensions) namespaces.

- **Implementation Details:**

    - **1. Directory Renaming and Restructuring:**

        - [x] Rename the main C# project directory from `src/Night.Engine/` to `src/Night/`.

        - [x] Move all contents of the former `src/Night.Engine/Framework/` directory (e.g., `Graphics/`, `Window/`, etc.) directly into the new `src/Night/` directory.

            - Example: `src/Night.Engine/Framework/Graphics/Graphics.cs` becomes `src/Night/Graphics/Graphics.cs`.

        - [x] Move the contents of the former `src/Night.Engine/Engine/` directory into a new `Engine` subdirectory within `src/Night/`.

            - Example: `src/Night.Engine/Engine/.gitkeep` becomes `src/Night/Engine/.gitkeep`.

            - Future engine components like `SceneManager.cs` would go into `src/Night/Engine/`.

    - **2. C# Project File (.csproj) Adjustments:**

        - [x] Rename the C# project file from `src/Night.Engine/Night.Engine.csproj` to `src/Night/Night.csproj`.

        - [x] Update the `src/Night/Night.csproj` file:

            - [x] Modify the `<AssemblyName>` property (or add it if not present) to ensure the output assembly is named `Night`. (e.g., `<AssemblyName>Night</AssemblyName>`)

            - [x] Verify that all source file paths (`<Compile Include="..." />` if explicit, or implicit globbing patterns) are correct after the directory restructuring.

    - **3. Solution File (`.sln`) Update:**

        - [x] Edit the `Night.sln` file to reflect the new path and name of the C# project file.

            - Example: Change `Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Night.Engine", "src\Night.Engine\Night.Engine.csproj", "{...}"`

            - To: `Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Night", "src\Night\Night.csproj", "{...}"` (The project GUID `{...}` should remain the same).

            - [x] Also update `Night.Engine.Tests` to `Night.Tests` and its path in the solution.

    - **4. Namespace Verification (Conceptual - No Code Change unless inconsistencies found):**

        - [x] Conceptually verify that all files moved from `src/Night.Engine/Framework/*` are already in the `Night` namespace (or sub-namespaces like `Night.Graphics`).

        - [x] Conceptually verify that any files moved to `src/Night/Engine/*` will use the `Night.Engine` namespace.

    - **5. Documentation Updates:**

        - [x] **`docs/PRD.md`:**

            - [x] Update Section 3 "Technical Specifications"

                - Change primary library name from `Night.Engine` to `Night`.

                - Reflect that the output DLL is `Night.dll`.

                - Clarify that this `Night.dll` contains both `Night` (framework) and `Night.Engine` (engine extensions) namespaces.

            - [x] Update Section 4 "Project Structure"

                - Modify the Mermaid diagram and textual descriptions to show the new `src/Night/` top-level directory for the main library.

                - Show module directories (e.g., `Graphics`, `Window`) directly under `src/Night/`.

                - Show the `Engine` subdirectory as `src/Night/Engine/`.

            - [x] Update Section 5 "File Descriptions"

                - Change `src/Night.Engine/Night.Engine.csproj` to `src/Night/Night.csproj`.

                - Describe `Night.csproj` as the project file for the main `Night.dll` library.

        - [x] **`README.md`:**

            - [x] Review and update any mentions of `Night.Engine` as the primary library name or `Night.Engine.dll` if they exist.

            - [x] Ensure any "Getting Started" or API usage examples correctly reflect `using Night;` and `using Night.Engine;` and the concept of a single `Night.dll`.

        - [x] **`docs/epics/*.md` (especially `epic10.md` and any active epics):**

            - [x] Review all task descriptions and implementation details.

            - [x] Update file paths (e.g., references to `src/Night.Engine/Framework/...` should become `src/Night/...`).

            - [x] Update references to `Night.Engine.csproj` to `Night.csproj`.

        - [x] **`docs/operational-guidelines.md`:**

            - [x] Review for any path or project name specifics that might need updating.

        - [x] **`.github/workflows/ci.yml` (and any other relevant workflows):**

            - [x] Update paths to the solution file (`Night.sln` - likely no change here unless solution name changes).

            - [x] Update paths to the C# project file if explicitly referenced (e.g., `dotnet build src/Night/Night.csproj`).

            - [x] Ensure build steps correctly produce `Night.dll`.

        - [x] **`scripts/update_api_doc.py` (Task 10.12 in `epic10.md`):**

            - [x] Ensure the script's `framework_dir` points to `src/Night/` (or its relevant subdirectories like `src/Night/Graphics`, etc., if it iterates that way) instead of `src/Night.Engine/Framework/`.

- **Acceptance Criteria:**

    - The project directory structure is updated as specified.

    - The C# project file is renamed to `Night.csproj`, located in `src/Night/`, and configured to output `Night.dll`.

    - The `Night.sln` file correctly references the renamed and relocated project.

    - The solution builds successfully, producing `Night.dll`.

    - The `Night.SampleGame` project still builds and runs correctly, referencing the new `Night.dll` and using the `Night` and `Night.Engine` namespaces as intended.

    - All specified documentation files (`PRD.md`, `README.md`, relevant epics, CI workflows, API doc script) are updated to accurately reflect the new structure, naming, and API organization.

- **Status:** Review



================================================
File: docs/epics/archive/epic1.md
================================================
**Epic 1: Project Setup & SDL3 Integration**

**Goal:** Establish the development environment, project structure as defined in the PRD, and ensure SDL3 native libraries are correctly fetched, linked, and usable by the C# projects.

- [x] **Task 1.0:** Align Project Structure with PRD Section 4 (Revised) (Status: Review)
    - [x] Review current project structure against `docs/PRD.md` Section 4 diagram.
    - [x] Move `Night.Engine/SDL3` submodule to `lib/SDL3-CS`.
    - [x] Remove `Night.Engine/runtimes` directory.
    - [x] Verify no `scripts` directory exists at root (remove if found and not in PRD).
    - [x] Create `lib/TASKS.md`.
    - **Verification:** Project structure matches `docs/PRD.md` Section 4 diagram. `.gitmodules` is updated.
- [x] **Task 1.1:** Initialize Git Repository & Solution Structure
    - [x] Initialize Git repository with a `.gitignore` file suitable for a .NET project.
    - [x] Create the `Night.sln` solution file.
    - [x] Create the main folder structure: `/docs`, `/scripts`, `/Night.Engine`, `/Night.SampleGame` as per PRD Section 4.
    - [x] Add initial `PRD.md` and a placeholder `TASKS.md` to `/docs`.
    - [x] Add a basic `README.md` to the project root.
    - **Verification:** Repository is cloneable, solution opens in IDE, folder structure matches PRD.

- [x] **Task 1.2.1:** Refactor `Platform` Build System and Workflow (Status: Review)
    - [x] Rename `FosterPlatform` to `Night.Platform` in [`src/Night.Platform/CMakeLists.txt`](src/Night.Platform/CMakeLists.txt:0) and update associated variables (e.g., `FOSTER_LIB_NAME` to `NIGHT_LIB_NAME`).
    - [x] Rename `foster_platform.h` to `night_platform.h` and `foster_platform.c` to `night_platform.c`. Update include guards and internal references.
    - [x] Update [`src/Night.Platform/README.md`](src/Night.Platform/README.md:0) to reflect the new naming.
    - [x] Update [` .github/workflows/build-libs.yml`](.github/workflows/build-libs.yml:0) to use `NIGHT_OVERRIDE_TARGET` and reflect any other necessary changes due to renaming.
    - **Verification:** The `Platform` project builds successfully with the new names. The GitHub Actions workflow runs successfully, producing artifacts like `Night.Platform.dll`.

- [x] **Task 1.3:** Set up C# Projects (`Night.Engine` & `Night.SampleGame`) (Status: Review)
    - [x] Create `Night.Engine.csproj` as a .NET 9 C# class library.
    - [x] Configure it to use C# 13.
    - [x] Ensure it's set up to correctly include/load native binaries from the `/runtimes` folder for multiple platforms.
    - [x] Create `Night.SampleGame.csproj` as a .NET 9 C# console application.
    - [x] Configure it to use C# 13.
    - [x] Add a project reference to `Night.Engine`.
    - [x] Add basic placeholder C# files (`API.cs`, `Engine.cs` in `Night.Engine`; `Program.cs`, `Game.cs` in `Night.SampleGame`).
    - **Verification:** Both projects build successfully. `Night.SampleGame` can reference types from `Night.Engine`.

- [x] **Task 1.4:** Initial SDL3 P/Invoke Test (Status: Review)
    - [x] In `Night.Engine` or `Night.SampleGame`, add P/Invoke declarations for simple functions from `src/Night.Platform/` (e.g., for `SDL_Init`, `SDL_Quit`, `SDL_GetVersion` equivalents via `Night.Platform.dll`). (Implemented directly against SDL3.dll in `Program.cs`)
    - [x] Call these P/Invoke functions from `Night.SampleGame`'s `Program.cs`. (Implemented in `Program.cs`)
    - **Verification:** The P/Invoke call executes without errors (e.g., `DllNotFoundException`), and if applicable, returns expected data (like SDL version). SDL can be initialized and quit. (Checked 2025-05-24: `SDL3.dll` copying mechanism via `Night.Engine.csproj` for `win-x64` is correctly configured.)

- [x] **Task 1.4.1:** Setup Coding Standards Enforcement (Status: Review)
    - [x] Create and configure `.editorconfig` at the project root to align with the Google C# Style Guide (indentation, column limit, `using` directive order, placeholder for Roslyn Analyzers).
    - [x] Updated `.pre-commit-config.yaml` for C# project with `dotnet format` and other standard hooks.
    - [x] Ensure Roslyn Analyzers are active and *fully* configured via `.editorconfig` for style and quality checks.
    - **Verification:** Code formatting tools (`dotnet format`) apply styles consistent with `.editorconfig`. IDE shows warnings/errors based on analyzer settings. `.pre-commit` hooks run successfully.

- **Task 1.5:** Integrate `lib/SDL3-CS` Bindings into `Night.Engine` (Status: Review)
    - **Description:** Modify `Night.Engine` to use the C# bindings from `lib/SDL3-CS` for SDL3 interop, and update `Night.SampleGame` to use these new capabilities. This replaces any direct P/Invoke to `SDL3.dll` or reliance on `Night.Platform` for SDL3 functions.
    - **Sub-tasks:**
        - [x] Add a project reference from `src/Night.Engine/Night.Engine.csproj` to `lib/SDL3-CS/SDL3/SDL3.Core.csproj` (or `SDL3.Legacy.csproj` if .NET 8+ is not guaranteed for all targets, though PRD specifies .NET 9).
        - [x] Update `src/Night.Engine/API.cs` (or a new `NativeMethods.cs` / `SDL3Integration.cs` file) to expose necessary SDL3 functions (e.g., `Init`, `Quit`, `GetVersion`) using the `SDL3-CS` bindings.
        - [x] Remove any direct P/Invoke declarations for SDL3 functions from `src/Night.SampleGame/Program.cs` or other files if they were using `Night.Platform.dll` or `SDL3.dll` directly for these.
        - [x] Update `src/Night.SampleGame/Program.cs` to call the SDL3 functions exposed by `Night.Engine` (which now use `SDL3-CS`).
    - **Verification:** `Night.Engine` and `Night.SampleGame` build successfully. `Night.SampleGame` can initialize and quit SDL, and retrieve version information using the `SDL3-CS` bindings via `Night.Engine`. No direct P/Invokes to `SDL3.dll` (for functions now covered by `Night.Engine`) remain in `Night.SampleGame`.

- **Task 1.6:** Remove `Night.Platform` (Status: In-Progress)
    - **Description:** Remove the `src/Night.Platform` directory and all references to it, as its functionality (primarily SDL3 building and basic interop) is now superseded by `lib/SDL3-CS` and pre-built SDL3 binaries.
    - **Sub-tasks:**
        - [ ] Delete the `src/Night.Platform` directory.
        - [ ] Update or remove ` .github/workflows/build-libs.yml` to eliminate `Night.Platform` build steps.
        - [ ] Remove any references to `Night.Platform` or its output libraries (e.g., `NightPlatform.dll`, `libNightPlatform.so`) from `.csproj` files, `Night.sln`, or other build/configuration files.
        - [ ] Verify that `Night.Engine` and `Night.SampleGame` still build and run correctly using `lib/SDL3-CS` for all SDL3 interactions.
    - **Verification:** The `src/Night.Platform` directory is gone. The project builds and runs without errors. The GitHub Actions workflow, if modified, completes successfully without trying to build `Night.Platform`.



================================================
File: docs/epics/archive/epic2.md
================================================
# Epic 2: Core Engine API - Foundations (Leveraging SDL3-CS)

[ ] **Task 2.1:** Define Core `Night` API Data Structures

- [ ] Create C# enums, structs, or classes for the data types exposed by the `Night` API (e.g., `Night.Color`, `Night.Rectangle`, `Night.Key`, `Night.WindowFlags`, a basic `Night.Sprite` class). These will be part of `Night.Engine`'s public interface.
- [ ] For each `Night` data structure, determine if it will directly wrap or map to/from corresponding C# structs/enums provided by SDL3-CS (e.g., SDL3-CS might provide `SDL_Rect`, `SDL_Color`, `SDL_Keycode`, etc.) or if it's a purely `Night`-level concept.

[ ] **Task 2.2:** Integrate and Verify SDL3-CS Bindings

- [ ] Add the SDL3-CS library to the `Night.Engine` project. This might involve:
    - Adding it as a NuGet package if it's published as one.
    - Including its source code or project as a submodule or directly in your solution if preferred/necessary.
- [ ] Review the specific SDL3-CS generated files (e.g., `SDL3.Core.cs` or `SDL3.Legacy.cs` based on your .NET target) to understand the available functions and data types.

[ ] **Task 2.3:** Stub out `Night` Public API Surface (`NightAPI.cs`, `Engine.cs`)

- [x] In `API.cs`, create the static classes `Night.Window`, `Night.Keyboard`, `Night.Mouse`, and `Night.Graphics`.
- [x] Add public method signatures (as stubs, initially throwing `NotImplementedException` or logging) for the API functions outlined in PRD Features 1, 2, and 3.
    - Example: `public static class Night.Window { public static void SetMode(int width, int height, WindowFlags flags) { throw new NotImplementedException(); /* Future: call SDL.SDL_CreateWindow via SDL3-CS */ } }`
- [x] In `Engine.cs`, create the `Night.Engine` class with a public `Run` method (stubbed).
- [x] Define placeholders for how the `Run` method will invoke the user's `Load()`, `Update()`, and `Draw()` methods.
- **Verification:** The stubbed public `Night` API is callable from `Night.SampleGame`. The structure aligns with the PRD. It's clear where SDL3-CS calls will be made in future implementation steps.



================================================
File: docs/epics/archive/epic3.md
================================================
**Epic 3: Window Management Implementation**

**Goal:** Fully implement the `Night.Window` module's public API (as stubbed in Epic 2) for creating, configuring, and managing the application window, using the SDL3-CS bindings.

- [x] **Task 3.1:** Implement `Night.Window.SetMode(int width, int height, WindowFlags flags)` (Status: Done)
    - [x] Use SDL3-CS functions to create an SDL window (e.g., `SDL.SDL_CreateWindow()`).
        - [x] Ensure the window is created with the specified `width` and `height`.
        - [x] Map the `Night.WindowFlags` (e.g., for fullscreen, resizable, borderless) to the corresponding SDL window flags or subsequent SDL function calls (e.g., `SDL.SDL_SetWindowFullscreen()`, `SDL.SDL_SetWindowResizable()`).
    - [x] If a default renderer is conceptually tied to the window in your design (common for 2D), create an SDL renderer (e.g., `SDL.SDL_CreateRenderer()`) associated with the window.
        - [x] Store the SDL window handle (and renderer handle, if applicable) internally within a private static part of `Night.Window`.
    - [x] Handle any necessary SDL initialization for video subsystems (`SDL.SDL_InitSubSystem(SDL.SDL_INIT_VIDEO)`) if not already handled globally.
    - [x] **Verification:** Calling `Night.Window.SetMode()` from `Night.SampleGame` successfully creates and displays a window with the specified dimensions and properties (e.g., fullscreen, resizable). No SDL errors are reported.

- [x] **Task 3.2:** Implement `Night.Window.SetTitle(string title)` (Status: Review)
    - [x] Use the appropriate SDL3-CS function to set the window's title (e.g., `SDL.SDL_SetWindowTitle()`), using the stored window handle.
    - **Verification:** Calling `Night.Window.SetTitle()` from `Night.SampleGame` changes the title displayed in the window's title bar.

- [x] **Task 3.3:** Implement `Night.Window.IsOpen()` (Status: Review)
    - [x] This method's primary role is to control the game loop. For now, its state will likely be tied to whether a `Quit` event has been received (which will be handled more fully in Epic 6: Game Loop).
    - [x] Create an internal static boolean flag (e.g., `_isWindowOpen` or `_isRunning`, default to `false` until `SetMode` is called, then `true`). `IsOpen()` will return this flag's value. The game loop (Epic 6) will set this to `false` on a quit event.
    - **Verification:** The `Night.Window.IsOpen()` method can be called and returns `true` after a window is created, and its state can be conceptually altered (though full quit logic is later).

- [x] **Task 3.4:** Implement Basic Error Handling for Window Operations (Status: Review)
    - [x] For all SDL3-CS function calls made within `Night.Window` methods, check their return values for errors (e.g., null pointers for window/renderer handles, negative values for error codes).
    - [x] If an SDL error occurs, retrieve the error message (e.g., using `SDL.SDL_GetError()`).
    - [x] Log errors using a simple mechanism for the prototype (e.g., `Console.WriteLine($"Error in {methodName}: {SDL.SDL_GetError()}");`).
    - [x] Decide on an error strategy for the prototype (e.g., throw an exception, return a boolean success/failure from `Night` API methods).
    - **Verification:** Invalid operations (e.g., setting title on a non-existent window if possible, or SDL internal errors) are caught and reported via console logs. The application behaves predictably (e.g., doesn't crash silently if window creation fails).

---

**Not Epic 4: Game Loop Implementation** (Status: In-Progress)

**Goal:** Implement the core game loop structure as defined in Feature 4 of the PRD, enabling the execution of a game using the `Night.Engine.Run` method.

- [x] **Task 4.1:** Implement `Night.Engine.Run<TGame>`
    - [x] Create an instance of `TGame`.
    - [x] Call `game.Load()`.
    - [x] Implement the main game loop (e.g., `while (Night.Window.IsOpen())`).
        - [x] Process system events (placeholder for now, full event handling in later tasks).
        - [x] Call `game.Update(deltaTime)` (deltaTime calculation to be basic for now).
        - [x] Call `game.Draw()`.
        - [x] Call `Night.Graphics.Present()` (assuming this will be available from Graphics module).
    - [x] Implement basic cleanup when the loop exits.
    - [x] Remove the `NotImplementedException`.
    - **Verification:** Calling `Night.Engine.Run&lt;SampleGame.Game&gt;()` from `Night.SampleGame` initializes the game, runs a basic loop, and calls `Load`, `Update`, `Draw` methods on the `SampleGame.Game` instance. Console output indicates these methods are being called.
- [x] **Task 4.2:** Resolve SDL3 native library loading for cross-platform execution (Status: In-Progress)
    - [x] Ensure `SDL3.dylib` (macOS), `SDL3.dll` (Windows), and `libSDL3.so.0` (Linux) are correctly located or copied to the output directory for `Night.SampleGame` during build.
    - [x] Verify that `mise run game` executes successfully on macOS.
    - [x] Document the solution for ensuring cross-platform native library availability.
    - **Verification:** The `DllNotFoundException` for SDL3 is resolved, and the game starts without this error on the primary development platform (macOS).



================================================
File: docs/epics/archive/epic4.md
================================================

**Epic 4: Input Handling Implementation**

**Goal:** Implement the `Night.Keyboard` and `Night.Mouse` modules for polling keyboard and mouse states, using the SDL3-CS bindings, to allow the game to respond to user input.

- [x] **Task 4.1:** Implement `Night.Keyboard.IsDown(KeyCode key)` (Status: Completed)
    - [x] Use SDL3-CS functions to get the current keyboard state (e.g., `SDL.SDL_GetKeyboardState(out int numkeys)` which returns a pointer to an array of key states).
    - [x] Define the `Night.KeyCode` enum if not already fully specified in Epic 2, ensuring it can be mapped to SDL's key representation (e.g., `SDL_Scancode` values). This mapping might involve looking up values in SDL3-CS's own enums (like `SDL_Scancode`).
    - [x] Implement the logic to check the state of the specified `Night.KeyCode` by looking up its corresponding SDL scancode in the state array returned by SDL.
    - **Verification:** Calling `Night.Keyboard.IsDown()` with various `Night.KeyCode` values correctly returns `true` when the respective keys are held down and `false` otherwise, as tested in `Night.SampleGame`.

- [x] **Task 4.2:** Implement `Night.Mouse.IsDown(MouseButton button)`
    - [x] Use SDL3-CS functions to get the current mouse button state (e.g., `SDL.SDL_GetMouseState(out float x, out float y)` which typically also returns the button mask).
    - [x] Define the `Night.MouseButton` enum (e.g., `Left`, `Middle`, `Right`, `X1`, `X2`) if not already fully specified in Epic 2.
    - [x] Map `Night.MouseButton` enum values to the SDL button masks (e.g., `SDL.SDL_BUTTON_LMASK`, `SDL.SDL_BUTTON_RMASK`).
    - [x] Implement the logic to check if the specified `Night.MouseButton` is currently pressed by checking the bitmask returned by the SDL mouse state function.
    - [x] **Verification:** Calling `Night.Mouse.IsDown()` with various `Night.MouseButton` values correctly returns `true` when the respective buttons are held down and `false` otherwise, as tested in `Night.SampleGame`.

- [x] **Task 4.3:** Implement `Night.Mouse.GetPosition()` (Status: Completed)
    - [x] Use an SDL3-CS function to get the current mouse cursor coordinates relative to the focused window (e.g., `SDL.SDL_GetMouseState(out float x, out float y)` usually provides coordinates relative to the current window, but verify this behavior with SDL3).
    - [x] Ensure the returned coordinates are cast or converted to `(int x, int y)` as per the `Night` API.
    - **Verification:** Calling `Night.Mouse.GetPosition()` returns the correct (x, y) integer coordinates of the mouse cursor within the game window boundaries.

- [x] **Task 4.4:** Define and Map `Night.KeyCode` and `Night.MouseButton` Enums (Status: Review)
    - [x] Research and define comprehensive `Night.KeyCode` and `Night.MouseButton` enums that align with common keyboard layouts and mouse buttons, and correspond to SDL3's `SDL_Scancode` and mouse button definitions provided by SDL3-CS.
    - [x] Create any necessary internal mapping functions or structures if a direct cast is not possible or if `Night` enums need to be more abstract than SDL's.
    - **Verification:** `Night.KeyCode` and `Night.MouseButton` enums are clearly defined and accurately map to the underlying SDL input system values.

- [x] **Task 4.5:** Basic Error Handling and State Management for Input (Status: Review)
    - [x] Ensure that input functions behave gracefully if called before SDL subsystems are fully initialized (e.g., return default/false values, log a warning). (Note: The main `Night.Framework.Run` should handle initialization order).
    - [x] Review SDL documentation for any specific error conditions or edge cases for the input functions being used.
    - **Verification:** Input functions do not cause crashes if queried at an inappropriate time (though this should be rare with a proper game loop) and provide default 'safe' return values.



================================================
File: docs/epics/archive/epic5.md
================================================
**Epic 5: 2D Graphics & Rendering Implementation**

**Goal:** Implement the core functionalities of the `Night.Graphics` module, enabling the loading of images as sprites and rendering them to the window. This includes screen clearing and handling the presentation of the rendered frame, all utilizing SDL3-CS bindings.

- [X] **Task 5.1:** Implement `Night.Graphics.NewImage(string filePath)` (Status: Review)
    - [X] Use SDL3-CS functions (specifically `SDL3.Image.LoadTexture()`) to load an image from a file path into an SDL Texture. This requires an active SDL Renderer.
    - [X] Refine the `Night.Sprite` class to store the SDL Texture handle, width, and height (queried using `SDL.GetTextureProperties()` and `SDL.GetNumberProperty()`).
    - [X] Implement error handling for file loading (file not found, texture load errors, property query errors, invalid dimensions) and log appropriately. Return `null` if loading fails.
    - **Verification:** Calling `Night.Graphics.NewImage()` with a path to a valid image file (e.g., a PNG) returns a `Night.Sprite` object. This object contains a non-null texture handle and correct width/height attributes. Attempting to load an invalid file results in a clear error message and no crash.

- [X] **Task 5.2:** Implement `Night.Graphics.Draw(Sprite sprite, float x, float y, float rotation = 0, float scaleX = 1, float scaleY = 1, float offsetX = 0, offsetY = 0)` (Status: Review)
    - [X] Use SDL3-CS functions to render the `SDL_Texture` associated with the `Night.Sprite` object (e.g., `SDL.SDL_RenderTexture()` or `SDL.SDL_RenderTextureRotated()`, or similar SDL3 equivalents that support rotation and scaling).
    - [X] Define the source rectangle (to draw the whole texture) and destination rectangle (`SDL_FRect` for float precision) based on the sprite's dimensions and the `x, y` parameters.
    - [X] Apply `rotation` (in degrees), `scaleX`, `scaleY`. The `offsetX` and `offsetY` parameters should define the origin point for these transformations (e.g., if (0,0), top-left; if (sprite.Width/2, sprite.Height/2), center).
    - [X] Ensure the correct SDL Renderer (obtained during window creation) is used for drawing.
    - **Verification:** Calling `Night.Graphics.Draw()` renders the specified `Night.Sprite` at the correct screen position, with the specified rotation and scale applied accurately. The origin of transformation (`offsetX`, `offsetY`) works as expected.

- [X] **Task 5.3:** Implement `Night.Graphics.Clear(Color color)` (Status: Review)
    - [X] Map the `Night.Color` struct (R, G, B, A byte values) to the format required by SDL.
    - [X] Use SDL3-CS functions to set the renderer's current drawing color (e.g., `SDL.SDL_SetRenderDrawColor()`).
    - [X] Use SDL3-CS functions to clear the entire rendering target with the set color (e.g., `SDL.SDL_RenderClear()`).
    - **Verification:** Calling `Night.Graphics.Clear()` fills the game window with the specified `Night.Color`.

- [X] **Task 5.4:** Implement `Night.Graphics.Present()` (Actual call in Game Loop) (Status: Review)
    - [X] The `Night.Graphics.Present()` method now calls `SDL.RenderPresent()` using the active renderer. This is called by `Night.Framework.Run()` after all `Draw()` calls for a frame.
    - [X] Error handling for `SDL.RenderPresent()` has been added.
    - **Verification:** The method `Night.Graphics.Present()` exists, calls `SDL.RenderPresent()`, and graphics drawn in the `Draw()` phase are now visible on screen.

- [X] **Task 5.5:** Renderer Initialization and Management (Status: Review)
    - [X] Confirm that the SDL Renderer instance is properly created (typically alongside the SDL Window in Epic 3, e.g., via `SDL.SDL_CreateRenderer()`) and stored internally where `Night.Graphics` methods can access it.
        - *Implementation Notes: Renderer is created in `Night.Window.SetMode()` using `SDL.CreateRenderer(window, null)`, requesting a hardware-accelerated renderer. It's stored in `Night.Window` and accessed by `Night.Graphics` via `Window.RendererPtr`.*
    - [X] Ensure renderer flags are appropriately set during creation (e.g., for hardware acceleration, vsync if desired by default for the prototype).
        - *Implementation Notes: Hardware acceleration is implicitly requested. VSync was not set via `CreateRenderer` flags due to SDL3-CS overload; SDL3 typically defaults to VSync with accelerated renderers or it can be set via `SDL.SetRenderVSync()` post-creation if needed.*
    - [X] Implement logic for destroying the SDL Renderer when the window is closed or the application quits (e.g., `SDL.SDL_DestroyRenderer()`).
        - *Implementation Notes: `Night.Window.Shutdown()` method added to destroy renderer, window, and quit video subsystem. This is called from `Night.Framework.Run()` on exit.*
    - **Verification:** Graphics operations use a valid, initialized SDL Renderer. The renderer is cleanly destroyed on application exit.

- [ ] **Task 5.6:** Basic Error Handling for Graphics Operations
    - [ ] For all relevant SDL3-CS graphics function calls, check return values for errors.
    - [ ] Retrieve and log specific SDL error messages (e.g., using `SDL.SDL_GetError()`) via `Console.WriteLine` or a similar simple logging mechanism for the prototype.
    - **Verification:** Errors during graphics operations (e.g., texture loading failure, issues during rendering calls) are reported with meaningful messages. The application does not crash silently due to graphics errors.



================================================
File: docs/epics/archive/epic6.md
================================================
**Epic 6: Game Loop Implementation** `Status: In-Progress`

**Goal:** Implement the `Night.Engine` class to manage the main game loop. This includes initializing and shutting down SDL, polling for events (especially quit events), calling the user-defined `Load`, `Update`, and `Draw` methods in the correct sequence, managing frame timing (delta time), and handling screen presentation.

- [x] **Task 6.1:** Implement Core `Night.Engine.Run(IGame gameLogic)` Structure `Status: Review`

  - [x] Define an interface (e.g., `Night.IGame`) that user game classes will implement, specifying methods like `Load()`, `Update(double deltaTime)`, `Draw()`, and optional input event handlers like `KeyPressed(KeyCode key, bool isRepeat)` etc., if this event-based approach is chosen for Feature 4. (Verified: Exists in `Types.cs`)
  - [x] Implement the main `Night.Engine.Run(IGame gameLogic)` method. (Verified: Implemented in `FrameworkLoop.cs`)
  - [x] **Initialization:**
    - [x] Inside `Run`, before the loop, call `SDL.SDL_Init(SDL.SDL_INIT_VIDEO | ...other_subsystems_if_needed...)` using SDL3-CS. Log errors if initialization fails. (Verified: `SDL.Init(SDL.InitFlags.Video | SDL.InitFlags.Events)` in `FrameworkLoop.cs`)
    - [x] Call the provided `gameLogic.Load()` method once after successful SDL initialization. (Verified: Implemented in `FrameworkLoop.cs`)
  - [x] **Main Loop:**
    - [x] Implement the primary game loop (e.g., `while (Night.Window.IsOpen()) { ... }`). The `Night.Window.IsOpen()` flag (from Epic 3) will be controlled by quit events. (Verified: Implemented in `FrameworkLoop.cs`)
  - [x] **Shutdown:**
    - [x] After the loop terminates, call appropriate SDL cleanup functions (e.g., destroy window, destroy renderer if not handled elsewhere, `SDL.SDL_QuitSubSystem(...)`, `SDL.SDL_Quit()`). (Verified: `Window.Shutdown()` and `SDL.Quit()` in `FrameworkLoop.cs`)
  - **Verification:** Calling `Night.Engine.Run()` with a simple `IGame` implementation initializes SDL, calls `Load()`, enters a loop, and then quits SDL. The `Night.SampleGame` can be launched using this. (Verified: `SampleGame/Program.cs` updated)

- [x] **Task 6.2:** Implement Event Polling within the Game Loop `Status: Review`
  - [x] Inside the main loop, use SDL3-CS functions to poll for SDL events (e.g., `while (SDL.SDL_PollEvent(out SDL_Event ev) != 0) { ... }`). (Verified: Implemented in `FrameworkLoop.cs`)
  - [x] Handle `SDL_EVENT_QUIT`: If this event is received, set the internal flag that `Night.Window.IsOpen()` checks to `false` to terminate the game loop. (Verified: Implemented in `FrameworkLoop.cs` via `Window.Close()`)
  - [x] **Task 6.2.1:** Implement `IGame.KeyPressed` callback `Status: Review`
    - [x] Add `KeyPressed(Night.KeySymbol key, Night.KeyCode scancode, bool isRepeat)` method to the `Night.IGame` interface. (Verified: Implemented in `Types.cs` with new `KeySymbol` enum)
    - [x] In `FrameworkLoop.cs`, when an `SDL.EventType.KeyDown` event occurs, call `game.KeyPressed` with mapped parameters. (Verified: Implemented in `FrameworkLoop.cs` using `KeySymbol`)
    - [x] Implement `KeyPressed` in `SampleGame` to demonstrate functionality (e.g., log key presses or quit on Escape). (Verified: Implemented in `SampleGame/Program.cs` using `KeySymbol`)
    - **Verification:** Pressing keys in the `SampleGame` triggers the `KeyPressed` callback with correct parameters (correct `KeySymbol` and `KeyCode`), and the sample implementation (e.g., logging or quitting) works as expected.
  - (Optional for initial prototype, can be basic) If pursuing event-based input handlers from Feature 4:
    - [x] Based on `ev.type`, dispatch to relevant `gameLogic` methods (e.g., `gameLogic.KeyPressed(ev.key.keysym.sym, ...)`). This requires mapping SDL event data to `Night` API parameters. (Addressed by Task 6.2.1 with `KeySymbol`)
  - **Verification:** The game loop correctly polls for events. The application closes cleanly when the window's close button is clicked (which generates an `SDL_EVENT_QUIT`). If basic event handlers are implemented, they are triggered. The `KeyPressed` callback is now a basic event handler with corrected key symbol reporting.

- [x] **Task 6.3:** Implement Delta Time Calculation and Pass to `Update` `Status: Review`
  - [x] Before the main loop, get initial timing values using SDL3-CS timing functions (e.g., `SDL.SDL_GetPerformanceCounter()` and `SDL.SDL_GetPerformanceFrequency()` for high-resolution timing, or `SDL.SDL_GetTicks()` for millisecond-based timing).
  - [x] At the beginning of each loop iteration (or end), calculate the time elapsed since the last frame (`deltaTime`) in seconds (e.g., as a `double` or `float`).
  - [x] Call `gameLogic.Update(deltaTime)` method, passing the calculated delta time.
  - **Verification:** The `gameLogic.Update()` method is called each frame and receives a `deltaTime` value that reasonably reflects the actual time elapsed per frame. Frame rate can be roughly monitored (e.g., by logging FPS) for stability.

- [x] **Task 6.4:** Integrate `gameLogic.Draw()` and Screen Presentation `Status: Review`
  - [ ] Inside the main loop, after `gameLogic.Update(deltaTime)`, call `gameLogic.Draw()`.
  - [ ] Immediately after `gameLogic.Draw()` completes, call the SDL function to present the renderer's back buffer to the window (e.g., `SDL.SDL_RenderPresent(rendererHandle)` using the renderer handle established in Epic 3/5).
  - **Verification:** The `gameLogic.Draw()` method is called each frame. Graphics drawn within this method (using `Night.Graphics` calls) are visible on the screen and update frame by frame.

- [x] **Task 6.5:** Basic Game Loop Error Handling and Robustness `Status: Review`
  - [x] Wrap calls to user-provided `gameLogic` methods (`Load`, `Update`, `Draw`, event handlers) in `try-catch` blocks. (Verified: `Load` covered by main try-catch; `Update`, `Draw`, `KeyPressed` have specific try-catch blocks in `FrameworkLoop.cs`)
  - [x] If an exception occurs in user code, log the exception (e.g., `Console.WriteLine`) and decide on a strategy: (Verified: Exceptions are logged, and `Window.Close()` is called to terminate loop gracefully for `Update`, `Draw`, `KeyPressed`. `Load` exceptions also lead to cleanup.)
    - For prototype: an unhandled exception in user code might gracefully terminate the engine loop and ensure SDL is shut down. (Verified)
  - [x] Ensure SDL initialization and shutdown are robust (e.g., `SDL_Quit` is always called even if `Load` throws an error). (Verified: Handled by the main `try-finally` block in `FrameworkLoop.cs`)
  - **Verification:** Unhandled exceptions within the `gameLogic` methods are caught by the `Night.Engine`, an error is logged, and the engine attempts to shut down SDL and exit cleanly rather than crashing without context.



================================================
File: docs/epics/archive/epic7-design.md
================================================
# Epic 7: Night.SampleGame - Platformer Design

This document outlines the design for the simple platformer game to be built using the Night Engine, as part of Epic 7.

## 1. Player Character

- **Appearance:** A solid **blue** colored rectangle.
- **Size:**
  - Width: 32 pixels
  - Height: 64 pixels
- **Initial Position:** Centered horizontally, resting on the first platform.

## 2. Player Actions

Player actions are controlled via keyboard input.

- **Move Left:**
  - **Input:** `Night.KeyCode.Left` (Left Arrow Key)
  - **Action:** Player character moves horizontally to the left at a defined speed.
- **Move Right:**
  - **Input:** `Night.KeyCode.Right` (Right Arrow Key)
  - **Action:** Player character moves horizontally to the right at a defined speed.
- **Jump:**
  - **Input:** `Night.KeyCode.Space` (Spacebar)
  - **Action:** Player character gains an initial upward vertical velocity. Gravity will then affect the player, bringing them back down. The player can only jump if they are currently on a platform (grounded).

## 3. Level Elements

The level will consist of static platforms.

- **Platforms:**
  - **Appearance:** Solid **green** colored rectangles.
  - **Properties:** Each platform will be defined by its position (X, Y coordinates of the top-left corner) and size (width, height).
  - **Arrangement (Example for initial prototype):**
    - Platform 1 (Ground):
      - Position: (X: 50, Y: 500)
      - Size: (Width: 700, Height: 50)
    - Platform 2:
      - Position: (X: 200, Y: 400)
      - Size: (Width: 150, Height: 30)
    - Platform 3:
      - Position: (X: 450, Y: 300)
      - Size: (Width: 100, Height: 30)
    - Platform 4 (Goal Platform):
      - Position: (X: 600, Y: 200)
      - Size: (Width: 100, Height: 30)
      - **Special:** Reaching this platform signifies the objective.

## 4. Game Objective / Success State

- **Objective:** The player must navigate their character from the starting platform to **Platform 4 (Goal Platform)**.
- **Success State:** The game successfully demonstrates stable player movement (left, right, jump), collision with platforms (landing, not passing through), and the ability to reach the designated goal platform. For the prototype, simply reaching the platform is sufficient; no complex "win" screen is required.

## 5. Implementation Checklist (for Tasks 7.2+)

This section can be used to track progress for subsequent implementation tasks.

### Task 7.2: Implement Player Character

- [ ] Create `Player` class in `Night.SampleGame`.
- [ ] `Player.Load()`:
  - [ ] Initialize player position (e.g., centered on Platform 1).
  - [ ] Initialize player size (32x64).
  - [ ] Initialize movement properties (speed, jump height, gravity value).
  - [ ] (No sprite loading needed, will draw a rectangle).
- [ ] `Player.Update(double deltaTime)`:
  - [ ] Handle horizontal movement input (`Night.Keyboard.IsDown(Night.KeyCode.Left)` / `Right`).
  - [ ] Implement jump logic (`Night.Keyboard.IsDown(Night.KeyCode.Space)`), apply upward velocity (only if grounded).
  - [ ] Apply gravity to vertical velocity.
  - [ ] Update player position based on velocity and `deltaTime`.
- [ ] `Player.Draw()`:
  - [ ] Render the player as a blue rectangle at its current position. (Requires a way to draw filled rectangles with `Night.Graphics`. If not directly available, a 1x1 white pixel sprite could be loaded and scaled/colored, or this highlights a need for basic primitive drawing).
        *Self-correction: PRD Feature 3 for `Night.Graphics` focuses on "loading images and drawing them as sprites". It does not explicitly mention drawing geometric primitives like rectangles. For the prototype, if `Night.Graphics.DrawRectangle(x, y, w, h, color)` is not available, the player (and platforms) might need to be represented by simple 1x1 pixel sprites that are then scaled and tinted, or use a pre-made colored square image if tinting is not yet supported. The design assumes a simple way to draw a colored rectangle will be feasible, potentially by creating a small colored texture in memory if direct drawing isn't an option.*

### Task 7.3: Implement Basic Level (Platforms)

- [ ] Define platform data (e.g., array/list of `Night.Rectangle` or custom struct for position, size, color).
  - [ ] Platform 1: (X: 50, Y: 500), Size: (700x50), Color: Green
  - [ ] Platform 2: (X: 200, Y: 400), Size: (150x30), Color: Green
  - [ ] Platform 3: (X: 450, Y: 300), Size: (100x30), Color: Green
  - [ ] Platform 4: (X: 600, Y: 200), Size: (100x30), Color: Green (Goal)
- [ ] `Game.Load()` or `Level.Load()`: Initialize platform objects/data.
- [ ] `Game.Update()` or `Player.Update()`:
  - [ ] Implement AABB collision detection between player and platforms.
  - [ ] Resolve collisions:
    - [ ] Prevent player from falling through platforms (stop downward movement).
    - [ ] Prevent player from moving horizontally into platforms.
- [ ] `Game.Draw()` or `Level.Draw()`:
  - [ ] Render platforms as green rectangles. (Same rendering consideration as the player character).

### Task 7.4: Implement Main Game Logic in `Game.cs`

- [ ] Ensure `Night.SampleGame.Game` class implements `Night.IGame`.
- [ ] `Game.Load()`:
  - [ ] Initialize/Load player object.
  - [ ] Initialize/Load platform data/level objects.
  - [ ] Set window title to "Night Platformer Sample".
  - [ ] Set window size (e.g., 800x600).
- [ ] `Game.Update(double deltaTime)`:
  - [ ] Call `Player.Update(deltaTime)`.
  - [ ] (Optional: Check if player reached Platform 4 - simple log message for now).
- [ ] `Game.Draw()`:
  - [ ] `Night.Graphics.Clear(backgroundColor)` (e.g., light gray or sky blue).
  - [ ] Call draw methods for platforms.
  - [ ] Call draw method for the player.
- [ ] **Verification:** `Night.SampleGame` runs via `Night.Engine.Run(new Game())`. All elements are present and interactive.



================================================
File: docs/epics/archive/epic7.md
================================================

**Status: In-Progress**

**Epic 7: Sample Game & Integration Testing**

**Goal:** Develop a simple platformer game using the "Night Engine." This sample game will serve as a comprehensive integration test, verifying that all core engine features (Window, Input, Graphics, Game Loop) function correctly and cohesively as defined in the PRD.

- [X] **Task 7.1:** Design Basic Platformer Game Mechanics for `Night.SampleGame`
  - [x] Define the player character: appearance (e.g., a simple colored rectangle or a basic sprite), size.
  - [x] Define player actions: move left, move right, jump.
  - [x] Define basic level elements: static platforms (rectangles) for the player to stand on and jump between.
  - [x] Define a simple objective or success state for the prototype (e.g., navigate to a specific point, or simply demonstrate stable movement and interaction).
  - **Verification:** A minimal design document or sketch outlining the platformer's mechanics, player abilities, and level structure is created.

**Status: Review**

- [X] **Task 7.2:** Implement Player Character in `Night.SampleGame`
  - [X] Create a `Player` class within the `Night.SampleGame` project. (`src/Night.SampleGame/Player.cs`)
  - [X] **Loading:** In a `Player.Load()` method (or equivalent called from `Game.Load()`), if using a sprite, load it using `Night.Graphics.NewImage()`. Initialize player position, size, and movement properties (e.g., speed, jump height, gravity). (Assumes `assets/images/player_sprite_blue_32x64.png` exists)
  - [X] **Updating:** In a `Player.Update(double deltaTime)` method:
    - [X] Handle horizontal movement input using `Night.Keyboard.IsDown(Night.KeyCode.Left)` and `Night.Keyboard.IsDown(Night.KeyCode.Right)`.
    - [X] Implement jump logic (e.g., on `Night.Keyboard.IsDown(Night.KeyCode.Space)`), applying an upward velocity.
    - [X] Apply basic gravity to the player's vertical velocity.
    - [X] Update player position based on velocity and `deltaTime`. (Includes temporary floor collision)
  - [X] **Drawing:** In a `Player.Draw()` method, render the player (rectangle or sprite) at its current position using `Night.Graphics.Draw()`.
  - **Verification:** The player character is displayed on the screen. It responds to left/right arrow key presses by moving horizontally. Pressing the jump key makes the player move upwards and then fall due to gravity. (Requires `assets/images/player_sprite_blue_32x64.png` to be visible).
**Status: Review**
- [X] **Task 7.3:** Implement Basic Level (Platforms) in `Night.SampleGame`
  - [X] Define platform data (e.g., an array or list of `Night.Rectangle` structs for position and size).
  - [X] In `Game.Load()` or a `Level.Load()` method, initialize these platforms.
  - [X] In `Game.Update()` or `Player.Update()`, implement simple Axis-Aligned Bounding Box (AABB) collision detection between the player and the platforms.
    - [X] Resolve collisions by preventing the player from passing through platforms (e.g., stop downward movement when landing on top of a platform, block horizontal movement into the side of a platform).
    - [X] Stabilize player on platforms to prevent jittering.
  - [X] In `Game.Draw()` or a `Level.Draw()` method, render the platforms (e.g., as filled rectangles using a conceptual `Night.Graphics.DrawRectangle()` if added, or by drawing placeholder sprites for each). _Self-correction: The PRD doesn't specify `DrawRectangle`. For the prototype, platforms can be represented by loaded sprites or this might highlight a small graphics primitive need for the sample._
  - **Verification:** Platforms are rendered on the screen. The player character can land on top of platforms and is appropriately stopped by them without jitter. The player does not fall through platforms.

- [X] **Task 7.4:** Implement Main Game Logic in `Program.cs` (integrating `IGame`)
  - [X] Ensure `Night.SampleGame.Game` class properly implements the `Night.IGame` interface (from Epic 6). (Implemented within `Program.cs`)
  - [X] **`Game.Load()`:** Initialize the player object, platform data/level objects, and load any other necessary assets. (Includes window setup, player load, platform data, and platform sprite loading)
  - [X] **`Game.Update(double deltaTime)`:** Call the `Player.Update(deltaTime)` method. Update any other game state logic (e.g., checking simple win/lose conditions if designed). (Includes win condition check for reaching goal platform)
  - [X] **`Game.Draw()`:**
    - [X] Call `Night.Graphics.Clear(backgroundColor)` at the beginning.
    - [X] Call draw methods for platforms and the player, ensuring correct layering if relevant.
  - **Verification:** The `Night.SampleGame` runs via `Night.Framework.Run(new Game())`. All game elements (player, platforms) are initialized, updated, and drawn correctly each frame, demonstrating the integrated use of `Night.Window`, `Night.Input`, `Night.Graphics`, and the `Night.Engine` game loop. _Note: `Program.cs` uses `Night.Framework.Run` which aligns with PRD; epic mentions `Night.Engine.Run`._

**Status: Review**

**Log for Task 7.4 (2025-05-27):**
- Confirmed `Game` class (within `Program.cs`) implements `IGame`.
- `Game.Load()` now initializes player, platforms (including goal platform), loads platform sprite, and sets up window title/size.
- `Game.Update()` calls `player.Update()` and includes a win condition check (console message on reaching goal platform).
- `Game.Draw()` clears screen, draws platforms (using scaled sprite), and draws player.
- `Game.KeyPressed()` handles Escape key for closing.
- The `Game` class remains within `Program.cs` as per user clarification.

- [ ] **Task 7.5:** End-to-End Feature Verification & Bug Fixing
  - [ ] Play through the `Night.SampleGame` platformer, systematically testing all implemented `Night` engine features:
    - Window creation and title (`Night.Window`).
    - Keyboard input for player control (`Night.Keyboard`).
    - Mouse input for position checking, if used for any debug (`Night.Mouse`).
    - Sprite loading and rendering for player/platforms (`Night.Graphics`).
    - Screen clearing (`Night.Graphics`).
    - Game loop operation, delta time, and event handling (`Night.Engine`).
  - [ ] Compare observed behavior against the feature descriptions in the PRD.
  - [ ] Document any bugs, unexpected behaviors, or deviations from the PRD.
  - [ ] Iterate on bug fixes within the `Night.Engine` or `Night.SampleGame` code until the prototype functions as intended for the defined features.
  - **Verification:** The sample platformer game is playable and all core `Night` engine features (PRD Features 1-4) are demonstrably working as expected. Any significant bugs identified during testing have been addressed.



================================================
File: docs/epics/archive/epic8.md
================================================
**Epic 8: Migrate SDL C# Bindings to SDL3# NuGet Package**

**Goal:** Successfully integrate the `edwardgushchin/SDL3-CS` (SDL3#) NuGet package into `Night.Engine` to replace the previously removed SDL3 bindings. This includes updating all engine code that interacts with SDL3, revising the native library management strategy, and ensuring the `Night.SampleGame` is fully functional with the new bindings.

- [x] **Task 8.1:** Research and Plan SDL3# Integration Strategy
  **Status: Completed**
    - [x] Thoroughly review the API of the `edwardgushchin/SDL3-CS` (SDL3#) NuGet package. Compare its namespaces (e.g., `SDL3`), static class names (e.g., `SDL`), enums (e.g., for InitFlags, EventType, KeyCode/Scancode, WindowFlags, MouseButton), structs (e.g., `SDL_Event` or its equivalent), and function signatures/return types with what was previously used or expected.
    - [x] Document key differences that will impact existing `Night.Engine` code in files like `FrameworkLoop.cs`, `Modules/Window.cs`, `Modules/Keyboard.cs`, `Modules/Mouse.cs`, `Modules/Graphics.cs`, `Modules/SDL.cs`, and `Types.cs`.
    - [x] **Decision Point:** Determine the strategy for managing native SDL3 libraries with SDL3#:
        - **Option A (Recommended):** Utilize the `SDL3-CS.Native` NuGet package alongside `SDL3-CS`. This would likely replace the current `scripts/update_sdl3.py` and `lib/SDL3-Prebuilt/` system for managing native binaries.
        - **Option B:** Continue managing native binaries manually (e.g., keep `scripts/update_sdl3.py` and `lib/SDL3-Prebuilt/`) if the `SDL3-CS.Native` package is unsuitable or if the existing pre-built binaries from `nightconcept/build-sdl3` (mentioned in `scripts/update_sdl3.py` ) are preferred or customized.
### Migration Plan & API Research (Task 8.1)

**Problem Description:**
The `Night.Engine` currently lacks SDL3 bindings after the removal of the previous `flibitijibibo-sdl3-cs` submodule. The task is to integrate the `edwardgushchin/SDL3-CS` (SDL3#) NuGet package, update all engine code, and decide on a native library management strategy.

**Solution Overview:**
The `edwardgushchin/SDL3-CS` (SDL3#) library, built locally from the submodule in `lib/SDL3-CS`, will be adopted as the new C# binding for SDL3. Native SDL3 libraries will be managed manually (Option B), likely by ensuring `scripts/update_sdl3.py` provides compatible .NET 9 binaries or by updating that script and `lib/SDL3-Prebuilt/`. Engine code will be updated to use the new SDL3# API, focusing on changes in namespaces, static class access, function signatures (especially return types like `bool` for `SDL.Init`), and enum/struct mappings.

**Implementation Steps (Derived from Task 8.1 research):**

1.  **Native Library Management Strategy:**
    *   **Decision:** Adopt **Option B (Modified)**. The `SDL3-CS` C# bindings will be built locally from the submodule (`lib/SDL3-CS`) and referenced as a DLL. Native SDL3 binaries (e.g., `SDL3.dll`, `libSDL3.so`) will be managed manually, likely by updating/using `scripts/update_sdl3.py` and the `lib/SDL3-Prebuilt/` directory to ensure .NET 9 compatible binaries are available. The `SDL3-CS.Native` NuGet package will **not** be used.
    *   **Rationale:** Per user feedback, to use locally built .NET 9 DLLs. This requires manual management of both the C# binding DLL and the underlying native SDL3 binaries.

2.  **Key API Differences and Impact on `Night.Engine`:**

    *   **General:**
        *   **Namespace:** Old bindings might have used a different namespace or none for static P/Invoke style. SDL3# uses the `SDL3` namespace. All relevant files will need `using SDL3;`.
        *   **Static Class:** SDL functions are called via the static `SDL` class (e.g., `SDL.Init()`, `SDL.GetError()`). Previous direct P/Invokes or wrapper classes will need to be updated.
        *   **Return Types:**
            *   `SDL.Init()` now returns `bool` directly, instead of an `int` that `Night.SDL.Init` previously converted from `SDLBool`. [`src/Night.Engine/Modules/SDL.cs`](src/Night.Engine/Modules/SDL.cs:1) will need significant changes here.
            *   Many other functions likely return `bool` for success/failure instead of integer codes. This needs to be checked for each function call being replaced.
        *   **Error Handling:** `SDL.GetError()` remains the standard way to get error messages.

    *   **`FrameworkLoop.cs`:**
        *   Event polling loop: `while (SDL.PollEvent(out var e))` is the new pattern. The `SDL.Event` struct (`e`) is a C# union-like struct.
        *   Event type checking: `(SDL.EventType)e.Type == SDL.EventType.Quit`.

    *   **`Modules/Window.cs`:**
        *   Window creation: Functions like `SDL.CreateWindow()` or `SDL.CreateWindowAndRenderer()` will be used. Parameter types and order, and especially `WindowFlags`, need to be mapped.
        *   `SDL.WindowFlags` (e.g., `SDL.WindowFlags.Fullscreen`, `SDL.WindowFlags.Resizable`) will replace any previous window flag enums. `Night.WindowFlags` in [`src/Night.Engine/Types.cs`](src/Night.Engine/Types.cs:1) will need to be updated or removed if directly using `SDL.WindowFlags`.

    *   **`Modules/Keyboard.cs`:**
        *   Event handling: `SDL.KeyboardEvent` (from `SDL.Event.Key`) will provide key press/release info.
        *   Key codes:
            *   `SDL.Scancode` enum (physical keys, e.g., `SDL.Scancode.A`). This is the likely equivalent if `Night.KeyCode` was based on scancodes.
            *   `SDL.Keycode` enum (virtual keys, layout-dependent, e.g., `SDL.Keycode.A`).
            *   The existing `Night.KeyCode` in [`src/Night.Engine/Types.cs`](src/Night.Engine/Types.cs:1) (which maps to `SDL_Scancode` values) needs to be carefully compared and mapped to `SDL.Scancode`.
        *   Modifier keys: `SDL.Keymod` enum will be used for checking Ctrl, Shift, Alt states, likely part of `SDL.KeyboardEvent`.

    *   **`Modules/Mouse.cs`:**
        *   Event handling: `SDL.MouseButtonEvent` (from `SDL.Event.Button`) for clicks, `SDL.MouseMotionEvent` (from `SDL.Event.Motion`) for movement, `SDL.MouseWheelEvent` (from `SDL.Event.Wheel`) for scroll.
        *   Mouse button identification:
            *   `SDL.MouseButtonEvent.button` will contain raw indices (1 for Left, 2 for Middle, etc., from `SDL.ButtonLeft`, `SDL.ButtonMiddle` constants).
            *   `SDL.GetMouseState()` will return a bitmask of `SDL.MouseButtonFlags` (e.g., `SDL.MouseButtonFlags.Left`).
            *   `Night.MouseButton` in [`src/Night.Engine/Types.cs`](src/Night.Engine/Types.cs:1) will need to be mapped.
        *   Mouse position: Likely available in `SDL.MouseMotionEvent` and via functions like `SDL.GetMouseState()`.

    *   **`Modules/Graphics.cs`:**
        *   Renderer and Window handles: Obtained from `SDL.CreateWindowAndRenderer()` or similar.
        *   Drawing functions: `SDL.RenderClear()`, `SDL.RenderPresent()`, `SDL.SetRenderDrawColor()`, etc., will be used. Signatures need checking.

    *   **`Modules/SDL.cs`:**
        *   This file, which currently wraps/passes through calls, will need substantial updates.
        *   `Init` method needs a complete rewrite due to the `bool` return type.
        *   Other wrapped SDL functions will need to be updated to call `SDL.Function()` from the new bindings.

    *   **`Types.cs`:**
        *   `Night.KeyCode`: Verify and map to `SDL.Scancode` (as per epic note) or `SDL.Keycode` if the intent was virtual keys.
        *   `Night.WindowFlags`: Update to map to/utilize `SDL.WindowFlags` or be replaced by it.
        *   `Night.MouseButton`: Update to map to raw button indices (1,2,3...) or `SDL.MouseButtonFlags` depending on usage context.
        *   Any other SDL-dependent types (e.g., event structs if they were previously exposed differently) will need review.

3.  **Detailed Checklist of Code Sections for Modification (Initial List):**
    *   **Project Files:**
        *   `src/Night.Engine/Night.Engine.csproj`: Remove old binding reference (if any remains). Add a `<ProjectReference>` to the local `SDL3-CS.csproj` (e.g., `../../lib/SDL3-CS/SDL3-CS/SDL3-CS.csproj`). Ensure the `SDL3-CS` submodule is built (e.g., via `dotnet build -c Release` in `lib/SDL3-CS`).
        *   `src/Night.SampleGame/Night.SampleGame.csproj`: Retain or update native library copy steps from `lib/SDL3-Prebuilt/` to ensure the correct native SDL3 binaries are copied to the output directory.
    *   **`src/Night.Engine/FrameworkLoop.cs`:**
        *   Event polling loop (`SDL.PollEvent`, `SDL.Event`, `SDL.EventType`).
        *   Quit event handling.
    *   **`src/Night.Engine/Modules/SDL.cs`:**
        *   `Init()` method.
        *   `Quit()` method.
        *   `GetError()` wrapping.
        *   All other SDL function wrappers.
    *   **`src/Night.Engine/Modules/Window.cs`:**
        *   Window creation functions (e.g., `CreateWindow`).
        *   Window property functions (title, size, position, flags).
        *   Usage of `WindowFlags`.
    *   **`src/Night.Engine/Modules/Keyboard.cs`:**
        *   Key press/release detection.
        *   Mapping/usage of `Night.KeyCode` with `SDL.Scancode` / `SDL.Keycode`.
        *   Modifier key state.
    *   **`src/Night.Engine/Modules/Mouse.cs`:**
        *   Mouse button press/release detection.
        *   Mapping/usage of `Night.MouseButton`.
        *   Mouse motion/position retrieval.
        *   Mouse wheel event handling.
    *   **`src/Night.Engine/Modules/Graphics.cs`:** (Primarily SDL function call updates)
        *   `Clear`
        *   `Present`
        *   `SetDrawColor`
        *   Any other rendering calls.
    *   **`src/Night.Engine/Types.cs`:**
        *   `Night.KeyCode` enum definition and mapping.
        *   `Night.WindowFlags` enum definition and mapping.
        *   `Night.MouseButton` enum definition and mapping.
        *   Any other internal structs/enums that wrap or mirror SDL types.
    *   **All files using SDL functionality:**
        *   Update `using` statements to `using SDL3;`.
        *   Change direct P/Invokes or old wrapper calls to `SDL.FunctionName()`.
        *   Adapt to new struct/enum names and function signatures.

**Risks/Challenges:**
*   **API Completeness:** Ensuring SDL3# provides all necessary functions that were used from the previous bindings. The "Readiness" table in SDL3# README is promising.
*   **Subtle Behavioral Changes:** Differences in how SDL3 itself or the new bindings handle certain edge cases or return values compared to the old setup.
*   **Enum/Struct Mapping:** Correctly mapping existing `Night.*` enums/structs to their new SDL3# counterparts (e.g., `KeyCode` to `Scancode` vs. `Keycode`, `MouseButton` values). This requires careful attention to the previous intent.
*   **Build/Runtime Issues with Native Libraries:** Manual management of native SDL3 binaries requires ensuring the correct versions (compatible with .NET 9 and the locally built SDL3-CS) are obtained (e.g., via `scripts/update_sdl3.py`) and correctly placed/copied for both `Night.Engine` and `Night.SampleGame` to run. This includes potential cross-platform considerations if testing on multiple OS.
*   **SDL3-CS Submodule Build:** The `lib/SDL3-CS` submodule must be successfully built before `Night.Engine` can reference its output.
- - [x] Create a detailed checklist of specific code sections in `Night.Engine` that will require modification.
    - [x] **Verification:** A clear migration plan is documented, including the chosen native library strategy (Option A or B) and a comprehensive list of anticipated code changes and potential challenges.
- [x] **Task 8.2:** Branch for Migration (If not already on a dedicated branch)
    
    - [x] Ensure work is being done on a new feature branch in Git (e.g., `dev`).
    - [x] Confirm the current project state (with old bindings removed) is committed.
    - **Verification:** Work is being done on a dedicated Git branch.
[x] **Task 8.3:** Integrate Locally Built `SDL3-CS` (SDL3#) Library
    **Status: Completed**

- [x] Confirm that any `<ProjectReference>` to the old `flibitijibibo-sdl3-cs` submodule has been removed from `src/Night.Engine/Night.Engine.csproj`.
- [x] Ensure the `lib/SDL3-CS` submodule is updated and buildable (e.g., `git submodule update --init --recursive`, then `dotnet build -c Release` within `lib/SDL3-CS`).
- [x] Add a `<ProjectReference>` to the local `SDL3-CS.csproj` (e.g., `../../lib/SDL3-CS/SDL3-CS/SDL3-CS.csproj`) in `src/Night.Engine/Night.Engine.csproj`.
- [x] Verify that native SDL3 binaries (e.g., `SDL3.dll` for Windows) are correctly managed (e.g., via `scripts/update_sdl3.py` and `lib/SDL3-Prebuilt/`) and accessible by `Night.Engine` and `Night.SampleGame`. (User to ensure native binaries are in place and copied to output).
- - **Verification:** `Night.Engine` and `Night.SampleGame` projects restore and build successfully, referencing the locally built `SDL3-CS.dll`. The application can locate and load the native SDL3 binaries at runtime. (Builds referencing `SDL3-CS.dll` are now possible; native loading depends on user's manual management of binaries).
- [x] **Task 8.4:** Update `Night.Engine` Code to Utilize SDL3# Bindings
    **Status: Completed**
    - [x] Referencing the checklist from Task 8.1, systematically update all C# files within `Night.Engine` that previously interacted with SDL3.
    - [x] Modify `using` statements if the namespace structure or static class access of SDL3# differs. The target seems to be `using SDL3;` and then `SDL.FunctionName()`.
    - [x] Update all calls to SDL functions, enums, structs, and constants to match the API provided by the new `SDL3-CS` (SDL3#) package. This will involve careful comparison of function signatures, parameter types, return types (e.g., `SDL_GetError()` vs. `SDL.GetError()`), and naming conventions (e.g., `SDL_INIT_VIDEO` from `flibitijibibo-sdl3-cs` vs. `SDL.InitFlags.Video` in the SDL3# example).
    - [x] Pay special attention to `Night.Types.cs`; ensure `Night.KeyCode`, `Night.WindowFlags`, etc., correctly map to or utilize the new SDL3# enum values. The existing `KeyCode` enum, for example, maps directly to `SDL_Scancode` values, which will need verification against the new bindings.
    - [x] Refactor or rewrite `src/Night.Engine/Modules/SDL.cs` to correctly wrap or pass through calls to the new SDL3# API. For instance, the existing `Night.SDL.Init` converts `SDLBool` to `int`; this will need to adapt to SDL3#'s `SDL.Init` which directly returns a `bool`.
- - **Verification:** `Night.Engine` compiles successfully against the new SDL3# bindings without any errors.
- [ ] **Task 8.5:** Test `Night.SampleGame` and Refactor for Compatibility
    
    - [ ] Build and run the `Night.SampleGame` project.
    - [ ] Address any compilation errors or runtime issues that arise due to changes in the SDL3 bindings or the `Night.Engine` API.
    - [ ] Thoroughly test all existing functionalities of the sample game (window creation, input handling, graphics rendering (currently stubbed), game loop operation ) to ensure they perform as expected with the new bindings.
	- [ ] **Verification:** `Night.SampleGame` builds, runs, and all features previously demonstrated (or stubbed out and called) function correctly with the migrated SDL3# bindings.
- [ ] **Task 8.6:** Update Project Documentation (PRD)

- [ ] In `docs/PRD.md`, update Section 3 ("Technical Specifications") to list `edwardgushchin/SDL3-CS` (SDL3#) NuGet package as the C# binding for SDL3, removing mention of `flibitijibibo-sdl3-cs`.
[ ] If the native library management strategy changed (e.g., by adopting `SDL3-CS.Native`):

- Update PRD Section 4 ("Project Structure") to reflect the removal of `lib/SDL3-CS` (already done by user) and potentially `lib/SDL3-Prebuilt/` and `scripts/update_sdl3.py`.
- - - Update PRD Section 5 ("File Descriptions") accordingly.
    - **Verification:** The `docs/PRD.md` accurately reflects the new SDL3 binding dependency and the chosen native library management strategy.
- [ ] **Task 8.7:** Clean Up or Update Native Library Management System
    
    - [ ] If `SDL3-CS.Native` (or an equivalent mechanism from the new SDL3# package) is adopted and successfully manages native SDL3 binaries (Option A from Task 8.1):
        - [ ] Delete the `scripts/update_sdl3.py` script.
        - [ ] Delete the `lib/SDL3-Prebuilt/` directory and its contents (including `version.txt` ).
[ ] Remove the `<Content Include...>` items from `src/Night.SampleGame/Night.SampleGame.csproj` that copied native libraries from `lib/SDL3-Prebuilt/`.
- [ ] If manual management of native libraries is retained (Option B from Task 8.1), ensure the `scripts/update_sdl3.py` script is still functional or update it as necessary to provide compatible binaries for the new SDL3# bindings.
- **Verification:** The project's method for handling native SDL3 libraries is clean, consistent with the chosen strategy, and functional. All obsolete files, scripts, and project configurations related to the old system are removed or appropriately updated.


================================================
File: docs/epics/archive/epic9.md
================================================
# Epic 9: Simplify macOS Platform Message

**User Story:** When starting the night engine, on MacOS, I want the platform message to be more simple including the MacOS version and just the darwin version, not all this extra stuff.

**Current Message Example:**
`Platform: Darwin 24.4.0 Darwin Kernel Version 24.4.0: Fri Apr 11 18:32:43 PDT 2025; root:xnu-11417.101.15~117/RELEASE_ARM64_T8103 (Arm64)`

**Desired Message Format Example:**
`Platform: macOS <version> (Darwin <kernel_version>)`

**Status:** Review

**Tasks:**

-   [x] **1. Review Project Documentation:**
    -   [x] Read `docs/PRD.md`
    -   [x] Read `docs/operational-guidelines.md`
-   [x] **2. Plan Implementation:**
    -   [x] Define Problem
    -   [x] Outline Solution
    -   [x] List Implementation Steps
    -   [x] Identify Risks/Challenges
-   [x] **3. Locate Code:**
    -   [x] Searched for the existing platform message generation logic. Found in `src/Night.Engine/FrameworkLoop.cs`.
-   [x] **4. Implement Changes:**
    -   [x] Modified C# code in `src/Night.Engine/FrameworkLoop.cs` to detect macOS.
    -   [x] Added logic to retrieve macOS version using `sw_vers -productVersion`.
    -   [x] Added logic to retrieve Darwin kernel version using `uname -r`.
    -   [x] Formatted the new platform string: `$"Platform: macOS {macOSVersion} (Darwin {darwinVersion})"`
    -   [x] Implemented error handling for version retrieval, falling back to `RuntimeInformation.OSDescription`.
-   [ ] **5. Test (Manual):**
    -   [ ] Build and run `Night.SampleGame` on macOS.
    -   [ ] Verify the console output shows the simplified platform string: `Platform: macOS <version> (Darwin <kernel_version>)`.
    -   [ ] Test error handling if possible (e.g., by temporarily making `sw_vers` inaccessible if feasible in a test environment, or by simulating an error in code to ensure fallback works).
-   [x] **6. Update Story File:**
    -   [x] Logged all significant actions, decisions, and outputs.
    -   [x] Updated task statuses.
-   [x] **7. Handoff for Review:**
    -   [x] Set status to `Review`.
    -   [x] Provided modified code and instructions for verification.

**Notes:**
Plan presented to user on 2025-05-28.
The plan involves:
- Problem: macOS platform string is too verbose.
- Solution: Retrieve macOS version (`sw_vers -productVersion`) and Darwin kernel version (`uname -r` or parse `SDL.GetPlatform()`) and format a simpler string.
- Steps: Locate code, detect macOS, retrieve versions, format string, update logic.
- Risks: Command availability, SDL string format changes, error handling.

Code changes implemented in `src/Night.Engine/FrameworkLoop.cs` to use `sw_vers` and `uname` on macOS for a simplified platform string. Fallback to `RuntimeInformation.OSDescription` is in place.


================================================
File: docs/love2d-api/roadmap.md
================================================
# Roadmap

Most functions list the Love2D equivalent module/function/callback implementation.

## Version 0.1.0

### Project

- [ ] `docfx` generation onto GitHub pages
- [ ] Tests
- [ ] Logo and icon
- [ ] CI

### Modules

- [ ] `love.filesystem`: Provides an interface to the user's filesystem.
- [ ] `love.graphics`: Drawing of shapes and images, management of screen geometry.
- [ ] `love.image`: Provides an interface to decode encoded image data.
- [ ] `love.keyboard`: Provides an interface to the user's keyboard.
- [ ] `love.mouse`: Provides an interface to the user's mouse.
- [ ] `love.timer`: Provides high-resolution timing functionality.
- [ ] `love.window`: Provides an interface for the program's window.

### Callbacks - General

- [ ] `love.draw`: Callback function used to draw on the screen every frame.
- [ ] `love.load`: This function is called exactly once at the beginning of the game.
- [ ] `love.run`: The main callback function, containing the main loop. A sensible default is used when left out.
- [ ] `love.update`: Callback function used to update the state of the game every frame.

### Callbacks - Keyboard

- [ ] `love.keypressed`: Callback function triggered when a key is pressed.
- [ ] `love.keyreleased`: Callback function triggered when a keyboard key is released.

### Callbacks - Mouse

- [ ] `love.mousepressed`: Callback function triggered when a mouse button is pressed.
- [ ] `love.mousereleased`: Callback function triggered when a mouse button is released.

### Callbacks - General

- [ ] `love.errhand`: The error handler, used to display error messages. (Note: `love.errorhandler` is also listed for 11.0, likely an alias or the preferred name)
- [ ] `love.errorhandler`: The error handler, used to display error messages.

### Types

- [ ] `Data`: The superclass of all data.
- [ ] `Object`: The superclass of all LÖVE types.
- [ ] `Variant`: The types supported by love.thread and love.event.

### General

- [ ] Config Files: Game configuration settings.

## Version 0.2.0

### Modules

- [ ] `love.joystick`: Provides an interface to connected joysticks.

### Callbacks - Joystick

- [ ] `love.joystickpressed`: Callback function triggered when a joystick button is pressed.
- [ ] `love.joystickreleased`: Callback function triggered when a joystick button is released.
- [ ] `love.gamepadaxis`: Called when a Joystick's virtual gamepad axis is moved.
- [ ] `love.gamepadpressed`: Called when a Joystick's virtual gamepad button is pressed.
- [ ] `love.gamepadreleased`: Called when a Joystick's virtual gamepad button is released.
- [ ] `love.joystickadded`: Called when a Joystick is connected.
- [ ] `love.joystickaxis`: Called when a joystick axis moves.
- [ ] `love.joystickhat`: Called when a joystick hat direction changes.
- [ ] `love.joystickremoved`: Called when a Joystick is disconnected.

## Version 0.3.0

### Modules

- [ ] `love.audio`: Provides an audio interface for playback/recording sound.
- [ ] `love.event`: Manages events, like keypresses.
- [ ] `love.sound`: This module is responsible for decoding sound files.
- [ ] `love.system`: Provides access to information about the user's system.

## Version 0.4.0

### Project

- [ ] Aseprite support

### Modules

- [ ] `love.font`: Allows you to work with fonts.

### Callbacks - General

- [ ] `love.quit`: Callback function triggered when the game is closed.

### Callbacks - Window

- [ ] `love.focus`: Callback function triggered when window receives or loses focus.

## Version 0.5.0

### Modules

- [ ] `love.math`: Provides system-independent mathematical functions.
- [ ] Tiled support

### Callbacks - General

- [ ] `love.thread`: Allows you to work with threads.
- [ ] `love.threaderror`: Callback function triggered when a Thread encounters an error.

### Callbacks - Window

- [ ] `love.mousefocus`: Callback function triggered when window receives or loses mouse focus.
- [ ] `love.resize`: Called when the window is resized.
- [ ] `love.visible`: Callback function triggered when window is shown or hidden.

### Callbacks - Keyboard

- [ ] `love.textinput`: Called when text has been entered by the user.

## Version 0.6.0

### Functions

- [ ] `love.getVersion`: Gets the current running version of LÖVE.

### Third-party modules

- [ ] `utf8`: Provides basic support for manipulating UTF-8 strings.

### Callbacks - Mouse

- [ ] `love.mousemoved`: Callback function triggered when the mouse is moved.

## Version 0.7.0

### Modules

- [ ] `love.video`: This module is responsible for decoding and streaming video files.

### Functions

- [ ] `love.isVersionCompatible`: Gets whether the given version is compatible with the current running version of LÖVE.

### Callbacks - General

- [ ] `love.lowmemory`: Callback function triggered when the system is running out of memory on mobile devices.

### Callbacks - Window

- [ ] `love.directorydropped`: Callback function triggered when a directory is dragged and dropped onto the window.

- [ ] `love.filedropped`: Callback function triggered when a file is dragged and dropped onto the window.

### Callbacks - Keyboard

- [ ] `love.textedited`: Called when the candidate text for an IME has changed.

### Callbacks - Mouse

- [ ] `love.wheelmoved`: Callback function triggered when the mouse wheel is moved.

## Version 0.8

### Modules

- [ ] `love.data`: Provides functionality for creating and transforming data.

### Functions

- [ ] `love.hasDeprecationOutput`: Gets whether LÖVE displays warnings when using deprecated functionality.
- [ ] `love.setDeprecationOutput`: Sets whether LÖVE displays warnings when using deprecated functionality.

## Version Horizon (Future)
Mostly related to mobile and touchscreen.

### Modules

- [ ] `love.touch`: Provides an interface to touch-screen presses.

### Callbacks - Window

- [ ] `love.displayrotated`: Called when the device display orientation changed.

### Callbacks - Touch

- [ ] `love.touchmoved`: Callback function triggered when a touch press moves inside the touch screen.
- [ ] `love.touchpressed`: Callback function triggered when the touch screen is touched.
- [ ] `love.touchreleased`: Callback function triggered when the touch screen stops being touched.

## Version Horizon (Far Future)
Networking implementation including rollback.



================================================
File: docs/love2d-api/modules/audio.md
================================================
# `love.audio` Module API Mapping

This document maps the functions available in the `love.audio` module of Love2D to their proposed equivalents in the Night Engine. This entire module is **Out of Scope** for the initial prototype.

| Love2D Function (`love.audio.`) | Night Engine API (`Night.Audio.`) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|---------------------------------|-----------------------------------|---------------------------|--------------------------|------|
| `love.audio.getActiveSourceCount()` | `Night.Audio.GetActiveSourceCount()` | `public static int GetActiveSourceCount()` | Out of Scope | [ ] |
| `love.audio.getDistanceModel()` | `Night.Audio.GetDistanceModel()`  | `public static Night.DistanceModel GetDistanceModel()` <br> `DistanceModel` enum. | Out of Scope | [ ] |
| `love.audio.getDopplerScale()`  | `Night.Audio.GetDopplerScale()`   | `public static double GetDopplerScale()` | Out of Scope | [ ] |
| `love.audio.getEffect(name)`    | `Night.Audio.GetEffect(string name)` | `public static Night.AudioEffect? GetEffect(string name)` <br> `AudioEffect` would be a base class for effects. | Out of Scope | [ ] |
| `love.audio.getOrientation()`   | `Night.Audio.GetListenerOrientation()` | `public static (float fx, float fy, float fz, float ux, float uy, float uz) GetListenerOrientation()` | Out of Scope | [ ] |
| `love.audio.getPosition()`      | `Night.Audio.GetListenerPosition()` | `public static (float x, float y, float z) GetListenerPosition()` | Out of Scope | [ ] |
| `love.audio.getRecordingDevices()` | `Night.Audio.GetRecordingDevices()` | `public static Night.RecordingDevice[] GetRecordingDevices()` | Out of Scope | [ ] |
| `love.audio.getSourceCount()`   | `Night.Audio.GetTotalSourceCount()` | `public static int GetTotalSourceCount()` | Out of Scope | [ ] |
| `love.audio.getVelocity()`      | `Night.Audio.GetListenerVelocity()` | `public static (float x, float y, float z) GetListenerVelocity()` | Out of Scope | [ ] |
| `love.audio.getVolume()`        | `Night.Audio.GetMasterVolume()`   | `public static float GetMasterVolume()` | Out of Scope | [ ] |
| `love.audio.isEffectsSupported()` | `Night.Audio.IsEffectsSupported()` | `public static bool IsEffectsSupported()` | Out of Scope | [ ] |
| `love.audio.newSource(filename, type)` or `love.audio.newSource(decoder, type)` | `Night.Audio.NewSource(string filePath, Night.SourceType type = Static)` or `Night.Audio.NewSource(Night.Decoder decoder, Night.SourceType type = Stream)` | `public static Night.Source NewSource(...)` <br> `SourceType` enum: `Static`, `Stream`. `Decoder` for custom audio formats. | Out of Scope | [ ] |
| `love.audio.pause(source)` or `love.audio.pause()` | `Night.Audio.Pause(Night.Source? source = null)` | `public static void Pause(Night.Source? source = null)` <br> Pauses specific source or all. | Out of Scope | [ ] |
| `love.audio.play(source)`       | `Night.Audio.Play(Night.Source source)` | `public static void Play(Night.Source source)` | Out of Scope | [ ] |
| `love.audio.resume(source)` or `love.audio.resume()` | `Night.Audio.Resume(Night.Source? source = null)` | `public static void Resume(Night.Source? source = null)` | Out of Scope | [ ] |
| `love.audio.setDistanceModel(model)` | `Night.Audio.SetDistanceModel(Night.DistanceModel model)` | `public static void SetDistanceModel(Night.DistanceModel model)` | Out of Scope | [ ] |
| `love.audio.setDopplerScale(scale)` | `Night.Audio.SetDopplerScale(double scale)` | `public static void SetDopplerScale(double scale)` | Out of Scope | [ ] |
| `love.audio.setEffect(name, settings)` | `Night.Audio.SetEffect(string name, Night.AudioEffectSettings settings)` | `public static bool SetEffect(string name, Night.AudioEffectSettings settings)` | Out of Scope | [ ] |
| `love.audio.setMixWithSystem(mix)` | `Night.Audio.SetMixWithSystem(bool mix)` | `public static void SetMixWithSystem(bool mix)` | Out of Scope | [ ] |
| `love.audio.setOrientation(fx, fy, fz, ux, uy, uz)` | `Night.Audio.SetListenerOrientation(...)` | `public static void SetListenerOrientation(float forwardX, ...)` | Out of Scope | [ ] |
| `love.audio.setPosition(x, y, z)` | `Night.Audio.SetListenerPosition(float x, float y, float z)` | `public static void SetListenerPosition(float x, float y, float z)` | Out of Scope | [ ] |
| `love.audio.setRecordingDevice(name)` | `Night.Audio.SetRecordingDevice(string name)` | `public static void SetRecordingDevice(string name)` | Out of Scope | [ ] |
| `love.audio.setVelocity(x, y, z)` | `Night.Audio.SetListenerVelocity(float x, float y, float z)` | `public static void SetListenerVelocity(float x, float y, float z)` | Out of Scope | [ ] |
| `love.audio.setVolume(volume)`  | `Night.Audio.SetMasterVolume(float volume)` | `public static void SetMasterVolume(float volume)` | Out of Scope | [ ] |
| `love.audio.stop(source)` or `love.audio.stop()` | `Night.Audio.Stop(Night.Source? source = null)` | `public static void Stop(Night.Source? source = null)` | Out of Scope | [ ] |

**Night Engine Specific Types:**
*   `Night.Source`: Represents an audio source (sound effect or music). Would have methods like `Play()`, `Pause()`, `Stop()`, `SetVolume()`, `Seek()`, `IsPlaying()`, etc.
*   `Night.SourceType`: Enum (`Static`, `Stream`).
*   `Night.Decoder`: Represents a custom audio decoder.
*   `Night.DistanceModel`: Enum for 3D audio distance attenuation (e.g., `None`, `Inverse`, `Linear`).
*   `Night.AudioEffect`: Base class for audio effects (e.g., reverb, echo).
*   `Night.AudioEffectSettings`: Base class for effect-specific settings.
*   `Night.RecordingDevice`: Represents an audio recording device.



================================================
File: docs/love2d-api/modules/data.md
================================================
# `love.data` Module API Mapping

This document maps the functions available in the `love.data` module of Love2D to their proposed equivalents in the Night Engine. This entire module is **Out of Scope** for the initial prototype. .NET provides extensive built-in support for these operations in namespaces like `System.IO.Compression`, `System.Security.Cryptography`, and `System.Text`.

| Love2D Function (`love.data.`) | Night Engine API (`Night.Data` or `System` namespaces) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|--------------------------------|--------------------------------------------------------|---------------------------|--------------------------|------|
| `love.data.compress(container, format, rawstring, level)` | `Night.Data.Compress(Night.DataContainerType container, Night.CompressionFormat format, byte[] data, int? level = null)` | `public static byte[] Compress(...)` <br> Uses `System.IO.Compression`. | Out of Scope | [ ] |
| `love.data.decompress(container, format, compressedstring)` | `Night.Data.Decompress(Night.DataContainerType container, Night.CompressionFormat format, byte[] compressedData)` | `public static byte[] Decompress(...)` | Out of Scope | [ ] |
| `love.data.decode(container, format, encodedstring)` | `Night.Data.Decode(Night.DataContainerType container, Night.EncodingFormat format, string encodedString)` | `public static byte[] Decode(...)` <br> e.g., Base64, Hex. Uses `System.Convert`. | Out of Scope | [ ] |
| `love.data.encode(container, format, rawstring, linelength)` | `Night.Data.Encode(Night.DataContainerType container, Night.EncodingFormat format, byte[] data, int? lineLength = null)` | `public static string Encode(...)` | Out of Scope | [ ] |
| `love.data.getPackedSize(format)` | `Night.Data.GetPackedSize(string packFormat)` | `public static int GetPackedSize(string packFormat)` <br> For binary packing. | Out of Scope | [ ] |
| `love.data.hash(hashfunction, string_or_Data)` | `Night.Data.Hash(Night.HashFunction function, byte[] data)` or `Night.Data.Hash(Night.HashFunction function, string data)` | `public static string Hash(...)` <br> Uses `System.Security.Cryptography`. | Out of Scope | [ ] |
| `love.data.newDataView(data, offset, size)` | `Night.Data.NewDataView(byte[] data, int offset = 0, int? size = null)` | `public static Night.DataView NewDataView(...)` <br> Similar to `System.Memory<byte>` or `ArraySegment<byte>`. | Out of Scope | [ ] |
| `love.data.pack(format, values...)` | `Night.Data.Pack(string packFormat, params object[] values)` | `public static byte[] Pack(...)` <br> Binary packing. | Out of Scope | [ ] |
| `love.data.unpack(format, datastring)` | `Night.Data.Unpack(string packFormat, byte[] packedData)` | `public static object[] Unpack(...)` | Out of Scope | [ ] |

**Night Engine Specific Types (if module were implemented):**
*   `Night.DataContainerType`: Enum (e.g., `String`, `Data`). (Love2D distinction, less relevant for C# byte arrays).
*   `Night.CompressionFormat`: Enum (e.g., `Gzip`, `Zlib`, `Lz4`).
*   `Night.EncodingFormat`: Enum (e.g., `Base64`, `Hex`).
*   `Night.HashFunction`: Enum (e.g., `Md5`, `Sha1`, `Sha256`).
*   `Night.DataView`: Wrapper for a segment of byte array, similar to `System.Memory<byte>`.



================================================
File: docs/love2d-api/modules/event.md
================================================
# `love.event` Module API Mapping

This document maps the functions available in the `love.event` module of Love2D to their proposed equivalents in the Night Engine. In Night Engine, event handling is primarily managed by the engine invoking specific callback methods on the user's game class (e.g., `MyGame.KeyPressed`). Direct manipulation of an event queue by the user is **Out of Scope** for the initial prototype.

| Love2D Function (`love.event.`) | Night Engine API (`Night.Event` or Engine Internals) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|---------------------------------|------------------------------------------------------|---------------------------|--------------------------|------|
| `love.event.clear()`            | `Night.Event.ClearQueue()` (Engine internal or not exposed) | `internal static void ClearQueue()` <br> Clears pending events. Engine might do this per frame. | Out of Scope | [ ] |
| `love.event.poll()`             | `Night.Event.Poll()` (Engine internal) | `internal static Night.EventData? Poll()` <br> Returns next event if any. Engine uses this in its loop. | Out of Scope | [ ] |
| `love.event.pump()`             | `Night.Event.PumpEvents()` (Engine internal) | `internal static void PumpEvents()` <br> Processes OS events into LÖVE events. Engine does this. | Out of Scope | [ ] |
| `love.event.push(e, ...)`       | `Night.Event.PushCustomEvent(string eventName, params object[] args)` | `public static void PushCustomEvent(string eventName, params object[] args)` <br> Allows user to push custom events. Would require a `MyGame.CustomEvent(name, args)` callback. | Out of Scope | [ ] |
| `love.event.quit(exitstatus)`   | `Night.Engine.RequestQuit(int exitStatus = 0)` | `public static void RequestQuit(int exitStatus = 0)` <br> Pushes a quit event. | In Scope (as `Night.Engine.RequestQuit`) | [ ] |
| `love.event.wait()`             | `Night.Event.Wait()` (Engine internal or not exposed) | `internal static Night.EventData Wait()` <br> Waits for next event. Not typical for game loops. | Out of Scope | [ ] |

**Night Engine Specific Types (if module were implemented for custom events):**
*   `Night.EventData`: A base class or struct for event information, potentially with derived types for specific events if not handled by direct callbacks.
*   Custom event callbacks in `MyGame` like `MyGame.OnCustomEvent(string name, object[] args)`.



================================================
File: docs/love2d-api/modules/filesystem.md
================================================
# `love.filesystem` Module API Mapping

This document maps the functions available in the `love.filesystem` module of Love2D to their proposed equivalents in the Night Engine. Most functions in this module are **Out of Scope** for the initial prototype.

| Love2D Function (`love.filesystem.`) | Night Engine API (`Night.Filesystem.`) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|--------------------------------------|----------------------------------------|---------------------------|--------------------------|------|
| `love.filesystem.append(name, data, size)` | `Night.Filesystem.Append(string path, byte[] data, int? size = null)` or `Night.Filesystem.AppendText(string path, string content)` | `public static bool Append(string path, byte[] data, int? size = null)` <br> `public static bool AppendText(string path, string content)` | Out of Scope | [ ] |
| `love.filesystem.areSymlinksEnabled()` | `Night.Filesystem.AreSymlinksEnabled()` | `public static bool AreSymlinksEnabled()` | Out of Scope | [ ] |
| `love.filesystem.createDirectory(name)` | `Night.Filesystem.CreateDirectory(string path)` | `public static bool CreateDirectory(string path)` | Out of Scope | [ ] |
| `love.filesystem.getAppdataDirectory()` | `Night.Filesystem.GetAppDataDirectory()` | `public static string GetAppDataDirectory()` | Out of Scope | [ ] |
| `love.filesystem.getDirectoryItems(name)` | `Night.Filesystem.GetDirectoryItems(string path)` | `public static string[] GetDirectoryItems(string path)` | Out of Scope | [ ] |
| `love.filesystem.getExecutablePath()` | `Night.Filesystem.GetExecutablePath()` | `public static string GetExecutablePath()` | Out of Scope | [ ] |
| `love.filesystem.getIdentity()`     | `Night.Filesystem.GetIdentity()`   | `public static string GetIdentity()` <br> Gets the save directory identity. | Out of Scope | [ ] |
| `love.filesystem.getLastModified(name)` | `Night.Filesystem.GetInfo(string path).ModTime` | `public static DateTime GetLastModifiedTime(string path)` (or long timestamp) | Superseded by GetInfo | [x] |
| `love.filesystem.getRealDirectory(name)` | `Night.Filesystem.GetRealDirectory(string path)` | `public static string GetRealDirectory(string path)` <br> Resolves symlinks. | Out of Scope | [ ] |
| `love.filesystem.getSaveDirectory()` | `Night.Filesystem.GetSaveDirectory()` | `public static string GetSaveDirectory()` | Out of Scope | [ ] |
| `love.filesystem.getSize(name)`     | `Night.Filesystem.GetInfo(string path).Size` | `public static long GetFileSize(string path)` | Superseded by GetInfo | [x] |
| `love.filesystem.getSource()`       | `Night.Filesystem.GetSourcePath()` | `public static string GetSourcePath()` <br> Path to the game's source (.love file or directory). | Out of Scope | [ ] |
| `love.filesystem.getSourceBaseDirectory()` | `Night.Filesystem.GetSourceBaseDirectory()` | `public static string GetSourceBaseDirectory()` | Out of Scope | [ ] |
| `love.filesystem.getUserDirectory()` | `Night.Filesystem.GetUserDirectory()` | `public static string GetUserDirectory()` | Out of Scope | [ ] |
| `love.filesystem.getWorkingDirectory()` | `Night.Filesystem.GetWorkingDirectory()` | `public static string GetWorkingDirectory()` | Out of Scope | [ ] |
| `love.filesystem.isFused()`         | `Night.Filesystem.IsFused()`       | `public static bool IsFused()` <br> True if game is a .love file and merged with interpreter. | Out of Scope | [ ] |
| `love.filesystem.isDirectory(name)` | `Night.Filesystem.GetInfo(string path).Type == Night.FileType.Directory` | `public static bool IsDirectory(string path)` | Superseded by GetInfo | [x] |
| `love.filesystem.isFile(name)`      | `Night.Filesystem.GetInfo(string path).Type == Night.FileType.File` | `public static bool IsFile(string path)` | Superseded by GetInfo | [x] |
| `love.filesystem.isSymlink(name)`   | `Night.Filesystem.GetInfo(string path).Type == Night.FileType.Symlink` | `public static bool IsSymlink(string path)` | Superseded by GetInfo | [x] |
| `love.filesystem.lines(name)`       | `Night.Filesystem.ReadLines(string path)` | `public static IEnumerable<string> ReadLines(string path)` | Out of Scope | [ ] |
| `love.filesystem.load(name)`        | `Night.Filesystem.LoadLuaScript(string path)` | `public static Action LoadLuaScript(string path)` <br> Loads and runs a Lua file. Night Engine might not support this directly. | Out of Scope | [ ] |
| `love.filesystem.mount(archive, mountpoint, appendToPath)` | `Night.Filesystem.Mount(string archivePath, string mountPoint, bool appendToSearchPath = false)` | `public static bool Mount(...)` | Out of Scope | [ ] |
| `love.filesystem.newFile(filename, mode)` | `Night.Filesystem.NewFileStream(string path, Night.FileMode mode = Read)` | `public static Night.FileStream NewFileStream(...)` <br> `FileMode` enum: `Read`, `Write`, `Append`. `FileStream` would be a custom stream wrapper. | Out of Scope | [ ] |
| `love.filesystem.newFileData(contents, name, decoder)` | `Night.Filesystem.NewFileData(byte[] content, string name, Night.FileDecoder decoder = Raw)` | `public static Night.FileData NewFileData(...)` <br> `FileDecoder` enum: `Raw`, `Base64`. `FileData` is an in-memory file. | Out of Scope | [ ] |
| `love.filesystem.read(name, size)`  | `Night.Filesystem.ReadBytes(string path, int? count = null)` or `Night.Filesystem.ReadText(string path)` | `public static byte[]? ReadBytes(string path, int? count = null)` <br> `public static string? ReadText(string path)` | Out of Scope | [ ] |
| `love.filesystem.remove(name)`      | `Night.Filesystem.Remove(string path)` | `public static bool Remove(string path)` <br> Removes file or empty directory. | Out of Scope | [ ] |
| `love.filesystem.setIdentity(name, appendToPath)` | `Night.Filesystem.SetIdentity(string identity, bool appendToPath = false)` | `public static void SetIdentity(...)` | Out of Scope | [ ] |
| `love.filesystem.setSymlinksEnabled(enable)` | `Night.Filesystem.SetSymlinksEnabled(bool enable)` | `public static void SetSymlinksEnabled(bool enable)` | Out of Scope | [ ] |
| `love.filesystem.setSource(path)`   | `Night.Filesystem.SetSource(string path)` | `public static void SetSource(string path)` | Out of Scope | [ ] |
| `love.filesystem.unmount(archive)`  | `Night.Filesystem.Unmount(string archivePath)` | `public static bool Unmount(string archivePath)` | Out of Scope | [ ] |
| `love.filesystem.write(name, data, size)` | `Night.Filesystem.WriteBytes(string path, byte[] data, int? size = null)` or `Night.Filesystem.WriteText(string path, string content)` | `public static bool WriteBytes(...)` <br> `public static bool WriteText(...)` | Out of Scope | [ ] |

| `love.filesystem.getInfo(path, filtertype, info)` | `Night.Filesystem.GetInfo(string path, Night.FileType? filterType = null, Night.FileSystemInfo? existingInfo = null)` | `public static Night.FileSystemInfo? GetInfo(string path, Night.FileType? filterType = null)` <br> `public static Night.FileSystemInfo? GetInfo(string path, Night.FileSystemInfo info)` <br> `public static Night.FileSystemInfo? GetInfo(string path, Night.FileType filterType, Night.FileSystemInfo info)` | In Scope | [x] |

**Night Engine Specific Types:**
*   `Night.FileMode`: Enum (`Read`, `Write`, `Append`).
*   `Night.FileStream`: Custom stream wrapper for file operations.
*   `Night.FileData`: Represents an in-memory file.
*   `Night.FileDecoder`: Enum (`Raw`, `Base64`).
*   `Night.FileType`: Enum (`File`, `Directory`, `Symlink`, `Other`, `None`).
*   `Night.FileSystemInfo`: Class (Properties: `Type`, `Size`, `ModTime`).



================================================
File: docs/love2d-api/modules/font.md
================================================
# `love.font` Module API Mapping

This document maps the functions available in the `love.font` module of Love2D to their proposed equivalents in the Night Engine. This entire module is **Out of Scope** for the initial prototype. The primary way to get a font object in Night Engine would be `Night.Graphics.NewFont()`.

| Love2D Function (`love.font.`) | Night Engine API (`Night.Font` methods or `Night.Graphics`) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|--------------------------------|-------------------------------------------------------------|---------------------------|--------------------------|------|
| `love.font.newRasterizer(filename, size)` or `love.font.newRasterizer(filedata, size)` or `love.font.newRasterizer(size)` | `Night.Graphics.NewFontRasterizer(string filePath, int size)` etc. | `public static Night.FontRasterizer NewFontRasterizer(...)` <br> Creates a font rasterizer. `Night.Font` would likely encapsulate this. | Out of Scope | [ ] |
| `love.font.newGlyphData(rasterizer, glyph)` | `(Night.FontRasterizer).NewGlyphData(char glyph)` or `(Night.FontRasterizer).NewGlyphData(uint glyph)` | `public Night.GlyphData NewGlyphData(char glyph)` (method on `FontRasterizer` or `Font`) | Out of Scope | [ ] |

**Related functionality in Night Engine (on `Night.Font` objects):**
*   Getting font height: `myFont.GetHeight()`
*   Getting ascent/descent: `myFont.GetAscent()`, `myFont.GetDescent()`
*   Getting baseline: `myFont.GetBaseline()`
*   Getting line height: `myFont.GetLineHeight()`
*   Getting text width: `myFont.GetWidth(string text)`
*   Wrapping text: `myFont.Wrap(string text, float wrapLimit)`
*   Setting fallback fonts: `myFont.SetFallback(Night.Font fallback1, ...)`

**Night Engine Specific Types:**
*   `Night.Font`: Represents a loaded font. Created via `Night.Graphics.NewFont()`. Would have methods for metrics and properties.
*   `Night.FontRasterizer`: Internal or advanced type for rasterizing glyphs.
*   `Night.GlyphData`: Represents rasterized data for a single glyph.



================================================
File: docs/love2d-api/modules/graphics.md
================================================
# `love.graphics` Module API Mapping

This document maps the functions available in the `love.graphics` module of Love2D to their proposed equivalents in the Night Engine.

| Love2D Function (`love.graphics.`) | Night Engine API (`Night.Graphics.`) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|------------------------------------|--------------------------------------|---------------------------|--------------------------|------|
| `love.graphics.arc(mode, arcType, x, y, radius, angle1, angle2, segments)` | `Night.Graphics.DrawArc(Night.DrawMode mode, Night.ArcType arcType, float x, float y, float radius, float angle1, float angle2, int? segments = null)` | `public static void DrawArc(Night.DrawMode mode, Night.ArcType arcType, float x, float y, float radius, float angle1, float angle2, int? segments = null)` <br> `DrawMode` enum: `Fill`, `Line`. `ArcType` enum: `Open`, `Closed`, `Pie`. Segments auto-calculated if null. | Out of Scope | [ ] |
| `love.graphics.circle(mode, x, y, radius, segments)` | `Night.Graphics.DrawCircle(Night.DrawMode mode, float x, float y, float radius, int? segments = null)` | `public static void DrawCircle(Night.DrawMode mode, float x, float y, float radius, int? segments = null)` | Out of Scope | [ ] |
| `love.graphics.clear(r, g, b, a)` or `love.graphics.clear(color)` | `Night.Graphics.Clear(Night.Color color)` or `Night.Graphics.Clear(byte r, byte g, byte b, byte a = 255)` | `public static void Clear(Night.Color color)` <br> `public static void Clear(byte r, byte g, byte b, byte a = 255)` | In Scope | [ ] |
| `love.graphics.discard(discardColor, discardStencil)` | `Night.Graphics.Discard(bool discardColor = true, bool discardStencil = true)` | `public static void Discard(bool discardColor = true, bool discardStencil = true)` <br> Discards render target contents. | Out of Scope | [ ] |
| `love.graphics.draw(drawable, x, y, r, sx, sy, ox, oy, kx, ky)` | `Night.Graphics.Draw(Night.IDrawable drawable, float x, float y, float rotation = 0, float scaleX = 1, float scaleY = 1, float offsetX = 0, float offsetY = 0, float shearX = 0, float shearY = 0)` | `public static void Draw(Night.IDrawable drawable, float x, float y, float rotation = 0, float scaleX = 1, float scaleY = 1, float offsetX = 0, float offsetY = 0, float shearX = 0, float shearY = 0)` <br> `IDrawable` could be `Sprite`, `Text`, `Shape`, etc. | In Scope (for Sprites) | [ ] |
| `love.graphics.draw(texture, quad, x, y, r, sx, sy, ox, oy, kx, ky)` | `Night.Graphics.Draw(Night.Texture texture, Night.Quad quad, float x, float y, float rotation = 0, float scaleX = 1, float scaleY = 1, float offsetX = 0, float offsetY = 0, float shearX = 0, float shearY = 0)` | `public static void Draw(Night.Texture texture, Night.Quad quad, ...)` <br> For drawing parts of a texture. | In Scope (for Sprites with Quads) | [ ] |
| `love.graphics.ellipse(mode, x, y, radiusx, radiusy, segments)` | `Night.Graphics.DrawEllipse(Night.DrawMode mode, float x, float y, float radiusX, float radiusY, int? segments = null)` | `public static void DrawEllipse(Night.DrawMode mode, float x, float y, float radiusX, float radiusY, int? segments = null)` | Out of Scope | [ ] |
| `love.graphics.getBackgroundColor()` | `Night.Graphics.GetBackgroundColor()` | `public static Night.Color GetBackgroundColor()` | In Scope | [ ] |
| `love.graphics.getBlendMode()`     | `Night.Graphics.GetBlendMode()`    | `public static (Night.BlendMode mode, Night.BlendAlphaMode alphaMode) GetBlendMode()` | Out of Scope | [ ] |
| `love.graphics.getCanvas()`        | `Night.Graphics.GetRenderTarget()` | `public static Night.IRenderTarget GetRenderTarget()` <br> Returns current render target (Canvas or screen). | Out of Scope | [ ] |
| `love.graphics.getCanvasFormats()` | `Night.Graphics.GetSupportedRenderTargetFormats()` | `public static Night.RenderTargetFormat[] GetSupportedRenderTargetFormats()` | Out of Scope | [ ] |
| `love.graphics.getColor()`         | `Night.Graphics.GetColor()`        | `public static Night.Color GetColor()` | In Scope | [ ] |
| `love.graphics.getColorMask()`     | `Night.Graphics.GetColorMask()`    | `public static (bool r, bool g, bool b, bool a) GetColorMask()` | Out of Scope | [ ] |
| `love.graphics.getDefaultFilter()` | `Night.Graphics.GetDefaultFilter()` | `public static Night.FilterMode GetDefaultFilter()` <br> `FilterMode` enum: `Linear`, `Nearest`. | In Scope | [ ] |
| `love.graphics.getDepthMode()`     | `Night.Graphics.GetDepthMode()`    | `public static (Night.CompareMode? mode, bool write) GetDepthMode()` | Out of Scope | [ ] |
| `love.graphics.getDimensions()`    | `Night.Graphics.GetDimensions()`   | `public static (int width, int height) GetDimensions()` <br> Gets dimensions of current render target (screen or canvas). | In Scope | [ ] |
| `love.graphics.getFont()`          | `Night.Graphics.GetFont()`         | `public static Night.Font GetFont()` | Out of Scope | [ ] |
| `love.graphics.getHeight()`        | `Night.Graphics.GetHeight()`       | `public static int GetHeight()` <br> Height of current render target. | In Scope | [ ] |
| `love.graphics.getLineWidth()`     | `Night.Graphics.GetLineWidth()`    | `public static float GetLineWidth()` | Out of Scope | [ ] |
| `love.graphics.getLineStyle()`     | `Night.Graphics.GetLineStyle()`    | `public static Night.LineStyle GetLineStyle()` <br> `LineStyle` enum: `Smooth`, `Rough`. | Out of Scope | [ ] |
| `love.graphics.getLineJoin()`      | `Night.Graphics.GetLineJoin()`     | `public static Night.LineJoin GetLineJoin()` <br> `LineJoin` enum: `None`, `Miter`, `Bevel`. | Out of Scope | [ ] |
| `love.graphics.getPointSize()`     | `Night.Graphics.GetPointSize()`    | `public static float GetPointSize()` | Out of Scope | [ ] |
| `love.graphics.getRendererInfo()`  | `Night.Graphics.GetRendererInfo()` | `public static Night.RendererInfo GetRendererInfo()` <br> `RendererInfo` class: `Name`, `Version`, `Vendor`, `Device`. | In Scope | [ ] |
| `love.graphics.getScissor()`       | `Night.Graphics.GetScissor()`      | `public static Night.Rectangle? GetScissor()` | Out of Scope | [ ] |
| `love.graphics.getShader()`        | `Night.Graphics.GetShader()`       | `public static Night.Shader GetShader()` | Out of Scope | [ ] |
| `love.graphics.getStats()`         | `Night.Graphics.GetStats()`        | `public static Night.GraphicsStats GetStats()` <br> `GraphicsStats` class: `DrawCalls`, `CanvasSwitches`, `ShaderSwitches`, etc. | In Scope (Basic stats) | [ ] |
| `love.graphics.getStencilTest()`   | `Night.Graphics.GetStencilTest()`  | `public static (Night.CompareMode? mode, int value) GetStencilTest()` | Out of Scope | [ ] |
| `love.graphics.getWidth()`         | `Night.Graphics.GetWidth()`        | `public static int GetWidth()` <br> Width of current render target. | In Scope | [ ] |
| `love.graphics.intersectScissor(x, y, width, height)` | `Night.Graphics.IntersectScissor(int x, int y, int width, int height)` | `public static void IntersectScissor(int x, int y, int width, int height)` | Out of Scope | [ ] |
| `love.graphics.isWireframe()`      | `Night.Graphics.IsWireframe()`     | `public static bool IsWireframe()` | Out of Scope | [ ] |
| `love.graphics.line(x1, y1, x2, y2, ...)` or `love.graphics.line(points)` | `Night.Graphics.DrawLine(params float[] points)` or `Night.Graphics.DrawLine(Night.PointF[] points)` | `public static void DrawLine(params float[] points)` <br> `public static void DrawLine(Night.PointF[] points)` | Out of Scope | [ ] |
| `love.graphics.newCanvas(width, height, format, msaa)` | `Night.Graphics.NewRenderTarget(int width, int height, Night.RenderTargetFormat format = Default, int msaa = 0)` | `public static Night.IRenderTarget NewRenderTarget(...)` | Out of Scope | [ ] |
| `love.graphics.newFont(filename, size)` or `love.graphics.newFont(size)` | `Night.Graphics.NewFont(string filePath, int size)` or `Night.Graphics.NewFont(int size)` | `public static Night.Font NewFont(...)` <br> Uses default font if no path. | Out of Scope | [ ] |
| `love.graphics.newImage(filename)` | `Night.Graphics.NewImage(string filePath)` | `public static Night.Sprite NewImage(string filePath)` <br> PRD refers to `Sprite` as return type. | In Scope | [ ] |
| `love.graphics.newImageFont(filename, glyphs, extraspacing)` | `Night.Graphics.NewImageFont(string filePath, string glyphs, int extraSpacing = 0)` | `public static Night.Font NewImageFont(...)` | Out of Scope | [ ] |
| `love.graphics.newQuad(x, y, width, height, sw, sh)` | `Night.Graphics.NewQuad(float x, float y, float width, float height, float sourceWidth, float sourceHeight)` | `public static Night.Quad NewQuad(...)` | In Scope | [ ] |
| `love.graphics.newShader(pixelcode, vertexcode)` | `Night.Graphics.NewShader(string pixelShaderCode, string vertexShaderCode = null)` | `public static Night.Shader NewShader(...)` | Out of Scope | [ ] |
| `love.graphics.newSpriteBatch(texture, size, usagehint)` | `Night.Graphics.NewSpriteBatch(Night.Texture texture, int size, Night.UsageHint hint = Dynamic)` | `public static Night.SpriteBatch NewSpriteBatch(...)` | Out of Scope | [ ] |
| `love.graphics.newText(font, textparts)` | `Night.Graphics.NewText(Night.Font font, params (string text, Night.Color? color)[] textParts)` | `public static Night.Text NewText(...)` | Out of Scope | [ ] |
| `love.graphics.newVideo(filename, options)` | `Night.Graphics.NewVideo(string filePath, Night.VideoOptions? options = null)` | `public static Night.Video NewVideo(...)` | Out of Scope | [ ] |
| `love.graphics.origin()`           | `Night.Graphics.ResetTransform()`  | `public static void ResetTransform()` <br> Resets current transformation to identity. | In Scope | [ ] |
| `love.graphics.points(coords, colors)` | `Night.Graphics.DrawPoints(Night.PointF[] positions, Night.Color[]? colors = null)` | `public static void DrawPoints(...)` | Out of Scope | [ ] |
| `love.graphics.polygon(mode, vertices)` | `Night.Graphics.DrawPolygon(Night.DrawMode mode, params Night.PointF[] vertices)` | `public static void DrawPolygon(...)` | Out of Scope | [ ] |
| `love.graphics.pop()`              | `Night.Graphics.PopTransform()`    | `public static void PopTransform()` | In Scope | [ ] |
| `love.graphics.present()`          | `Night.Graphics.Present()`         | `public static void Present()` <br> Called by engine after `MyGame.Draw()`. | In Scope | [ ] |
| `love.graphics.print(text, x, y, r, sx, sy, ox, oy, kx, ky)` | `Night.Graphics.Print(string text, float x, float y, float rotation = 0, ...)` | `public static void Print(string text, float x, float y, ...)` <br> Uses current font. | Out of Scope | [ ] |
| `love.graphics.printf(text, x, y, limit, align, r, sx, sy, ox, oy, kx, ky)` | `Night.Graphics.PrintF(string text, float x, float y, float wrapLimit, Night.TextAlign align = Left, ...)` | `public static void PrintF(...)` | Out of Scope | [ ] |
| `love.graphics.push(stacktype)`    | `Night.Graphics.PushTransform(Night.StackType type = All)` | `public static void PushTransform(Night.StackType type = Night.StackType.All)` <br> `StackType` enum: `All`, `Transform`. | In Scope | [ ] |
| `love.graphics.rectangle(mode, x, y, width, height, rx, ry, segments)` | `Night.Graphics.DrawRectangle(Night.DrawMode mode, float x, float y, float width, float height, float cornerRadiusX = 0, float cornerRadiusY = 0, int? segments = null)` | `public static void DrawRectangle(...)` | Out of Scope | [ ] |
| `love.graphics.reset()`            | `Night.Graphics.ResetState()`      | `public static void ResetState()` <br> Resets all graphics state (color, blend mode, etc.) | In Scope | [ ] |
| `love.graphics.rotate(angle)`      | `Night.Graphics.Rotate(float angleInRadians)` | `public static void Rotate(float angleInRadians)` | In Scope | [ ] |
| `love.graphics.scale(sx, sy)`      | `Night.Graphics.Scale(float scaleX, float scaleY)` | `public static void Scale(float scaleX, float scaleY)` | In Scope | [ ] |
| `love.graphics.shear(kx, ky)`      | `Night.Graphics.Shear(float shearX, float shearY)` | `public static void Shear(float shearX, float shearY)` | In Scope | [ ] |
| `love.graphics.setBackgroundColor(r, g, b, a)` or `love.graphics.setBackgroundColor(color)` | `Night.Graphics.SetBackgroundColor(Night.Color color)` or `Night.Graphics.SetBackgroundColor(byte r, byte g, byte b, byte a = 255)` | `public static void SetBackgroundColor(...)` | In Scope | [ ] |
| `love.graphics.setBlendMode(mode, alphamode)` | `Night.Graphics.SetBlendMode(Night.BlendMode mode, Night.BlendAlphaMode alphaMode = Multiply)` | `public static void SetBlendMode(...)` | Out of Scope | [ ] |
| `love.graphics.setCanvas(canvas)` or `love.graphics.setCanvas()` | `Night.Graphics.SetRenderTarget(Night.IRenderTarget? target = null)` | `public static void SetRenderTarget(Night.IRenderTarget? target = null)` <br> `null` sets to screen. | Out of Scope | [ ] |
| `love.graphics.setColor(r, g, b, a)` or `love.graphics.setColor(color)` | `Night.Graphics.SetColor(Night.Color color)` or `Night.Graphics.SetColor(byte r, byte g, byte b, byte a = 255)` | `public static void SetColor(...)` | In Scope | [ ] |
| `love.graphics.setColorMask(r, g, b, a)` | `Night.Graphics.SetColorMask(bool r, bool g, bool b, bool a)` | `public static void SetColorMask(bool r, bool g, bool b, bool a)` | Out of Scope | [ ] |
| `love.graphics.setDefaultFilter(min, mag, anisotropy)` | `Night.Graphics.SetDefaultFilter(Night.FilterMode min, Night.FilterMode? mag = null, float anisotropy = 1.0f)` | `public static void SetDefaultFilter(...)` <br> `mag` defaults to `min` if null. | In Scope | [ ] |
| `love.graphics.setDepthMode(mode, write)` | `Night.Graphics.SetDepthMode(Night.CompareMode? mode, bool write)` | `public static void SetDepthMode(Night.CompareMode? mode, bool write)` | Out of Scope | [ ] |
| `love.graphics.setFont(font)`      | `Night.Graphics.SetFont(Night.Font font)` | `public static void SetFont(Night.Font font)` | Out of Scope | [ ] |
| `love.graphics.setLineWidth(width)` | `Night.Graphics.SetLineWidth(float width)` | `public static void SetLineWidth(float width)` | Out of Scope | [ ] |
| `love.graphics.setLineStyle(style)` | `Night.Graphics.SetLineStyle(Night.LineStyle style)` | `public static void SetLineStyle(Night.LineStyle style)` | Out of Scope | [ ] |
| `love.graphics.setLineJoin(join)`  | `Night.Graphics.SetLineJoin(Night.LineJoin join)` | `public static void SetLineJoin(Night.LineJoin join)` | Out of Scope | [ ] |
| `love.graphics.setPointSize(size)` | `Night.Graphics.SetPointSize(float size)` | `public static void SetPointSize(float size)` | Out of Scope | [ ] |
| `love.graphics.setScissor(x, y, width, height)` or `love.graphics.setScissor()` | `Night.Graphics.SetScissor(int? x, int? y, int? width, int? height)` or `Night.Graphics.SetScissor(Night.Rectangle? rect)` | `public static void SetScissor(Night.Rectangle? rect)` <br> `null` disables scissor. | Out of Scope | [ ] |
| `love.graphics.setShader(shader)` or `love.graphics.setShader()` | `Night.Graphics.SetShader(Night.Shader? shader = null)` | `public static void SetShader(Night.Shader? shader = null)` | Out of Scope | [ ] |
| `love.graphics.setStencilTest(comparemode, comparevalue)` or `love.graphics.setStencilTest()` | `Night.Graphics.SetStencilTest(Night.CompareMode? mode = null, int value = 0)` | `public static void SetStencilTest(Night.CompareMode? mode = null, int value = 0)` | Out of Scope | [ ] |
| `love.graphics.setWireframe(enable)` | `Night.Graphics.SetWireframe(bool enable)` | `public static void SetWireframe(bool enable)` | Out of Scope | [ ] |
| `love.graphics.stencil(stencilfunction, action, value, keepvalues)` | `Night.Graphics.Stencil(Action stencilFunction, Night.StencilAction action = Replace, int value = 1, bool keepValues = false)` | `public static void Stencil(...)` <br> Complex. | Out of Scope | [ ] |
| `love.graphics.translate(dx, dy)`  | `Night.Graphics.Translate(float deltaX, float deltaY)` | `public static void Translate(float deltaX, float deltaY)` | In Scope | [ ] |
| `love.graphics.transformPoint(worldX, worldY)` | `Night.Graphics.TransformPoint(float worldX, float worldY)` | `public static (float screenX, float screenY) TransformPoint(float worldX, float worldY)` | In Scope | [ ] |
| `love.graphics.inverseTransformPoint(screenX, screenY)` | `Night.Graphics.InverseTransformPoint(float screenX, float screenY)` | `public static (float worldX, float worldY) InverseTransformPoint(float screenX, float screenY)` | In Scope | [ ] |

**Night Engine Specific Types:**
*   `Night.DrawMode`: Enum (`Fill`, `Line`).
*   `Night.ArcType`: Enum (`Open`, `Closed`, `Pie`).
*   `Night.IDrawable`: Interface for drawable objects (Sprite, Text, etc.).
*   `Night.Texture`: Represents a texture (likely part of `Night.Image` or `Night.Sprite`).
*   `Night.Quad`: Represents a portion of a texture.
*   `Night.Color`: Struct/class for color (RGBA).
*   `Night.BlendMode`: Enum for blending (e.g., `Alpha`, `Add`, `Subtract`, `Multiply`).
*   `Night.BlendAlphaMode`: Enum for alpha blending (e.g., `Multiply`, `PreMultiplied`).
*   `Night.IRenderTarget`: Interface for render targets (Canvas or screen).
*   `Night.RenderTargetFormat`: Enum for pixel formats of render targets.
*   `Night.FilterMode`: Enum (`Linear`, `Nearest`).
*   `Night.CompareMode`: Enum for depth/stencil tests (e.g., `Less`, `Equal`, `Greater`, `Always`).
*   `Night.Font`: Represents a font.
*   `Night.LineStyle`: Enum (`Smooth`, `Rough`).
*   `Night.LineJoin`: Enum (`None`, `Miter`, `Bevel`).
*   `Night.RendererInfo`: Class with properties like `Name`, `Version`, `Vendor`, `Device`.
*   `Night.Rectangle`: Struct/class for a rectangle (X, Y, Width, Height).
*   `Night.Shader`: Represents a shader program.
*   `Night.GraphicsStats`: Class for graphics statistics.
*   `Night.PointF`: Struct for a 2D point with float coordinates.
*   `Night.Sprite`: Represents an image that can be drawn. (Corresponds to Love2D Image)
*   `Night.SpriteBatch`: For optimized drawing of many sprites from the same texture.
*   `Night.Text`: Represents renderable text.
*   `Night.Video`: Represents a video that can be drawn.
*   `Night.VideoOptions`: Options for video loading.
*   `Night.StackType`: Enum (`All`, `Transform`).
*   `Night.TextAlign`: Enum (`Left`, `Center`, `Right`, `Justify`).
*   `Night.StencilAction`: Enum for stencil operations (e.g., `Keep`, `Replace`, `Increment`).
*   `Night.UsageHint`: Enum for SpriteBatch (`Static`, `Dynamic`, `Stream`).



================================================
File: docs/love2d-api/modules/image.md
================================================
# `love.image` Module API Mapping

This document maps the functions available in the `love.image` module of Love2D to their proposed equivalents in the Night Engine. The functionality of this module is often integrated into `Night.Sprite` or `Night.Texture` objects, or handled during image loading. Most direct `love.image` functions are **Out of Scope** for the initial prototype as standalone static methods.

| Love2D Function (`love.image.`) | Night Engine API (`Night.Image` or `Texture`/`Sprite` methods) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|---------------------------------|----------------------------------------------------------------|---------------------------|--------------------------|------|
| `love.image.newImageData(width, height, format, data)` | `Night.Image.NewImageData(int width, int height, Night.PixelFormat format = RGBA8, byte[]? data = null)` | `public static Night.ImageData NewImageData(...)` <br> Creates raw image data. `Night.ImageData` would be a class/struct. | Out of Scope | [ ] |
| `love.image.isCompressed(filename)` or `love.image.isCompressed(filedata)` | `Night.Image.IsCompressed(string filePath)` or `Night.Image.IsCompressed(Night.FileData fileData)` | `public static bool IsCompressed(...)` <br> Checks if an image file is a compressed format LÖVE can load. | Out of Scope | [ ] |
| `love.image.newCompressedData(filename)` | `Night.Image.NewCompressedData(string filePath)` | `public static Night.CompressedImageData NewCompressedData(string filePath)` <br> Loads a compressed image file (e.g. DDS, KTX) into a special data object. | Out of Scope | [ ] |

**Related functionality in Night Engine (on `Sprite` or `Texture` or `ImageData` objects):**
*   Getting dimensions: `mySprite.GetWidth()`, `mySprite.GetHeight()`
*   Getting format: `myImageData.GetFormat()`
*   Manipulating pixel data: `myImageData.GetPixel(x,y)`, `myImageData.SetPixel(x,y,color)` (Likely Out of Scope for prototype)
*   Encoding/Decoding: Functionality to save an `ImageData` to a file (e.g., `myImageData.Encode("png", "filename.png")`) is Out of Scope.

**Night Engine Specific Types:**
*   `Night.ImageData`: Represents raw, uncompressed image data. Could have methods like `GetWidth()`, `GetHeight()`, `GetPixel()`, `SetPixel()`.
*   `Night.PixelFormat`: Enum for pixel formats (e.g., `RGBA8`, `RGB8`, `Luminance8`).
*   `Night.FileData`: Represents file data in memory (from `Night.Filesystem`).
*   `Night.CompressedImageData`: Represents compressed image data.
*   `Night.Sprite`: The primary object for loaded images, returned by `Night.Graphics.NewImage()`. It would internally manage texture data.



================================================
File: docs/love2d-api/modules/joystick.md
================================================
# `love.joystick` Module API Mapping

This document maps the functions available in the `love.joystick` module of Love2D to their proposed equivalents in the Night Engine. This entire module is **Out of Scope** for the initial prototype. Joystick event callbacks are noted in the `love` module mapping.

| Love2D Function (`love.joystick.`) | Night Engine API (`Night.Joystick` or `Joystick` instance methods) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|------------------------------------|--------------------------------------------------------------------|---------------------------|--------------------------|------|
| `love.joystick.getJoysticks()`     | `Night.Joystick.GetJoysticks()`    | `public static Night.Joystick[] GetJoysticks()` <br> Returns all connected joysticks. | Out of Scope | [ ] |
| `love.joystick.getJoystickCount()` | `Night.Joystick.GetJoystickCount()` | `public static int GetJoystickCount()` | Out of Scope | [ ] |
| `love.joystick.loadGamepadMappings(filename)` or `love.joystick.loadGamepadMappings(string)` | `Night.Joystick.LoadGamepadMappings(string pathOrString)` | `public static bool LoadGamepadMappings(string pathOrString)` | Out of Scope | [ ] |
| `love.joystick.saveGamepadMappings(joystick)` | `(Night.Joystick).SaveGamepadMappings()` | `public string SaveGamepadMappings()` (Method on `Joystick` instance) | Out of Scope | [ ] |
| `love.joystick.setGamepadMapping(guid, buttonOrAxis, inputtype, inputindex, hatdirection)` | `Night.Joystick.SetGamepadMapping(string guid, ...)` | Complex mapping function. | Out of Scope | [ ] |

**Functionality on `Night.Joystick` instances (if implemented):**
*   `joystick.isConnected()`
*   `joystick.getName()`
*   `joystick.getID()` (instance ID)
*   `joystick.getGUID()`
*   `joystick.getAxisCount()`
*   `joystick.getButtonCount()`
*   `joystick.getHatCount()`
*   `joystick.getAxis(axisindex)`
*   `joystick.getAxes()`
*   `joystick.isDown(buttonindex, ...)`
*   `joystick.getHat(hatindex)`
*   `joystick.isGamepad()`
*   `joystick.getGamepadAxis(axis)`
*   `joystick.isGamepadDown(button)`
*   `joystick.setVibration(left, right, duration)`
*   `joystick.hasVibration()`

**Night Engine Specific Types:**
*   `Night.Joystick`: Represents a joystick/gamepad device.
*   `Night.GamepadAxis`: Enum for standard gamepad axes (e.g., `LeftX`, `LeftY`, `RightX`, `RightY`, `TriggerLeft`, `TriggerRight`).
*   `Night.GamepadButton`: Enum for standard gamepad buttons (e.g., `A`, `B`, `X`, `Y`, `Start`, `Select`, `DPadUp`).
*   `Night.HatDirection`: Enum for hat switch directions (e.g., `Centered`, `Up`, `Down`, `Left`, `Right`, `UpLeft`).



================================================
File: docs/love2d-api/modules/keyboard.md
================================================
# `love.keyboard` Module API Mapping

This document maps the functions available in the `love.keyboard` module of Love2D to their proposed equivalents in the Night Engine.

| Love2D Function (`love.keyboard.`) | Night Engine API (`Night.Keyboard.`) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|------------------------------------|--------------------------------------|---------------------------|--------------------------|------|
| `love.keyboard.isDown(key)`        | `Night.Keyboard.IsDown(Night.KeyCode key)` | `public static bool IsDown(Night.KeyCode key)` <br> Checks if specific keys are held down. `Night.KeyCode` enum will map to SDL scancodes. | In Scope | [ ] |
| `love.keyboard.isScancodeDown(scancode)` | `Night.Keyboard.IsScancodeDown(Night.Scancode scancode)` | `public static bool IsScancodeDown(Night.Scancode scancode)` <br> `Night.Scancode` would be an enum closely matching SDL scancodes. May be internal or less used if `KeyCode` is preferred. | In Scope (Lower priority than `IsDown`) | [ ] |
| `love.keyboard.getKeyFromScancode(scancode)` | `Night.Keyboard.GetKeyFromScancode(Night.Scancode scancode)` | `public static Night.KeyCode GetKeyFromScancode(Night.Scancode scancode)` | In Scope (Helper for input mapping) | [ ] |
| `love.keyboard.getScancodeFromKey(key)` | `Night.Keyboard.GetScancodeFromKey(Night.KeyCode key)` | `public static Night.Scancode GetScancodeFromKey(Night.KeyCode key)` | In Scope (Helper for input mapping) | [ ] |
| `love.keyboard.setKeyRepeat(enable)` | `Night.Keyboard.SetKeyRepeatEnabled(bool enabled)` | `public static void SetKeyRepeatEnabled(bool enabled)` <br> Enables or disables key repeat for `love.keypressed`. SDL handles this by default; this might control if `isRepeat` is true in `MyGame.KeyPressed`. | In Scope (Verify SDL behavior) | [ ] |
| `love.keyboard.hasKeyRepeat()`     | `Night.Keyboard.HasKeyRepeat()`    | `public static bool HasKeyRepeat()` <br> Checks if key repeat is enabled. | In Scope (Verify SDL behavior) | [ ] |
| `love.keyboard.setTextInput(enable, x, y, w, h)` | `Night.Keyboard.SetTextInputRect(bool enable, Night.Rectangle? rect = null)` | `public static void SetTextInputRect(bool enable, Night.Rectangle? rect = null)` <br> For on-screen keyboards on touch devices. `rect` defines text input area. | Out of Scope | [ ] |
| `love.keyboard.hasScreenKeyboard()` | `Night.Keyboard.HasScreenKeyboard()` | `public static bool HasScreenKeyboard()` | Out of Scope | [ ] |

**Night Engine Specific Types:**
*   `Night.KeyCode`: Enum representing keyboard keys (e.g., `A`, `Space`, `Return`). This will be mapped to SDL scancodes.
*   `Night.Scancode`: Enum representing platform-independent physical key codes (e.g., `SDL_SCANCODE_A`).
*   `Night.Rectangle`: Struct/class for a rectangle (X, Y, Width, Height).



================================================
File: docs/love2d-api/modules/love.md
================================================
# `love` Module API Mapping

This document maps the functions available in the base `love` module of Love2D to their proposed equivalents in the Night Engine.

| Love2D Function (`love.`) | Night Engine API (`Night.`) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|---------------------------|-----------------------------|---------------------------|--------------------------|------|
| `love.getVersion()`       | `Night.Engine.GetVersion()` | `public static string GetVersion()` <br> Returns a string like "Major.Minor.Revision Codename". | In Scope | [ ] |
| `love.setDeprecationOutput(boolean enabled)` | `Night.Engine.SetDeprecationOutput(bool enabled)` | `public static void SetDeprecationOutput(bool enabled)` <br> Controls whether Love2D's deprecation warnings are output. May or may not be relevant for Night. | Out of Scope (Low Priority) | [ ] |
| `love.run()`              | `Night.Engine.Run<T>()` or `Night.Engine.Run(IGame gameInstance)` | `public static void Run<T>() where T : IGame, new()` <br> `public static void Run(IGame gameInstance)` <br> This is the main entry point that starts the game loop. The user provides a game class/instance. | In Scope | [x] |
| `love.load(arg)`          | `MyGame.Load(string[] args)` | Implemented by the user in their game class: `void Load(string[] args);` <br> Called once at the beginning. `arg` in Love2D contains command-line arguments. | In Scope | [x] |
| `love.update(dt)`         | `MyGame.Update(double deltaTime)` | Implemented by the user: `void Update(double deltaTime);` <br> Called every frame. | In Scope | [x] |
| `love.draw()`             | `MyGame.Draw()`             | Implemented by the user: `void Draw();` <br> Called every frame after update. | In Scope | [x] |
| `love.quit()`             | `MyGame.Quit()` or `Night.Engine.Quit()` | User implementation: `bool Quit();` (return true to allow quit) <br> Engine initiated: `Night.Engine.RequestQuit()` or similar. Love2D `love.quit` can also be an event. | In Scope (Basic window close event handling) | [ ] |
| `love.focus(f)`           | `MyGame.FocusChanged(bool hasFocus)` | User implementation: `void FocusChanged(bool hasFocus);` | In Scope | [ ] |
| `love.mousefocus(f)`      | `MyGame.MouseFocusChanged(bool hasFocus)` | User implementation: `void MouseFocusChanged(bool hasFocus);` | Out of Scope (Covered by general focus) | [ ] |
| `love.visible(v)`         | `MyGame.VisibilityChanged(bool isVisible)` | User implementation: `void VisibilityChanged(bool isVisible);` | In Scope | [ ] |
| `love.keypressed(key, scancode, isrepeat)` | `MyGame.KeyPressed(Night.KeyCode key, string scancode, bool isRepeat)` | User implementation: `void KeyPressed(Night.KeyCode key, /* SDL_Scancode scancode, */ bool isRepeat);` <br> `scancode` might be abstracted away or be an internal SDL detail. | In Scope | [ ] |
| `love.keyreleased(key, scancode)` | `MyGame.KeyReleased(Night.KeyCode key, string scancode)` | User implementation: `void KeyReleased(Night.KeyCode key /*, SDL_Scancode scancode */);` | In Scope | [ ] |
| `love.textinput(text)`    | `MyGame.TextInput(string text)` | User implementation: `void TextInput(string text);` | In Scope (but low priority for prototype) | [ ] |
| `love.mousepressed(x, y, button, istouch, presses)` | `MyGame.MousePressed(int x, int y, Night.MouseButton button, bool isTouch, int presses)` | User implementation: `void MousePressed(int x, int y, Night.MouseButton button, int presses);` <br> `isTouch` might be handled separately if touch events are distinct. | In Scope | [ ] |
| `love.mousereleased(x, y, button, istouch)` | `MyGame.MouseReleased(int x, int y, Night.MouseButton button, bool isTouch)` | User implementation: `void MouseReleased(int x, int y, Night.MouseButton button);` | In Scope | [ ] |
| `love.mousemoved(x, y, dx, dy, istouch)` | `MyGame.MouseMoved(int x, int y, int deltaX, int deltaY, bool isTouch)` | User implementation: `void MouseMoved(int x, int y, int deltaX, int deltaY);` | In Scope | [ ] |
| `love.wheelmoved(x, y)`   | `MyGame.MouseWheelMoved(int deltaX, int deltaY)` | User implementation: `void MouseWheelMoved(int deltaX, int deltaY);` | In Scope (Basic support) | [ ] |
| `love.joystickpressed(joystick, button)` | `MyGame.JoystickPressed(Night.Joystick joystick, int button)` | User implementation: `void JoystickPressed(Night.Joystick joystick, int button);` | Out of Scope | [ ] |
| `love.joystickreleased(joystick, button)` | `MyGame.JoystickReleased(Night.Joystick joystick, int button)` | User implementation: `void JoystickReleased(Night.Joystick joystick, int button);` | Out of Scope | [ ] |
| `love.joystickaxis(joystick, axis, value)` | `MyGame.JoystickAxisMoved(Night.Joystick joystick, int axis, float value)` | User implementation: `void JoystickAxisMoved(Night.Joystick joystick, int axis, float value);` | Out of Scope | [ ] |
| `love.joystickhat(joystick, hat, direction)` | `MyGame.JoystickHatMoved(Night.Joystick joystick, int hat, Night.HatDirection direction)` | User implementation: `void JoystickHatMoved(Night.Joystick joystick, int hat, Night.HatDirection direction);` | Out of Scope | [ ] |
| `love.joystickadded(joystick)` | `MyGame.JoystickAdded(Night.Joystick joystick)` | User implementation: `void JoystickAdded(Night.Joystick joystick);` | Out of Scope | [ ] |
| `love.joystickremoved(joystick)` | `MyGame.JoystickRemoved(Night.Joystick joystick)` | User implementation: `void JoystickRemoved(Night.Joystick joystick);` | Out of Scope | [ ] |
| `love.touchpressed(id, x, y, dx, dy, pressure)` | `MyGame.TouchPressed(long id, float x, float y, float deltaX, float deltaY, float pressure)` | User implementation: `void TouchPressed(long id, float x, float y, float deltaX, float deltaY, float pressure);` | Out of Scope | [ ] |
| `love.touchreleased(id, x, y, dx, dy, pressure)` | `MyGame.TouchReleased(long id, float x, float y, float deltaX, float deltaY, float pressure)` | User implementation: `void TouchReleased(long id, float x, float y, float deltaX, float deltaY, float pressure);` | Out of Scope | [ ] |
| `love.touchmoved(id, x, y, dx, dy, pressure)` | `MyGame.TouchMoved(long id, float x, float y, float deltaX, float deltaY, float pressure)` | User implementation: `void TouchMoved(long id, float x, float y, float deltaX, float deltaY, float pressure);` | Out of Scope | [ ] |
| `love.lowmemory()`        | `MyGame.LowMemory()`        | User implementation: `void LowMemory();` | Out of Scope | [ ] |
| `love.threaderror(thread, errorstr)` | `MyGame.ThreadError(Night.Thread thread, string error)` | User implementation: `void ThreadError(Night.Thread thread, string error);` | Out of Scope | [ ] |
| `love.directorydropped(path)` | `MyGame.DirectoryDropped(string path)` | User implementation: `void DirectoryDropped(string path);` | Out of Scope | [ ] |
| `love.filedropped(file)`  | `MyGame.FileDropped(Night.File file)` | User implementation: `void FileDropped(Night.File file);` <br> `Night.File` would be a wrapper for file data. | Out of Scope | [ ] |
| `love.resize(w, h)`       | `MyGame.WindowResized(int width, int height)` | User implementation: `void WindowResized(int width, int height);` | In Scope | [ ] |

*Note: Many `love` module functions are event callbacks. In Night Engine, these will be methods the user implements in their game class, which are then called by `Night.Engine`.*



================================================
File: docs/love2d-api/modules/math.md
================================================
# `love.math` Module API Mapping

This document maps the functions available in the `love.math` module of Love2D to their proposed equivalents in the Night Engine. Most of this functionality can be achieved using `System.Math` and `System.Random` in C#. A dedicated `Night.Math` module is **Out of Scope** for the initial prototype, but specific advanced functions might be added later.

| Love2D Function (`love.math.`) | Night Engine API (`Night.Math` or `System`) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|--------------------------------|---------------------------------------------|---------------------------|--------------------------|------|
| `love.math.triangulate(polygon)` | `Night.Math.Triangulate(Night.PointF[] polygon)` | `public static int[] Triangulate(Night.PointF[] polygon)` <br> Returns indices for triangles. | Out of Scope | [ ] |
| `love.math.isConvex(polygon)`  | `Night.Math.IsConvex(Night.PointF[] polygon)` | `public static bool IsConvex(Night.PointF[] polygon)` | Out of Scope | [ ] |
| `love.math.getAngle(x1, y1, x2, y2)` | `Night.Math.GetAngle(float x1, float y1, float x2, float y2)` | `public static double GetAngle(float x1, float y1, float x2, float y2)` <br> Similar to `Math.Atan2(y2 - y1, x2 - x1)`. | Out of Scope (Use `System.Math`) | [ ] |
| `love.math.noise(x, y, z, w)`  | `Night.Math.Noise(double x, double? y = null, double? z = null, double? w = null)` | `public static double Noise(...)` <br> Simplex noise. | Out of Scope | [ ] |
| `love.math.random()`             | `(new System.Random()).NextDouble()` or `Night.Math.Random()` | `public static double Random()` <br> Returns [0, 1). | Out of Scope (Use `System.Random`) | [ ] |
| `love.math.random(max)`          | `(new System.Random()).Next(max + 1)` or `Night.Math.Random(int max)` | `public static int Random(int max)` <br> Returns [0, max]. Or `Next(1, max + 1)` for [1, max]. Love2D is [1,max] for integer. | Out of Scope (Use `System.Random`) | [ ] |
| `love.math.random(min, max)`     | `(new System.Random()).Next(min, max + 1)` or `Night.Math.Random(int min, int max)` | `public static int Random(int min, int max)` <br> Returns [min, max]. | Out of Scope (Use `System.Random`) | [ ] |
| `love.math.randomNormal(stddev, mean)` | `Night.Math.RandomNormal(double stdDev = 1.0, double mean = 0.0)` | `public static double RandomNormal(...)` <br> Normally distributed random number. | Out of Scope | [ ] |
| `love.math.setRandomSeed(seed)`  | `Night.Math.SetRandomSeed(int seed)` or `new System.Random(seed)` | `public static void SetRandomSeed(int seed)` <br> For a global `Night.Math` random generator. | Out of Scope (Use `System.Random` instance) | [ ] |
| `love.math.getRandomSeed()`      | `Night.Math.GetRandomSeed()`      | `public static (int seed, int? highSeed) GetRandomSeed()` | Out of Scope | [ ] |
| `love.math.getRandomState()`     | `Night.Math.GetRandomState()`     | `public static string GetRandomState()` | Out of Scope | [ ] |
| `love.math.setRandomState(state)`| `Night.Math.SetRandomState(string state)` | `public static void SetRandomState(string state)` | Out of Scope | [ ] |
| `love.math.newBezierCurve(points)` | `Night.Math.NewBezierCurve(Night.PointF[] controlPoints)` | `public static Night.BezierCurve NewBezierCurve(...)` | Out of Scope | [ ] |
| `love.math.newRandomGenerator()` | `Night.Math.NewRandomGenerator()` | `public static System.Random NewRandomGenerator()` or a custom `Night.RandomGenerator` class. | Out of Scope | [ ] |
| `love.math.gammaToLinear(c)`     | `Night.Math.GammaToLinear(double colorComponent)` | `public static double GammaToLinear(double colorComponent)` | Out of Scope | [ ] |
| `love.math.linearToGamma(c)`     | `Night.Math.LinearToGamma(double colorComponent)` | `public static double LinearToGamma(double colorComponent)` | Out of Scope | [ ] |

**Night Engine Specific Types (if module were implemented):**
*   `Night.PointF`: Struct for a 2D point with float coordinates.
*   `Night.BezierCurve`: Class representing a Bezier curve, with methods like `Evaluate(t)`, `GetDerivative(t)`.
*   `Night.RandomGenerator`: A class that might encapsulate `System.Random` or a custom PRNG, potentially with Love2D-compatible state management.



================================================
File: docs/love2d-api/modules/mouse.md
================================================
# `love.mouse` Module API Mapping

This document maps the functions available in the `love.mouse` module of Love2D to their proposed equivalents in the Night Engine.

| Love2D Function (`love.mouse.`) | Night Engine API (`Night.Mouse.`) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|---------------------------------|-----------------------------------|---------------------------|--------------------------|------|
| `love.mouse.getX()`             | `Night.Mouse.GetX()`              | `public static int GetX()` | In Scope | [ ] |
| `love.mouse.getY()`             | `Night.Mouse.GetY()`              | `public static int GetY()` | In Scope | [ ] |
| `love.mouse.getPosition()`      | `Night.Mouse.GetPosition()`       | `public static (int x, int y) GetPosition()` | In Scope | [ ] |
| `love.mouse.isDown(button)`     | `Night.Mouse.IsDown(Night.MouseButton button)` | `public static bool IsDown(Night.MouseButton button)` <br> `Night.MouseButton` enum: `Left`, `Right`, `Middle`, `X1`, `X2`, etc. | In Scope | [ ] |
| `love.mouse.isVisible()`        | `Night.Mouse.IsVisible()`         | `public static bool IsVisible()` | In Scope | [ ] |
| `love.mouse.setX(x)`            | `Night.Mouse.SetX(int x)`         | `public static void SetX(int x)` <br> Warps mouse cursor. | In Scope (Low priority) | [ ] |
| `love.mouse.setY(y)`            | `Night.Mouse.SetY(int y)`         | `public static void SetY(int y)` <br> Warps mouse cursor. | In Scope (Low priority) | [ ] |
| `love.mouse.setPosition(x,y)`   | `Night.Mouse.SetPosition(int x, int y)` | `public static void SetPosition(int x, int y)` <br> Warps mouse cursor. | In Scope (Low priority) | [ ] |
| `love.mouse.setVisible(visible)`| `Night.Mouse.SetVisible(bool visible)` | `public static void SetVisible(bool visible)` | In Scope | [ ] |
| `love.mouse.setGrabbed(grab)`   | `Night.Mouse.SetGrabbed(bool grabbed)` | `public static void SetGrabbed(bool grabbed)` <br> Confines cursor to window. | In Scope (Low priority) | [ ] |
| `love.mouse.isGrabbed()`        | `Night.Mouse.IsGrabbed()`         | `public static bool IsGrabbed()` | In Scope (Low priority) | [ ] |
| `love.mouse.getRelativeMode()`  | `Night.Mouse.GetRelativeMode()`   | `public static bool GetRelativeMode()` | In Scope (Low priority, for FPS-style input) | [ ] |
| `love.mouse.setRelativeMode(enable)` | `Night.Mouse.SetRelativeMode(bool enable)` | `public static void SetRelativeMode(bool enable)` | In Scope (Low priority) | [ ] |
| `love.mouse.getCursor()`        | `Night.Mouse.GetCursor()`         | `public static Night.Cursor GetCursor()` <br> `Night.Cursor` would be a custom cursor object. | Out of Scope | [ ] |
| `love.mouse.setCursor(cursor)`  | `Night.Mouse.SetCursor(Night.Cursor? cursor = null)` | `public static void SetCursor(Night.Cursor? cursor = null)` <br> `null` for default system cursor. | Out of Scope | [ ] |
| `love.mouse.newCursor(imagedata, hotx, hoty)` | `Night.Mouse.NewCursor(Night.ImageData imageData, int hotSpotX, int hotSpotY)` | `public static Night.Cursor NewCursor(...)` | Out of Scope | [ ] |
| `love.mouse.getSystemCursor(ctype)` | `Night.Mouse.GetSystemCursor(Night.SystemCursorType type)` | `public static Night.Cursor GetSystemCursor(Night.SystemCursorType type)` <br> `SystemCursorType` enum: `Arrow`, `IBeam`, `Crosshair`, etc. | Out of Scope | [ ] |

**Night Engine Specific Types:**
*   `Night.MouseButton`: Enum representing mouse buttons (e.g., `Left`, `Right`, `Middle`, `X1`, `X2`).
*   `Night.Cursor`: Represents a mouse cursor (custom or system).
*   `Night.ImageData`: Wrapper for image data, likely from `Night.Image` module.
*   `Night.SystemCursorType`: Enum for standard system cursors.



================================================
File: docs/love2d-api/modules/sound.md
================================================
# `love.sound` Module API Mapping

This document maps the functions available in the `love.sound` module of Love2D to their proposed equivalents in the Night Engine. This module is primarily for decoding sound data, which would be handled internally by `Night.Audio.NewSource` or `Night.Source` objects if the audio module were implemented. This entire module is **Out of Scope** for the initial prototype.

| Love2D Function (`love.sound.`) | Night Engine API (`Night.Sound` or `Night.Audio` internals) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|---------------------------------|-------------------------------------------------------------|---------------------------|--------------------------|------|
| `love.sound.newDecoder(filedata, bufferSize)` | `Night.Audio.NewDecoder(Night.FileData fileData, int bufferSize = 4096)` | `public static Night.Decoder NewDecoder(...)` <br> Creates a sound decoder. | Out of Scope | [ ] |
| `love.sound.newSoundData(samples, sampleRate, bitDepth, channels)` | `Night.Audio.NewSoundData(int samples, int sampleRate, int bitDepth, int channels)` or `Night.Audio.NewSoundData(byte[] rawPcmData, ...)` | `public static Night.SoundData NewSoundData(...)` <br> Creates raw sound data. | Out of Scope | [ ] |

**Functionality on `Night.Decoder` instances (if implemented):**
*   `decoder.GetBitDepth()`
*   `decoder.GetChannelCount()`
*   `decoder.GetDuration()`
*   `decoder.GetSampleRate()`
*   `decoder.Decode()` (returns a chunk of SoundData)
*   `decoder.Seek(offset)`

**Functionality on `Night.SoundData` instances (if implemented):**
*   `soundData.GetBitDepth()`
*   `soundData.GetChannelCount()`
*   `soundData.GetDuration()`
*   `soundData.GetSampleCount()`
*   `soundData.GetSampleRate()`
*   `soundData.GetSample(index)`
*   `soundData.SetSample(index, value)`
*   `soundData.Clone()`

**Night Engine Specific Types (if module were implemented):**
*   `Night.Decoder`: Represents an object that can decode audio from a stream or file data.
*   `Night.SoundData`: Represents raw PCM audio data in memory.
*   `Night.FileData`: Represents file data in memory (from `Night.Filesystem`).



================================================
File: docs/love2d-api/modules/system.md
================================================
# `love.system` Module API Mapping

This document maps the functions available in the `love.system` module of Love2D to their proposed equivalents in the Night Engine. Most functions in this module are **Out of Scope** for the initial prototype. Standard .NET `System.Environment` or `System.Runtime.InteropServices.RuntimeInformation` can provide some of this.

| Love2D Function (`love.system.`) | Night Engine API (`Night.System` or `System` namespace) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|----------------------------------|---------------------------------------------------------|---------------------------|--------------------------|------|
| `love.system.getOS()`            | `Night.System.GetOSName()` or `System.Runtime.InteropServices.RuntimeInformation.OSDescription` | `public static string GetOSName()` | Out of Scope | [ ] |
| `love.system.getProcessorCount()`| `System.Environment.ProcessorCount` | `public static int GetProcessorCount()` (via `System.Environment`) | Out of Scope | [ ] |
| `love.system.getPowerInfo()`     | `Night.System.GetPowerInfo()`     | `public static Night.PowerInfo GetPowerInfo()` <br> `PowerInfo` class: `State` (enum), `SecondsLeft` (nullable int), `Percent` (nullable int). | Out of Scope | [ ] |
| `love.system.getClipboardText()` | `Night.System.GetClipboardText()` | `public static string GetClipboardText()` <br> Would need platform-specific implementation or a library. | Out of Scope | [ ] |
| `love.system.setClipboardText(text)` | `Night.System.SetClipboardText(string text)` | `public static void SetClipboardText(string text)` | Out of Scope | [ ] |
| `love.system.openURL(url)`       | `Night.System.OpenURL(string url)` or `System.Diagnostics.Process.Start()` | `public static bool OpenURL(string url)` <br> `Process.Start(new ProcessStartInfo(url) { UseShellExecute = true });` | Out of Scope | [ ] |
| `love.system.vibrate(seconds)`   | `Night.System.Vibrate(double seconds)` | `public static void Vibrate(double seconds)` <br> For mobile devices. | Out of Scope | [ ] |
| `love.system.getPreferredLocales()` | `Night.System.GetPreferredLocales()` | `public static string[] GetPreferredLocales()` <br> From `System.Globalization.CultureInfo.CurrentUICulture` etc. | Out of Scope | [ ] |

**Night Engine Specific Types (if module were implemented):**
*   `Night.PowerInfo`: Class/Struct with properties `State` (enum: `NoBattery`, `Charging`, `Charged`, `Draining`), `SecondsLeft` (nullable int), `Percent` (nullable int).



================================================
File: docs/love2d-api/modules/thread.md
================================================
# `love.thread` Module API Mapping

This document maps the functions available in the `love.thread` module of Love2D to their proposed equivalents in the Night Engine. This entire module is **Out of Scope** for the initial prototype, as .NET provides comprehensive threading capabilities via `System.Threading`.

| Love2D Function (`love.thread.`) | Night Engine API (`Night.Thread` or `System.Threading`) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|----------------------------------|---------------------------------------------------------|---------------------------|--------------------------|------|
| `love.thread.newThread(filename)` or `love.thread.newThread(codestring)` | `Night.Thread.NewThread(string luaScriptPathOrCode)` or `new System.Threading.Thread(...)` | `public static Night.Thread NewThread(string luaScriptPathOrCode)` <br> Love2D threads run Lua code. Night Engine would use C# delegates/lambdas with `System.Threading.Thread` or `Task`. | Out of Scope | [ ] |
| `love.thread.getChannel(name)`   | `Night.Thread.GetChannel<T>(string name)` | `public static Night.Channel<T> GetChannel<T>(string name)` <br> Channels are for inter-thread communication. | Out of Scope | [ ] |
| `love.thread.newChannel()`       | `Night.Thread.NewChannel<T>()`    | `public static Night.Channel<T> NewChannel<T>()` | Out of Scope | [ ] |

**Functionality on `Night.Thread` instances (if implemented, wrapping `System.Threading.Thread`):**
*   `thread.Start()`
*   `thread.Wait()`
*   `thread.IsRunning()`
*   `thread.GetError()`

**Functionality on `Night.Channel<T>` instances (if implemented, similar to `System.Threading.Channels.Channel<T>`):**
*   `channel.Push(T value)`
*   `channel.Pop()` (non-blocking, returns nullable T)
*   `channel.Demand()` (blocking, returns T)
*   `channel.Peek()`
*   `channel.GetCount()`
*   `channel.HasRead(id)`
*   `channel.Clear()`
*   `channel.PerformAtomic(Func<bool> operation)`

**Night Engine Specific Types (if module were implemented):**
*   `Night.Thread`: A wrapper around `System.Threading.Thread` or `Task`, potentially with easier error handling or specific Love2D-like behaviors if Lua interop were a goal.
*   `Night.Channel<T>`: A thread-safe communication channel, similar to `System.Threading.Channels.Channel<T>`.



================================================
File: docs/love2d-api/modules/timer.md
================================================
# `love.timer` Module API Mapping

This document maps the functions available in the `love.timer` module of Love2D to their proposed equivalents in the Night Engine. Most functions in this module are **Out of Scope** for the initial prototype.

| Love2D Function (`love.timer.`) | Night Engine API (`Night.Timer.`) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|---------------------------------|-----------------------------------|---------------------------|--------------------------|------|
| `love.timer.getDelta()`         | `Night.Timer.GetDelta()`      | `public static double GetDelta()` <br> Time since last frame. This is already provided to `MyGame.Update(deltaTime)`. This function would provide it on demand. | Out of Scope (Covered by `Update`'s `deltaTime`) | [ ] |
| `love.timer.getFPS()`           | `Night.Timer.GetFPS()`            | `public static int GetFPS()` <br> Current frames per second. | In Scope (Useful for debugging/display) | [ ] |
| `love.timer.getAverageDelta()`  | `Night.Timer.GetAverageDelta()` | `public static double GetAverageDeltaTime()` <br> Average delta time over the last second. | Out of Scope | [ ] |
| `love.timer.getTime()`          | `Night.Timer.GetTime()`           | `public static double GetTime()` <br> Time since the game started, in seconds. | In Scope (Useful utility) | [ ] |
| `love.timer.sleep(s)`           | `Night.Timer.Sleep(double seconds)` | `public static void Sleep(double seconds)` <br> Pauses execution. | Out of Scope (Generally not recommended in game loops) | [ ] |
| `love.timer.step()`             | `Night.Timer.Step()`              | `public static double Step()` <br> Measures time between calls. Used internally by Love2D's default `love.run`. Night Engine will have its own internal timing. | Out of Scope (Engine internal) | [ ] |



================================================
File: docs/love2d-api/modules/touch.md
================================================
# `love.touch` Module API Mapping

This document maps the functions available in the `love.touch` module of Love2D to their proposed equivalents in the Night Engine. This entire module is **Out of Scope** for the initial prototype. Touch event callbacks are noted in the `love` module mapping.

| Love2D Function (`love.touch.`) | Night Engine API (`Night.Touch.`) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|---------------------------------|-----------------------------------|---------------------------|--------------------------|------|
| `love.touch.getPosition(id)`    | `Night.Touch.GetPosition(long touchId)` | `public static (float x, float y) GetPosition(long touchId)` | Out of Scope | [ ] |
| `love.touch.getPressure(id)`    | `Night.Touch.GetPressure(long touchId)` | `public static float GetPressure(long touchId)` | Out of Scope | [ ] |
| `love.touch.getTouches()`       | `Night.Touch.GetActiveTouches()`  | `public static long[] GetActiveTouches()` <br> Returns IDs of currently active touches. | Out of Scope | [ ] |

**Night Engine Specific Types (if module were implemented):**
*   Touch events in `MyGame` would pass a `Night.TouchEventArgs` object containing `Id`, `X`, `Y`, `DeltaX`, `DeltaY`, `Pressure`.



================================================
File: docs/love2d-api/modules/video.md
================================================
# `love.video` Module API Mapping

This document maps the functions available in the `love.video` module of Love2D to their proposed equivalents in the Night Engine. This entire module is **Out of Scope** for the initial prototype. The primary way to get a video object in Night Engine would be `Night.Graphics.NewVideo()`.

| Love2D Function (`love.video.`) | Night Engine API (`Night.Video` methods or `Night.Graphics`) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|---------------------------------|--------------------------------------------------------------|---------------------------|--------------------------|------|
| `love.video.newVideoStream(filename)` | `Night.Graphics.NewVideo(string filePath, Night.VideoOptions? options = null)` | `public static Night.Video NewVideo(...)` <br> This is the main entry point. `VideoStream` in Love2D is just `Video`. | Out of Scope | [ ] |

**Functionality on `Night.Video` instances (if implemented):**
*   `video.Play()`
*   `video.Pause()`
*   `video.Seek(offset)`
*   `video.Tell()` (get current playback time)
*   `video.GetSource()` (audio source associated with video)
*   `video.IsPlaying()`
*   `video.SetSync(audioSource)`
*   `video.GetWidth()`, `video.GetHeight()` (as an `IDrawable`)
*   `video.GetFilename()`
*   `video.GetFilter()`
*   `video.SetFilter(min, mag)`

**Night Engine Specific Types (if module were implemented):**
*   `Night.Video`: Represents a video object. It would be an `IDrawable` and might internally manage a `Night.Source` for audio. Created via `Night.Graphics.NewVideo()`.
*   `Night.VideoOptions`: Class for video loading options (e.g., `EnableAudio`).
*   `Night.Source`: Audio source from `Night.Audio` module.
*   `Night.FilterMode`: Enum (`Linear`, `Nearest`).



================================================
File: docs/love2d-api/modules/window.md
================================================
# `love.window` Module API Mapping

This document maps the functions available in the `love.window` module of Love2D to their proposed equivalents in the Night Engine.

| Love2D Function (`love.window.`) | Night Engine API (`Night.Window.`) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|----------------------------------|------------------------------------|---------------------------|--------------------------|------|
| `love.window.close()`            | `Night.Window.Close()`             | `public static void Close()` <br> Requests to close the window. The `MyGame.Quit()` callback will be invoked. | In Scope | [x] |
| `love.window.displaySleepEnabled()` | `Night.Window.IsDisplaySleepEnabled()` | `public static bool IsDisplaySleepEnabled()` | Out of Scope | [ ] |
| `love.window.fromPixels(px_x, px_y)` | `Night.Window.FromPixels(double pixelX, double pixelY)` | `public static (double x, double y) FromPixels(double pixelX, double pixelY)` <br> Converts pixel coordinates to density-independent units. | In Scope (if high DPI is handled) | [ ] |
| `love.window.getDesktopDimensions(displayindex)` | `Night.Window.GetDesktopDimensions(int displayIndex = 0)` | `public static (int width, int height) GetDesktopDimensions(int displayIndex = 0)` | In Scope (for default display) | [ ] |
| `love.window.getDimensions()`      | `Night.Window.GetDimensions()`     | `public static (int width, int height) GetDimensions()` | In Scope | [ ] |
| `love.window.getDisplayCount()`    | `Night.Window.GetDisplayCount()`   | `public static int GetDisplayCount()` | In Scope (for default display awareness) | [ ] |
| `love.window.getDisplayName(displayindex)` | `Night.Window.GetDisplayName(int displayIndex = 0)` | `public static string GetDisplayName(int displayIndex = 0)` | Out of Scope | [ ] |
| `love.window.getFullscreen()`      | `Night.Window.IsFullscreen()`      | `public static bool IsFullscreen()` <br> Returns true if fullscreen. Also need `Night.Window.GetFullscreenMode()` for type. | In Scope | [ ] |
| `love.window.getFullscreenModes(displayindex)` | `Night.Window.GetFullscreenModes(int displayIndex = 0)` | `public static Night.FullscreenMode[] GetFullscreenModes(int displayIndex = 0)` <br> `FullscreenMode` struct/class: `int Width, int Height, int RefreshRate`. | In Scope (for setting fullscreen) | [ ] |
| `love.window.getIcon()`            | `Night.Window.GetIcon()`           | `public static Night.ImageData GetIcon()` <br> `Night.ImageData` would be a wrapper. | Out of Scope | [ ] |
| `love.window.getMode()`            | `Night.Window.GetMode()`           | `public static (int width, int height, Night.WindowFlags flags) GetMode()` <br> `WindowFlags` would be a struct/class. | In Scope | [ ] |
| `love.window.getPixelDimensions()` | `Night.Window.GetPixelDimensions()` | `public static (int pixelWidth, int pixelHeight) GetPixelDimensions()` | In Scope (if high DPI is handled) | [ ] |
| `love.window.getPixelScale()`      | `Night.Window.GetPixelScale()`     | `public static double GetPixelScale()` | In Scope (if high DPI is handled) | [ ] |
| `love.window.getPosition()`        | `Night.Window.GetPosition()`       | `public static (int x, int y, int displayIndex) GetPosition()` | In Scope | [ ] |
| `love.window.getTitle()`           | `Night.Window.GetTitle()`          | `public static string GetTitle()` | In Scope | [ ] |
| `love.window.hasFocus()`           | `Night.Window.HasFocus()`          | `public static bool HasFocus()` | In Scope | [ ] |
| `love.window.hasMouseFocus()`      | `Night.Window.HasMouseFocus()`     | `public static bool HasMouseFocus()` | In Scope | [ ] |
| `love.window.isMaximized()`        | `Night.Window.IsMaximized()`       | `public static bool IsMaximized()` | In Scope | [ ] |
| `love.window.isMinimized()`        | `Night.Window.IsMinimized()`       | `public static bool IsMinimized()` | In Scope | [ ] |
| `love.window.isOpen()`             | `Night.Window.IsOpen()`            | `public static bool IsOpen()` <br> Checks if the window is open and the game should continue running. | In Scope | [x] |
| `love.window.isVisible()`          | `Night.Window.IsVisible()`         | `public static bool IsVisible()` | In Scope | [ ] |
| `love.window.maximize()`           | `Night.Window.Maximize()`          | `public static void Maximize()` | In Scope | [ ] |
| `love.window.minimize()`           | `Night.Window.Minimize()`          | `public static void Minimize()` | In Scope | [ ] |
| `love.window.requestAttention(continuous)` | `Night.Window.RequestAttention(bool continuous = false)` | `public static void RequestAttention(bool continuous = false)` | Out of Scope | [ ] |
| `love.window.restore()`            | `Night.Window.Restore()`           | `public static void Restore()` <br> Restores after minimize/maximize. | In Scope | [ ] |
| `love.window.setDisplaySleepEnabled(enable)` | `Night.Window.SetDisplaySleepEnabled(bool enable)` | `public static void SetDisplaySleepEnabled(bool enable)` | Out of Scope | [ ] |
| `love.window.setFullscreen(fullscreen, fstype)` | `Night.Window.SetFullscreen(bool fullscreen, Night.FullscreenType type = Night.FullscreenType.Desktop)` | `public static bool SetFullscreen(bool fullscreen, Night.FullscreenType type = Night.FullscreenType.Desktop)` <br> `FullscreenType` enum: `Desktop`, `Exclusive`. Returns success. | In Scope | [ ] |
| `love.window.setIcon(imagedata)`   | `Night.Window.SetIcon(Night.ImageData iconData)` | `public static bool SetIcon(Night.ImageData iconData)` | Out of Scope | [ ] |
| `love.window.setMode(width, height, flags)` | `Night.Window.SetMode(int width, int height, Night.WindowFlags? flags = null)` | `public static bool SetMode(int width, int height, Night.WindowFlags? flags = null)` <br> `flags` could include: `Fullscreen`, `Resizable`, `Borderless`, `VSync`, `MinMSAA`, `DepthBits`, `StencilBits`. Returns success. | In Scope | [x] |
| `love.window.setPosition(x, y, displayindex)` | `Night.Window.SetPosition(int x, int y, int displayIndex = -1)` | `public static void SetPosition(int x, int y, int displayIndex = -1)` <br> `displayIndex = -1` could mean current or primary. | In Scope | [ ] |
| `love.window.setTitle(title)`      | `Night.Window.SetTitle(string title)` | `public static void SetTitle(string title)` | In Scope | [x] |
| `love.window.toPixels(x, y)`       | `Night.Window.ToPixels(double x, double y)` | `public static (double pixelX, double pixelY) ToPixels(double x, double y)` <br> Converts density-independent units to pixel coordinates. | In Scope (if high DPI is handled) | [ ] |
| `love.window.updateMode(width, height, flags)` | `Night.Window.UpdateMode(int width, int height, Night.WindowFlags? flags = null)` | `public static bool UpdateMode(int width, int height, Night.WindowFlags? flags = null)` <br> Similar to `SetMode` but for an existing window. | In Scope | [ ] |
| `love.window.showMessageBox(title, message, type, attachtowindow)` | `Night.Window.ShowMessageBox(string title, string message, Night.MessageBoxType type = Night.MessageBoxType.Info, bool attachToWindow = true)` | `public static void ShowMessageBox(string title, string message, Night.MessageBoxType type = Night.MessageBoxType.Info, bool attachToWindow = true)` <br> `MessageBoxType` enum: `Info`, `Warning`, `Error`. | Out of Scope (Low priority) | [ ] |

**Night Engine Specific Types:**
*   `Night.WindowFlags`: A struct or class that might contain boolean properties like `Fullscreen`, `Resizable`, `Borderless`, `VSync`, and potentially integer values for `MinMSAA`, `DepthBits`, `StencilBits`.
*   `Night.FullscreenType`: Enum (`Desktop`, `Exclusive`).
*   `Night.FullscreenMode`: Struct/class (`int Width, int Height, int RefreshRate`).
*   `Night.ImageData`: Wrapper for image data, likely from `Night.Image` module.
*   `Night.MessageBoxType`: Enum (`Info`, `Warning`, `Error`).




================================================
File: scripts/sync_sdl3.py
================================================
import requests
import zipfile
import os
import shutil
import tempfile
import xml.etree.ElementTree as ET

OWNER = "nightconcept"
REPO = "build-sdl"
PREBUILT_DIR = os.path.join(os.path.dirname(__file__), "..", "lib", "SDL3-Prebuilt")
VERSION_FILE = os.path.join(PREBUILT_DIR, "version.txt")

LIBRARIES_CONFIG = {
    "sdl3-core": {
        "tag_prefix": "sdl3-core-release-",
        "asset_lib_name": "SDL3",
        "lib_files": {
            "windows": "SDL3.dll",
            "macos": "libSDL3.0.dylib",
            "linux": "libSDL3.so.0",
        },
        "extract_subfolder": None,
        "csproj_path": os.path.join(os.path.dirname(__file__), "..", "lib", "SDL3-CS", "SDL3-CS.Native", "SDL3-CS.Native.csproj")
    },
    "sdl2_mixer": {
        "tag_prefix": "sdl3_mixer-release-",
        "asset_lib_name": {
            "windows": "SDL2_mixer",        # Windows asset zip uses SDL2_mixer
            "macos": "SDL3_mixer",
            "linux": "SDL3_mixer"
        },
        "lib_files": {
            "windows": "SDL2_mixer.dll",
            "macos": "libSDL3_mixer.0.dylib",
            "linux": "libSDL3_mixer.so.0",
        },
        "extract_subfolder": None,
        "csproj_path": os.path.join(os.path.dirname(__file__), "..", "lib", "SDL3-CS", "SDL3-CS.Native.Mixer", "SDL3-CS.Native.Mixer.csproj")
    },
    "sdl3_ttf": {
        "tag_prefix": "sdl3_ttf-release-",
        "asset_lib_name": "SDL3_ttf",
        "lib_files": {
            "windows": "SDL3_ttf.dll",
            "macos": "libSDL3_ttf.0.dylib",
            "linux": "libSDL3_ttf.so.0",
        },
        "extract_subfolder": None,
        "csproj_path": os.path.join(os.path.dirname(__file__), "..", "lib", "SDL3-CS", "SDL3-CS.Native.TTF", "SDL3-CS.Native.TTF.csproj")
    },
    "sdl3_image": {
        "tag_prefix": "sdl3_image-release-",
        "asset_lib_name": "SDL3_image",
        "lib_files": {
            "windows": "SDL3_image.dll",
            "macos": "libSDL3_image.0.dylib",
            "linux": "libSDL3_image.so.0",
        },
        "extract_subfolder": None,
        "csproj_path": os.path.join(os.path.dirname(__file__), "..", "lib", "SDL3-CS", "SDL3-CS.Native.Image", "SDL3-CS.Native.Image.csproj")
    },
}

PLATFORM_TAGS = {
    "windows": "win32-x64",
    "macos": "macos-universal", # Default for macOS, overridden for SDL_image arm64
    "linux": "linux-x86_64",
}

# Ensure PREBUILT_DIR subdirectories exist
for platform in PLATFORM_TAGS.keys():
    os.makedirs(os.path.join(PREBUILT_DIR, platform), exist_ok=True)

def get_all_releases():
    """Fetches all release information from GitHub."""
    api_url = f"https://api.github.com/repos/{OWNER}/{REPO}/releases"
    print(f"Fetching all releases from {api_url}...")
    response = requests.get(api_url)
    response.raise_for_status()
    return response.json()

def get_version_from_csproj(csproj_path):
    """Extracts and formats the version from a .csproj file."""
    try:
        tree = ET.parse(csproj_path)
        root = tree.getroot()
        nugetPropertyGroup = root.find("./PropertyGroup[@Label='NuGet']")
        if nugetPropertyGroup is not None:
            version_element = nugetPropertyGroup.find("Version")
            if version_element is not None and version_element.text:
                full_version = version_element.text.strip()
                # Convert "X.Y.Z.W" to "X.Y.Z"
                parts = full_version.split('.')
                if len(parts) >= 3:
                    return ".".join(parts[:3])
                else:
                    print(f"Warning: Version '{full_version}' in {csproj_path} is not in expected X.Y.Z.W format.")
                    return None
        print(f"Warning: Could not find <Version> tag under <PropertyGroup Label='NuGet'> in {csproj_path}.")
        return None
    except ET.ParseError:
        print(f"Error: Could not parse XML from {csproj_path}.")
        return None
    except FileNotFoundError:
        print(f"Error: .csproj file not found at {csproj_path}.")
        return None

def get_specific_release_by_version_tag(releases, tag_prefix, target_version_str):
    """Finds a specific release matching a given tag prefix and version string."""
    expected_tag_name = tag_prefix + target_version_str
    print(f"Searching for release with exact tag: {expected_tag_name}")
    for release in releases:
        if release.get("tag_name", "") == expected_tag_name:
            release["parsed_version"] = target_version_str  # Store the clean version string
            print(f"Found specific release: {release['tag_name']}")
            return release
    print(f"Release with tag '{expected_tag_name}' not found.")
    return None

def find_asset_url(release_data, expected_asset_name):
    """Finds the download URL for a specific asset in the release data."""
    for asset in release_data.get("assets", []):
        if asset["name"] == expected_asset_name:
            # Reduced verbosity: print(f"Found asset: {asset['browser_download_url']}")
            return asset["browser_download_url"]
    print(f"Warning: Asset '{expected_asset_name}' not found in release {release_data.get('tag_name')}")
    return None

def download_file(url, dest_path):
    """Downloads a file from a URL to a destination path."""
    print(f"Downloading {os.path.basename(dest_path)}...")
    response = requests.get(url, stream=True)
    response.raise_for_status()
    with open(dest_path, "wb") as f:
        for chunk in response.iter_content(chunk_size=8192):
            f.write(chunk)
    # Reduced verbosity: print("Download complete.")

def extract_zip(zip_path, extract_to_path):
    """Extracts a zip file to a specified directory."""
    # Reduced verbosity: print(f"Extracting {zip_path} to {extract_to_path}...")
    with zipfile.ZipFile(zip_path, "r") as zip_ref:
        zip_ref.extractall(extract_to_path)
    # Reduced verbosity: print("Extraction complete.")

def copy_library_file(extract_path, lib_name, platform, lib_config):
    """Copies the specific library file from the extracted path to the prebuilt directory."""
    lib_filename = lib_config["lib_files"][platform]

    # Determine source path, considering a potential subfolder in the zip
    src_file_path = extract_path # Default if logic below doesn't find a better path
    if lib_config.get("extract_subfolder"):
        # This logic might need adjustment if the subfolder name is dynamic (e.g., versioned)
        # For now, assumes a fixed subfolder name if provided.
        # Example: if zip extracts to "sdl3-core-3.0.0/", then extract_subfolder could be "sdl3-core-3.0.0"
        # However, the current LIBRARIES_CONFIG has it as None.

        # Simplified: try root, then try common patterns like 'lib', 'bin'
        possible_src_paths = [
            os.path.join(extract_path, lib_config["extract_subfolder"], lib_filename),
            os.path.join(extract_path, lib_config["extract_subfolder"], "lib", lib_filename),
            os.path.join(extract_path, lib_config["extract_subfolder"], "bin", lib_filename),
        ]
        # Also check if the subfolder itself is the direct parent of the lib_filename
        possible_src_paths.insert(0, os.path.join(extract_path, lib_filename)) # Check root of extract_path first

        found_src_file = None
        for p_path in possible_src_paths:
            if os.path.exists(p_path):
                found_src_file = p_path
                break

        if not found_src_file:
            print(f"Warning: Library file {lib_filename} not found in standard subfolder paths for {lib_name} on {platform} with extract_subfolder '{lib_config.get('extract_subfolder')}'. Searching recursively in {extract_path}...")
            for root, _, files in os.walk(extract_path):
                if lib_filename in files:
                    found_src_file = os.path.join(root, lib_filename)
                    print(f"Found {lib_filename} at {found_src_file}")
                    break
            if not found_src_file:
                print(f"Error: Library file {lib_filename} not found in {extract_path} for {lib_name} on {platform}.")
                return False
        src_file_path = found_src_file

    else: # No extract_subfolder specified, assume lib is at root of extracted files or in a single dir.
        src_file_path_direct = os.path.join(extract_path, lib_filename)
        if os.path.exists(src_file_path_direct):
            src_file_path = src_file_path_direct
        else:
            extracted_items = os.listdir(extract_path)
            if len(extracted_items) == 1 and os.path.isdir(os.path.join(extract_path, extracted_items[0])):
                # Zip extracted into a single top-level directory
                base_extracted_dir = os.path.join(extract_path, extracted_items[0])

                # Check for lib directly in this subdir
                src_file_path_subdir_direct = os.path.join(base_extracted_dir, lib_filename)
                if os.path.exists(src_file_path_subdir_direct):
                    src_file_path = src_file_path_subdir_direct
                else:
                    # Try common subdirs like lib/ or bin/ within that single extracted directory
                    common_subdirs_to_check = ["lib", "bin"]
                    found_in_common_subdir = False
                    for common_s_dir in common_subdirs_to_check:
                        path_in_common_subdir = os.path.join(base_extracted_dir, common_s_dir, lib_filename)
                        if os.path.exists(path_in_common_subdir):
                            src_file_path = path_in_common_subdir
                            found_in_common_subdir = True
                            break
                    if not found_in_common_subdir:
                        # Fallback: search recursively within the single extracted directory
                        print(f"Warning: Library file {lib_filename} not found in standard paths within {base_extracted_dir}. Searching recursively...")
                        found_recursively = False
                        for root, _, files in os.walk(base_extracted_dir):
                            if lib_filename in files:
                                src_file_path = os.path.join(root, lib_filename)
                                print(f"Found {lib_filename} at {src_file_path}")
                                found_recursively = True
                                break
                        if not found_recursively:
                            print(f"Error: Library file {lib_filename} not found in {extract_path} or its single subdirectory '{base_extracted_dir}' for {lib_name} on {platform}.")
                            return False
            else: # Multiple items at root of extraction, or not a directory
                # Fallback: search recursively from the root of extract_path
                print(f"Warning: Library file {lib_filename} not found directly in {extract_path} and not a single subdirectory structure. Searching recursively in {extract_path}...")
                found_recursively_at_root = False
                for root, _, files in os.walk(extract_path):
                    if lib_filename in files:
                        src_file_path = os.path.join(root, lib_filename)
                        print(f"Found {lib_filename} at {src_file_path}")
                        found_recursively_at_root = True
                        break
                if not found_recursively_at_root:
                    print(f"Error: Library file {lib_filename} not found directly in {extract_path} for {lib_name} on {platform}.")
                    return False


    dest_dir = os.path.join(PREBUILT_DIR, platform)
    dest_file_path = os.path.join(dest_dir, lib_filename)

    os.makedirs(dest_dir, exist_ok=True)
    shutil.copy2(src_file_path, dest_file_path)
    print(f"  Successfully copied {lib_filename} for {lib_name} ({platform})")
    return True

def update_version_file(library_versions):
    """Updates the version.txt file with all successfully fetched library versions."""
    if library_versions:
        print(f"\nUpdating {VERSION_FILE} with library versions...")
        with open(VERSION_FILE, "w") as f:
            for lib_key, version_str in sorted(library_versions.items()):
                f.write(f"{lib_key}={version_str}\n")
        print("Version file updated.")
    else:
        print("\nSkipping version file update as no library versions were determined.")

def main():
    library_versions = {} # To store successfully fetched versions
    total_expected_files = 0
    successfully_copied_files = 0
    failed_downloads_or_copies = [] # Stores tuples of (lib_key, platform_key, reason)

    try:
        all_releases = get_all_releases()
        if not all_releases:
            print("No releases found. Exiting.")
            return

        for lib_key, lib_config in LIBRARIES_CONFIG.items():
            print(f"\nProcessing library: {lib_key}...")

            csproj_path = lib_config.get("csproj_path")
            if not csproj_path:
                print(f"  Error: csproj_path not defined for {lib_key}. Skipping.")
                for platform_key in PLATFORM_TAGS.keys():
                    total_expected_files += 1
                    failed_downloads_or_copies.append((lib_key, platform_key, "csproj_path not defined"))
                continue

            target_version_str = get_version_from_csproj(csproj_path)
            if not target_version_str:
                print(f"  Could not determine version for {lib_key} from {csproj_path}. Skipping all platforms for this library.")
                for platform_key in PLATFORM_TAGS.keys():
                    total_expected_files += 1
                    failed_downloads_or_copies.append((lib_key, platform_key, f"Version not found in {os.path.basename(csproj_path)}"))
                continue

            print(f"  Target version from {os.path.basename(csproj_path)}: {target_version_str}")
            specific_lib_release = get_specific_release_by_version_tag(all_releases, lib_config["tag_prefix"], target_version_str)

            if not specific_lib_release:
                print(f"  Could not find release for {lib_key} version {target_version_str}. Skipping all platforms for this library.")
                for platform_key in PLATFORM_TAGS.keys():
                    total_expected_files += 1
                    failed_downloads_or_copies.append((lib_key, platform_key, f"Release for version {target_version_str} not found"))
                continue

            lib_version = specific_lib_release["parsed_version"] # Should be target_version_str
            # Store version if release was found, even if some assets fail later
            library_versions[lib_key] = lib_version

            for platform_key, platform_tag_value in PLATFORM_TAGS.items():
                total_expected_files += 1
                asset_to_log_base = f"{lib_key} v{lib_version} ({platform_key})"

                current_platform_tag = platform_tag_value

                # Determine asset_lib_name for constructing the filename
                asset_lib_name_config_value = lib_config["asset_lib_name"]
                actual_asset_lib_name_for_file = ""

                if isinstance(asset_lib_name_config_value, dict):
                    actual_asset_lib_name_for_file = asset_lib_name_config_value.get(platform_key)
                    if not actual_asset_lib_name_for_file:
                        print(f"    Error: Platform-specific asset_lib_name for '{platform_key}' not found in config for '{lib_key}'. Skipping.")
                        failed_downloads_or_copies.append((lib_key, platform_key, f"asset_lib_name for {platform_key} missing"))
                        continue
                else:
                    actual_asset_lib_name_for_file = asset_lib_name_config_value

                if lib_key == "sdl3_image" and platform_key == "macos":
                    # SDL3_image on macOS has a special asset name for arm64
                    expected_asset_name = f"SDL3_image-{lib_version}-macos-arm64.zip"
                else:
                    expected_asset_name = f"{actual_asset_lib_name_for_file}-{lib_version}-{current_platform_tag}.zip"

                print(f"  Looking for asset: {expected_asset_name}")
                asset_url = find_asset_url(specific_lib_release, expected_asset_name)

                if not asset_url:
                    print(f"    Asset not found. Skipping.")
                    failed_downloads_or_copies.append((lib_key, platform_key, "Asset not found in release"))
                    continue

                try:
                    with tempfile.TemporaryDirectory() as tmpdir:
                        zip_filename = expected_asset_name
                        zip_path = os.path.join(tmpdir, zip_filename)

                        download_file(asset_url, zip_path)

                        extract_target_path = os.path.join(tmpdir, f"extracted_{lib_key}_{platform_key}_{lib_version}")
                        os.makedirs(extract_target_path, exist_ok=True)
                        extract_zip(zip_path, extract_target_path)

                        if copy_library_file(extract_target_path, lib_key, platform_key, lib_config):
                            successfully_copied_files +=1
                        else:
                            # Error already printed in copy_library_file
                            failed_downloads_or_copies.append((lib_key, platform_key, "Copy failed"))
                except Exception as e_inner:
                    print(f"    Error processing {asset_to_log_base}: {e_inner}")
                    failed_downloads_or_copies.append((lib_key, platform_key, f"Exception: {e_inner}"))

        update_version_file(library_versions)

    except requests.exceptions.RequestException as e:
        print(f"\nNetwork error: {e}")
    except zipfile.BadZipFile as e:
        print(f"\nError: Downloaded file is not a valid zip file or is corrupted: {e}")
    except Exception as e:
        print(f"\nAn unexpected error occurred: {e}")
        import traceback
        traceback.print_exc()
    finally:
        print("\n--- Update Summary ---")
        print(f"Total library files expected: {total_expected_files}")
        print(f"Successfully copied:        {successfully_copied_files}")
        failures = total_expected_files - successfully_copied_files
        print(f"Failed to retrieve/copy:  {failures}")
        if failed_downloads_or_copies:
            print("\nDetails of failures/skipped files:")
            for lib, plat, reason in failed_downloads_or_copies:
                print(f"  - {lib} ({plat}): {reason}")
        print("----------------------")

if __name__ == "__main__":
    main()



================================================
File: scripts/update_api_doc.py
================================================
import os
import re
from collections import defaultdict

def derive_love2d_api(class_name, method_name):
    """
    Attempts to derive a Love2D-style API call.
    Example: Filesystem, GetInfo -> love.filesystem.getInfo
    """
    if not class_name or not method_name:
        return ""

    module_name = class_name.lower()

    # Convert PascalCase or camelCase method_name to camelCase (starting lowercase)
    # If it's already camelCase (like 'getInfo'), it should remain as is.
    # If it's PascalCase (like 'GetInfo'), it becomes 'getInfo'.
    love_method_name = method_name[0].lower() + method_name[1:]

    return f"love.{module_name}.{love_method_name}"

def parse_cs_file(filepath):
    """
    Parses a C# file to extract public static classes and their public static methods.
    """
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            content = f.read()
    except Exception as e:
        print(f"Error reading file {filepath}: {e}")
        return None

    class_data = {}

    # Regex to find public static classes
    class_match = re.search(r"public\s+static\s+class\s+(\w+)", content)

    if class_match:
        class_name = class_match.group(1)
        class_content_start = class_match.end()

        # Rough way to get class content, assuming reasonably formatted code
        # This might fail with complex nested structures or preprocessor directives
        open_braces = 0
        class_body_end = class_content_start
        found_first_brace = False

        for i in range(class_content_start, len(content)):
            if content[i] == '{':
                if not found_first_brace:
                    found_first_brace = True
                open_braces += 1
            elif content[i] == '}':
                open_braces -= 1
                if found_first_brace and open_braces == 0:
                    class_body_end = i
                    break

        class_body = content[class_match.end():class_body_end]

        methods = defaultdict(list)
        # Regex to find public static methods, including parameters
        # This regex aims to capture [return_type] MethodName([params])
        # Group 1: return_type (non-greedy)
        # Group 2: method_name
        # Group 3: params_str
        method_pattern = re.compile(
            r"public\s+static\s+(?:async\s+)?(.*?)\s+(\w+)\s*\(([^)]*)\)"
        )

        for method_match in method_pattern.finditer(class_body):
            # Return type is group 1, method_name is group 2, params_str is group 3
            method_name = method_match.group(2)
            params_str = method_match.group(3).strip()

            # Clean up parameter string: remove default values, extra spaces
            params_list = []
            if params_str:
                raw_params = params_str.split(',')
                for p in raw_params:
                    p_cleaned = p.strip()
                    # Remove default initializers like "= null" or "= 12"
                    p_cleaned = re.sub(r"\s*=\s*.*", "", p_cleaned)
                    params_list.append(p_cleaned)

            full_signature = f"{method_name}({', '.join(params_list)})"
            methods[method_name].append(full_signature)

        if methods:
            class_data[class_name] = dict(methods)

    return class_data

def parse_enums_cs_file(filepath):
    """
    Parses a C# file to extract public enums.
    """
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            content = f.read()
    except FileNotFoundError:
        return [] # Silently return empty if file not found
    except Exception as e:
        print(f"Error reading enum file {filepath}: {e}")
        return []

    enums = []
    # Regex to find public enums
    enum_pattern = re.compile(r"public\s+enum\s+(\w+)")
    for match in enum_pattern.finditer(content):
        enums.append(match.group(1))
    return sorted(list(set(enums)))

def parse_types_cs_file(filepath):
    """
    Parses a C# file to extract public class names.
    """
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            content = f.read()
    except FileNotFoundError:
        return [] # Silently return empty if file not found
    except Exception as e:
        print(f"Error reading types file {filepath}: {e}")
        return []

    types = []
    # Regex to find public classes (can be extended for structs, interfaces if needed)
    # e.g., r"public\s+(?:class|struct|interface)\s+(\w+)"
    class_pattern = re.compile(r"public\s+class\s+(\w+)")
    for match in class_pattern.finditer(content):
        types.append(match.group(1))
    return sorted(list(set(types)))

def generate_markdown(all_module_data, output_file):
    """
    Generates a markdown file from the parsed API data.
    """
    markdown_lines = []
    markdown_lines.append(f"# Night / Love2D API\n")

    sorted_module_names = sorted(all_module_data.keys())

    for module_name_key in sorted_module_names:
        module_data = all_module_data[module_name_key]
        markdown_lines.append(f"## {module_name_key}\n")

        module_had_content = False

        # --- Types ---
        if module_data.get("types"):
            if module_had_content: markdown_lines.append("") # Separator from previous section
            markdown_lines.append(f"### Types ({module_name_key})\n")
            module_had_content = True
            for type_name in module_data["types"]: # Already sorted from parsing function
                markdown_lines.append(f"- {type_name}")

        # --- Functions ---
        if module_data.get("functions"):
            if module_had_content: markdown_lines.append("") # Separator from previous section
            markdown_lines.append(f"### Functions ({module_name_key})\n")
            module_had_content = True
            # The "functions" key holds a dict like: {"ClassName": {"methodName": [signatures]}}
            for class_name, methods in module_data["functions"].items():
                sorted_method_names = sorted(methods.keys())
                for method_name in sorted_method_names:
                    signatures = methods[method_name]
                    love2d_call = derive_love2d_api(class_name, method_name)

                    if love2d_call:
                        markdown_lines.append(f"- {method_name}() - {love2d_call}")
                    else:
                        markdown_lines.append(f"- {method_name}()")

                    if len(signatures) > 1 or (len(signatures) == 1 and signatures[0] != f"{method_name}()"):
                        for sig in sorted(signatures):
                            markdown_lines.append(f"  - {sig}")

        # --- Enums ---
        if module_data.get("enums"):
            if module_had_content: markdown_lines.append("")
            markdown_lines.append(f"### Enums ({module_name_key})\n")
            module_had_content = True
            for enum_name in module_data["enums"]:
                markdown_lines.append(f"- {enum_name}")

        # If not the last module, add a separating blank line.
        if module_name_key != sorted_module_names[-1]:
            markdown_lines.append("")

    # At end of document, add ONE blank line
    markdown_lines.append("")

    try:
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write("\n".join(markdown_lines))
        print(f"Markdown documentation generated at {output_file}")
    except Exception as e:
        print(f"Error writing markdown file {output_file}: {e}")

def main():
    framework_dir = os.path.join("src", "Night")
    output_md_file = os.path.join("docs", "API.md")

    all_module_data = defaultdict(lambda: {"functions": {}, "enums": [], "types": []})

    if not os.path.isdir(framework_dir):
        print(f"Error: Directory not found - {framework_dir}")
        return

    # Iterate through subdirectories in framework_dir (each is a module)
    for module_name in sorted(os.listdir(framework_dir)): # Sort for consistent processing order
        module_path = os.path.join(framework_dir, module_name)
        if os.path.isdir(module_path):
            if module_name.startswith('.'): # Skip hidden directories like .git
                continue

            print(f"Processing module: {module_name}...")

            # Path for the main module file (e.g., Filesystem.cs for Filesystem module)
            main_module_cs_file = os.path.join(module_path, f"{module_name}.cs")
            enums_cs_file = os.path.join(module_path, "Enums.cs")
            types_cs_file = os.path.join(module_path, "Types.cs")

            # 1. Parse main module file for functions
            if os.path.exists(main_module_cs_file):
                print(f"  Parsing functions from {main_module_cs_file}...")
                parsed_functions_data = parse_cs_file(main_module_cs_file)
                if parsed_functions_data:
                    for class_name_func, methods in parsed_functions_data.items():
                        # Ensure the functions dict for this class_name_func exists
                        if class_name_func not in all_module_data[module_name]["functions"]:
                            all_module_data[module_name]["functions"][class_name_func] = defaultdict(list)

                        for method_name, signatures in methods.items():
                            all_module_data[module_name]["functions"][class_name_func][method_name].extend(signatures)
                            all_module_data[module_name]["functions"][class_name_func][method_name] = \
                                sorted(list(set(all_module_data[module_name]["functions"][class_name_func][method_name])))
            else:
                print(f"  Skipping functions: {main_module_cs_file} not found for module {module_name}.")

            # 2. Parse Enums.cs for enums
            if os.path.exists(enums_cs_file):
                print(f"  Parsing enums from {enums_cs_file}...")
                parsed_enums = parse_enums_cs_file(enums_cs_file) # Already returns sorted unique list
                if parsed_enums:
                    all_module_data[module_name]["enums"].extend(parsed_enums)
                    all_module_data[module_name]["enums"] = sorted(list(set(all_module_data[module_name]["enums"]))) # Ensure uniqueness if called multiple times (though not expected here)
            else:
                print(f"  Skipping enums: {enums_cs_file} not found for module {module_name}.")


            # 3. Parse Types.cs for types
            if os.path.exists(types_cs_file):
                print(f"  Parsing types from {types_cs_file}...")
                parsed_types = parse_types_cs_file(types_cs_file) # Already returns sorted unique list
                if parsed_types:
                    all_module_data[module_name]["types"].extend(parsed_types)
                    all_module_data[module_name]["types"] = sorted(list(set(all_module_data[module_name]["types"]))) # Ensure uniqueness
            else:
                print(f"  Skipping types: {types_cs_file} not found for module {module_name}.")
            print("") # Blank line after processing a module's files for readability in console

    if all_module_data:
        os.makedirs(os.path.dirname(output_md_file), exist_ok=True)
        generate_markdown(all_module_data, output_md_file)
    else:
        print("No API data parsed.")

if __name__ == "__main__":
    main()



================================================
File: scripts/update_tools.py
================================================
import os
import requests
import zipfile
import shutil
import json # Added for manifest handling

# Configuration
TOOL_NAME = "crunch"
GITHUB_OWNER = "nightconcept"
GITHUB_REPO = "crunch"
GITHUB_API_URL_LATEST_RELEASE = f"https://api.github.com/repos/{GITHUB_OWNER}/{GITHUB_REPO}/releases/latest"

BASE_TARGET_DIR = os.path.join("tools", TOOL_NAME)
MANIFEST_FILE_PATH = os.path.join("tools", "manifest.json")

PLATFORM_IDENTIFIERS = {
    "linux": "linux",
    "macos": "macos",
    "windows": "windows"
}

def ensure_dir_exists(path):
    """Ensures that a directory exists, creating it if necessary."""
    if not os.path.exists(path):
        os.makedirs(path, exist_ok=True)

def load_manifest():
    """Loads the manifest file."""
    ensure_dir_exists(os.path.dirname(MANIFEST_FILE_PATH))
    if not os.path.exists(MANIFEST_FILE_PATH):
        return {}
    try:
        with open(MANIFEST_FILE_PATH, 'r') as f:
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        return {}

def save_manifest(data):
    """Saves data to the manifest file."""
    ensure_dir_exists(os.path.dirname(MANIFEST_FILE_PATH))
    with open(MANIFEST_FILE_PATH, 'w') as f:
        json.dump(data, f, indent=4)

def get_latest_release_info():
    """Fetches the latest release information from GitHub."""
    print(f"Fetching latest release information for {GITHUB_OWNER}/{GITHUB_REPO}...")
    try:
        response = requests.get(GITHUB_API_URL_LATEST_RELEASE, timeout=30)
        response.raise_for_status()
        release_data = response.json()
        version = release_data.get("tag_name")
        assets = release_data.get("assets", [])
        if not version or not assets:
            print("Error: Could not find version or assets in GitHub API response.")
            return None

        print(f"Latest version found: {version}")
        return {"version": version, "assets": assets}
    except requests.exceptions.RequestException as e:
        print(f"Error fetching release info from GitHub: {e}")
        return None
    except json.JSONDecodeError:
        print("Error: Could not decode JSON response from GitHub API.")
        return None


def download_and_extract_asset(asset_name, asset_url, platform_subdir, base_download_path):
    """Downloads a single asset and extracts it into a platform-specific subdirectory."""

    # Temporary download location for the zip file (e.g., in BASE_TARGET_DIR)
    temp_zip_dir = base_download_path
    # Use a generic name for the downloaded zip to avoid issues if asset_name is complex
    # However, for clarity during download, asset_name is fine if it's just the filename.
    zip_file_path = os.path.join(temp_zip_dir, asset_name)

    ensure_dir_exists(temp_zip_dir) # Should already exist if base_download_path is BASE_TARGET_DIR

    extract_to_path = os.path.join(base_download_path, platform_subdir)
    ensure_dir_exists(extract_to_path)

    print(f"Processing {asset_name} for {platform_subdir}...")
    try:
        print(f"  Downloading from {asset_url}...")
        response = requests.get(asset_url, stream=True, timeout=60)
        response.raise_for_status()

        with open(zip_file_path, 'wb') as f:
            for chunk in response.iter_content(chunk_size=8192):
                f.write(chunk)

        print(f"  Extracting to {extract_to_path}...")
        with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
            zip_ref.extractall(extract_to_path)
        print(f"  Successfully processed {asset_name}")

    except requests.exceptions.RequestException as e:
        print(f"  Error downloading {asset_name}: {e}")
        return False
    except zipfile.BadZipFile:
        print(f"  Error: {asset_name} is not a valid zip file or is corrupted.")
        return False
    except Exception as e:
        print(f"  An unexpected error occurred with {asset_name}: {e}")
        return False
    finally:
        if os.path.exists(zip_file_path):
            os.remove(zip_file_path)
    return True

def main():
    """Main function to download and extract crunch tools."""
    print(f"Starting update process for {TOOL_NAME} tools into {BASE_TARGET_DIR}...")
    ensure_dir_exists(BASE_TARGET_DIR)

    manifest_data = load_manifest()
    current_tool_info = manifest_data.get(TOOL_NAME, {})
    current_version = current_tool_info.get("version")

    latest_release_info = get_latest_release_info()
    if not latest_release_info:
        print(f"Could not retrieve latest release information for {TOOL_NAME}. Exiting.")
        return

    latest_version = latest_release_info["version"]

    if current_version == latest_version:
        print(f"{TOOL_NAME} is already up to date (Version: {current_version}).")
        return

    print(f"New version of {TOOL_NAME} available: {latest_version}. (Current: {current_version or 'None'})")
    print("Attempting to download and extract new version...")

    all_successful_this_run = True
    assets_processed_count = 0

    for asset in latest_release_info["assets"]:
        asset_name = asset.get("name", "").lower()
        asset_url = asset.get("browser_download_url")

        if not asset_name or not asset_url or not asset_name.endswith(".zip"):
            continue # Skip if not a zip or missing essential info

        processed_for_platform = False
        for platform_key, id_string in PLATFORM_IDENTIFIERS.items():
            if id_string in asset_name:
                if not download_and_extract_asset(asset.get("name"), asset_url, platform_key, BASE_TARGET_DIR):
                    all_successful_this_run = False
                    print(f"Failed to process asset {asset.get('name')} for platform {platform_key}.")
                else:
                    assets_processed_count += 1
                processed_for_platform = True
                break # Asset matched a platform

    if all_successful_this_run and assets_processed_count > 0:
        manifest_data[TOOL_NAME] = {"version": latest_version}
        save_manifest(manifest_data)
        print(f"{TOOL_NAME} successfully updated to version {latest_version}.")
        print(f"{assets_processed_count} asset(s) processed.")
    elif assets_processed_count == 0:
        print(f"No suitable assets found for {TOOL_NAME} in version {latest_version}.")
    else:
        print(f"Some assets for {TOOL_NAME} version {latest_version} failed to download or extract. Manifest not updated.")

if __name__ == "__main__":
    main()



================================================
File: src/Night/ErrorHandler.cs
================================================
// <copyright file="ErrorHandler.cs" company="PlaceholderCompany">
// Copyright (c) PlaceholderCompany. All rights reserved.
// </copyright>

using System;
using System.IO;

namespace Night
{
  /// <summary>
  /// Defines the delegate for handling unhandled exceptions from game code.
  /// </summary>
  /// <param name="e">The exception that occurred.</param>
  public delegate void ErrorHandlerDelegate(Exception e);

  /// <summary>
  /// Manages the user-defined error handler.
  /// </summary>
  public static class Error
  {
    internal static ErrorHandlerDelegate? CustomErrorHandler { get; private set; }

    /// <summary>
    /// Sets a custom function to be called when an unhandled error occurs in game code.
    /// </summary>
    /// <param name="handler">The delegate to handle errors.</param>
    public static void SetHandler(ErrorHandlerDelegate handler)
    {
      CustomErrorHandler = handler;
    }

    internal static ErrorHandlerDelegate? GetHandler()
    {
      return CustomErrorHandler;
    }
  }
}



================================================
File: src/Night/FrameworkLoop.cs
================================================
// <copyright file="FrameworkLoop.cs" company="PlaceholderCompany">
// Copyright (c) PlaceholderCompany. All rights reserved.
// </copyright>

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.InteropServices;

using Night;

using SDL3;

namespace Night
{
  /// <summary>
  /// Manages the main game loop and coordination of game states.
  /// Provides the main entry point to run a game.
  /// </summary>
  public static class Framework
  {
    private static bool isSdlInitialized = false;
    private static SDL.InitFlags initializedSubsystems = 0;

    private static int frameCount = 0;
    private static double fpsTimeAccumulator = 0.0;
    private static List<double> deltaHistory = new List<double>();
    private const int MaxDeltaHistorySamples = 60; // Store up to 1 second of deltas at 60fps

    private static bool inErrorState = false;

    /// <summary>
    /// Gets a value indicating whether a flag indicating whether the core SDL systems, particularly for input,
    /// have been successfully initialized by this Framework's Run method.
    /// </summary>
    public static bool IsInputInitialized { get; private set; } = false;

    private static string GetFormattedPlatformString()
    {
      if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
      {
        try
        {
          string macOSVersion = string.Empty;
          string darwinVersion = string.Empty;

          // Get macOS version
          ProcessStartInfo swVersPsi = new ProcessStartInfo
          {
            FileName = "sw_vers",
            Arguments = "-productVersion",
            RedirectStandardOutput = true,
            UseShellExecute = false,
            CreateNoWindow = true,
          };
          using (Process swVersProcess = Process.Start(swVersPsi)!)
          {
            macOSVersion = swVersProcess.StandardOutput.ReadToEnd().Trim();
            swVersProcess.WaitForExit();
          }

          // Get Darwin kernel version
          ProcessStartInfo unamePsi = new ProcessStartInfo
          {
            FileName = "uname",
            Arguments = "-r",
            RedirectStandardOutput = true,
            UseShellExecute = false,
            CreateNoWindow = true,
          };
          using (Process unameProcess = Process.Start(unamePsi)!)
          {
            darwinVersion = unameProcess.StandardOutput.ReadToEnd().Trim();
            unameProcess.WaitForExit();
          }

          if (!string.IsNullOrEmpty(macOSVersion) && !string.IsNullOrEmpty(darwinVersion))
          {
            return $"Platform: macOS {macOSVersion} (Darwin {darwinVersion})";
          }
        }
        catch (Exception ex)
        {
          // Log the exception or handle it as needed, then fall back.
          Console.WriteLine($"Night.Framework.Run: Could not retrieve detailed macOS version info: {ex.Message}");
        }
      }

      // Fallback for non-macOS platforms or if macOS version retrieval fails
      return $"Platform: {RuntimeInformation.OSDescription} ({RuntimeInformation.OSArchitecture})";
    }

    /// <summary>
    /// Runs the game instance.
    /// The game loop will internally call Load, Update, and Draw methods
    /// on the provided game logic.
    /// This method will initialize and shut down required SDL subsystems.
    /// </summary>
    /// <param name="game">The game interface to run. Must implement <see cref="Night.IGame"/>.</param>
    public static void Run(IGame game)
    {
      if (game == null)
      {
        Console.WriteLine("Night.Framework.Run: gameLogic cannot be null.");
        return;
      }

      ConfigurationManager.LoadConfig();
      var windowConfig = ConfigurationManager.CurrentConfig.Window;

      string sdlVersionString = NightSDL.GetVersion();
      Console.WriteLine($"Night Engine: v0.0.1");
      Console.WriteLine($"SDL: v{sdlVersionString}");
      Console.WriteLine(GetFormattedPlatformString());
      Console.WriteLine($"Framework: {RuntimeInformation.FrameworkDescription}");

      try
      {
        initializedSubsystems = SDL.InitFlags.Video | SDL.InitFlags.Events;
        if (!SDL.Init(initializedSubsystems))
        {
          Console.WriteLine($"Night.Framework.Run: SDL_Init failed: {SDL.GetError()}");
          return;
        }

        isSdlInitialized = true;
        IsInputInitialized = (initializedSubsystems & SDL.InitFlags.Events) == SDL.InitFlags.Events;

        // Setup initial window based on configuration BEFORE game.Load()
        Console.WriteLine("Night.Framework.Run: Initializing window with config/default settings before game.Load().");
        SDL.WindowFlags sdlFlags = (SDL.WindowFlags)0;
        if (windowConfig.Resizable)
        {
          sdlFlags |= SDL.WindowFlags.Resizable;
        }

        if (windowConfig.Borderless)
        {
          sdlFlags |= SDL.WindowFlags.Borderless;
        }

        if (windowConfig.HighDPI)
        {
          sdlFlags |= SDL.WindowFlags.HighPixelDensity;
        }

        bool modeSet = Window.SetMode(windowConfig.Width, windowConfig.Height, sdlFlags);
        if (!modeSet)
        {
          Console.WriteLine($"Night.Framework.Run: Failed to set initial window mode from configuration: {SDL.GetError()}");
          CleanUpSDL();
          return;
        }

        Window.SetTitle(windowConfig.Title);

        if (windowConfig.Fullscreen)
        {
          FullscreenType fsType = windowConfig.FullscreenType.ToLowerInvariant() == "exclusive"
                                    ? FullscreenType.Exclusive
                                    : FullscreenType.Desktop;
          if (!Window.SetFullscreen(true, fsType))
          {
            Console.WriteLine($"Night.Framework.Run: Failed to set initial fullscreen mode from configuration: {SDL.GetError()}");
          }
        }

        if (Window.RendererPtr != nint.Zero)
        {
          if (!SDL.SetRenderVSync(Window.RendererPtr, windowConfig.VSync))
          {
            Console.WriteLine($"Night.Framework.Run: Failed to set initial VSync mode from configuration: {SDL.GetError()}");
          }
        }

        if (windowConfig.X.HasValue && windowConfig.Y.HasValue && Window.Handle != nint.Zero)
        {
          _ = SDL.SetWindowPosition(Window.Handle, windowConfig.X.Value, windowConfig.Y.Value);
        }

        // End of initial window setup
        try
        {
          game.Load(); // game.Load() can now use Graphics.NewImage(), and can also call Window.SetMode again to override.
        }
        catch (Exception e)
        {
          HandleGameException(e, game);
          if (inErrorState)
          {
            CleanUpSDLAndWindow();
            return;
          }
        }

        // After game.Load(), check if window is still open.
        // If game.Load() called Window.Close() or failed to maintain a window, we should not continue.
        if (!Window.IsOpen())
        {
          Console.WriteLine("Night.Framework.Run: Window is not open after game.Load(). Exiting.");
          CleanUpSDLAndWindow(); // Ensure cleanup if window was closed by game.Load()
          return;
        }

        // If game.Load() *did* change window settings (e.g. VSync via a new SetMode call),
        // we don't re-apply config VSync here unless we have a way to know it wasn't touched by game.
        // The current Window.SetMode creates a new renderer, so VSync would be reset anyway if game called SetMode.
        // So, if game called SetMode, it's responsible for its own VSync if it differs from config default for new renderer.
        // If game didn't call SetMode, our initial VSync setting stands.
        Night.Timer.Initialize();

        frameCount = 0;
        fpsTimeAccumulator = 0.0;
        deltaHistory.Clear();

        // Main game loop
        while (Window.IsOpen() && !inErrorState)
        {
          // Calculate DeltaTime by calling Night.Timer.Step()
          double deltaTime = Night.Timer.Step();

          // FPS Calculation
          frameCount++;
          fpsTimeAccumulator += deltaTime;
          if (fpsTimeAccumulator >= 1.0)
          {
            Night.Timer.CurrentFPS = frameCount;
            frameCount = 0;
            fpsTimeAccumulator -= 1.0; // Subtract 1 second, keep remainder for accuracy
          }

          // Average Delta Calculation
          deltaHistory.Add(deltaTime);
          if (deltaHistory.Count > MaxDeltaHistorySamples)
          {
            deltaHistory.RemoveAt(0); // Keep the list size bounded
          }

          if (deltaHistory.Count > 0)
          {
            Night.Timer.CurrentAverageDelta = deltaHistory.Average();
          }

          // Event Processing
          while (SDL.PollEvent(out SDL.Event e) && !inErrorState)
          {
            var eventType = (SDL.EventType)e.Type;

            if (eventType == SDL.EventType.Quit)
            {
              Window.Close();
            }
            else if (eventType == SDL.EventType.KeyDown)
            {
              try
              {
                // TODO: Rename these to match love2d
                game.KeyPressed(
                    (KeySymbol)e.Key.Key,
                    (KeyCode)e.Key.Scancode,
                    e.Key.Repeat);
              }
              catch (Exception exUser)
              {
                HandleGameException(exUser, game);
              }
            }
            else if (eventType == SDL.EventType.KeyUp)
            {
              try
              {
                game.KeyReleased(
                    (KeySymbol)e.Key.Key,
                    (KeyCode)e.Key.Scancode);
              }
              catch (Exception exUser)
              {
                HandleGameException(exUser, game);
              }
            }
            else if (eventType == SDL.EventType.MouseButtonDown)
            {
              try
              {
                game.MousePressed(
                    (int)e.Button.X,
                    (int)e.Button.Y,
                    (MouseButton)e.Button.Button,
                    e.Button.Which == SDL.TouchMouseID, // istouch
                    e.Button.Clicks);
              }
              catch (Exception exUser)
              {
                HandleGameException(exUser, game);
              }
            }
            else if (eventType == SDL.EventType.MouseButtonUp)
            {
              try
              {
                game.MouseReleased(
                    (int)e.Button.X,
                    (int)e.Button.Y,
                    (MouseButton)e.Button.Button,
                    e.Button.Which == SDL.TouchMouseID, // istouch
                    e.Button.Clicks);
              }
              catch (Exception exUser)
              {
                HandleGameException(exUser, game);
              }
            }

            // TODO: Add other event handling (mouse, etc.) as per future tasks.
          }

          if (inErrorState) // Check if error occurred during event processing
          {
            // Error handler (Default or custom) should have run.
            // Default handler enters its own loop or prepares for exit.
            // If it was a custom handler, it might have cleared _inErrorState or decided to continue.
            // If _inErrorState is still true, we break the main loop.
            break;
          }

          // Update
          if (!inErrorState) // Do not update if an error has occurred and is being handled
          {
            try
            {
              game.Update((float)deltaTime);
            }
            catch (Exception exUser)
            {
              HandleGameException(exUser, game);
              if (inErrorState)
              {
                break; // Exit main loop if error sets state
              }
            }
          }

          // Draw
          if (!inErrorState) // Do not draw if an error has occurred and is being handled
          {
            try
            {
              // Graphics.BeginFrame() / Clear etc. should be called by game.Draw() or a higher level abstraction.
              // For now, FrameworkLoop does not manage the render target clearing directly.
              // It's assumed game.Draw() handles everything from clear to present.
              game.Draw();

              // Present the drawn frame to the screen
              Night.Graphics.Present();
            }
            catch (Exception exUser)
            {
              HandleGameException(exUser, game);

              // If Draw fails, we typically still want to try and finish the frame/loop iteration
              // unless _inErrorState is set by the handler to signal a desire to stop.
              if (inErrorState)
              {
                break;
              }
            }
          }
        }
      }
      catch (Exception ex)
      {
        // This is for errors within Framework.Run itself, not game code.
        Console.WriteLine($"Night.Framework.Run: An UNEXPECTED FRAMEWORK error occurred: {ex.ToString()}");

        // Attempt to call default error handler for framework errors too, but without game instance.
        HandleGameException(ex, null);
      }
      finally
      {
        // TODO: Call gameLogic.Quit() if it's added to IGame.
        CleanUpSDLAndWindow();
      }
    }

    private static void HandleGameException(Exception e, IGame? gameInstance)
    {
      inErrorState = true; // Signal that we are now in an error state.

      var customHandler = Night.Error.GetHandler();
      if (customHandler != null)
      {
        try
        {
          customHandler(e);

          // If custom handler returns, we assume it handled the error
          // and the game might want to continue or has already quit.
          // For now, we'll still close the window to be safe, unless custom handler re-opens it.
          // This behavior might need refinement.
          if (Window.IsOpen())
          {
            Window.Close();
          }
        }
        catch (Exception exHandler)
        {
          // Error in the custom error handler itself!
          Console.WriteLine($"Night.Framework.Run: CRITICAL: Exception in custom error handler: {exHandler.ToString()}");

          // Fallback to a very minimal default behavior
          Console.WriteLine($"Night.Framework.Run: Original game error: {e.ToString()}");
          if (Window.IsOpen())
          {
            Window.Close(); // Ensure shutdown
          }
        }
      }
      else
      {
        DefaultErrorHandler(e, gameInstance);
      }
    }

    private static void DefaultErrorHandler(Exception e, IGame? gameInstance)
    {
      Console.Error.WriteLine("--- Night Engine: Default Error Handler ---");
      Console.Error.WriteLine($"An error occurred in the game: {e.GetType().Name}");
      Console.Error.WriteLine($"Message: {e.Message}");
      Console.Error.WriteLine("Stack Trace:");
      Console.Error.WriteLine(e.StackTrace);
      Console.Error.WriteLine("-------------------------------------------");

      bool canDrawError = false;
      try
      {
        if (!Window.IsOpen() || (Window.RendererPtr == nint.Zero)) // Assuming Graphics.RendererPtr is a good check for active graphics
        {
          Console.WriteLine("Night.Framework.Run (DefaultErrorHandler): Window or Graphics not initialized. Attempting to set mode...");

          // Attempt to set a basic window mode if not already open.
          // Use a default size. WindowFlags can be minimal or Resizable.
          if (Window.SetMode(800, 600, SDL.WindowFlags.Resizable))
          {
            Console.WriteLine("Night.Framework.Run (DefaultErrorHandler): Window mode set to 800x600.");
            canDrawError = Window.RendererPtr != nint.Zero;
          }
          else
          {
            Console.WriteLine($"Night.Framework.Run (DefaultErrorHandler): Failed to set window mode. SDL Error: {SDL.GetError()}");
          }
        }
        else
        {
          canDrawError = true;
        }

        // Reset input state
        if (IsInputInitialized) // Check if input was ever initialized
        {
          Mouse.SetVisible(true);
          Mouse.SetGrabbed(false);
          Mouse.SetRelativeMode(false);

          // Mouse.SetCursor() - Skipped as per plan if complex; SDL default cursor should apply.
        }
      }
      catch (Exception resetEx)
      {
        Console.Error.WriteLine($"Night.Framework.Run (DefaultErrorHandler): Exception during state reset: {resetEx.ToString()}");
        canDrawError = false; // If reset fails, drawing might be unsafe.
      }

      if (canDrawError)
      {
        try
        {
          // Simple error display loop
          string fullErrorText = $"Error: {e.Message}\n\n{e.StackTrace}";

          // Shorten for display if too long, or make it scrollable if we had font rendering
          // For now, just display what fits or make user copy.
          Window.SetTitle($"Error - {gameInstance?.GetType().Name ?? "Night Game"}");

          bool runningErrorLoop = true;
          while (runningErrorLoop && Window.IsOpen())
          {
            while (SDL.PollEvent(out SDL.Event ev))
            {
              if (ev.Type == (uint)SDL.EventType.Quit)
              {
                runningErrorLoop = false;
                Window.Close();
                break;
              }

              if (ev.Type == (uint)SDL.EventType.KeyDown)
              {
                if (ev.Key.Key == SDL.Keycode.Escape)
                {
                  runningErrorLoop = false;
                  Window.Close();
                  break;
                }

                // Check for Ctrl+C - SDL.Keymod.Ctrl is a flag
                if (ev.Key.Key == SDL.Keycode.C && ((SDL.GetModState() & SDL.Keymod.Ctrl) != 0))
                {
                  try
                  {
                    if (Night.System.SetClipboardText(fullErrorText))
                    {
                      Console.WriteLine("(Error copied to clipboard)");
                    }
                    else
                    {
                      Console.WriteLine($"(Failed to copy error to clipboard: {SDL.GetError()})");
                    }
                  }
                  catch (Exception clipEx)
                  {
                    Console.WriteLine($"(Exception trying to copy to clipboard: {clipEx.Message})");
                  }
                }
              }
            }

            if (!runningErrorLoop)
            {
              break;
            }

            Graphics.Clear(new Color(89, 157, 220, 255)); // Blue background

            // Graphics.Print functionality is NOT available.
            // We will just show a blue screen and title. User must check console.
            // If Night.Font was available:
            // Graphics.SetColor(Night.Color.Black);
            // Graphics.Print($"Error: {e.Message}", 10, 10, Window.GetWidth() - 20);
            // Graphics.Print($"Press ESC to quit. Ctrl+C to copy.", 10, Window.GetHeight() - 30);
            Graphics.Present();
            Timer.Sleep(0.01f); // Sleep for 10ms
          }
        }
        catch (Exception drawEx)
        {
          Console.Error.WriteLine($"Night.Framework.Run (DefaultErrorHandler): Exception during error display loop: {drawEx.ToString()}");
        }
      }
      else
      {
        Console.WriteLine("Night.Framework.Run (DefaultErrorHandler): Cannot display visual error. Check console. Press Ctrl+C in console to quit if frozen.");

        // Loop to keep process alive for a bit for console reading, or just exit.
        // For now, just let it fall through to finally block.
      }

      // Ensure the main loop knows to terminate
      if (Window.IsOpen())
      {
        Window.Close();
      }
    }

    private static void CleanUpSDLAndWindow()
    {
      // Shutdown window and related resources (renderer, etc.)
      // This should happen before SDL.QuitSubSystem for Video.
      if (Window.IsOpen())
      {
        // This case should ideally not be hit if _inErrorState or loop conditions were managed correctly
        Console.WriteLine("Night.Framework.Run (CleanUpSDLAndWindow): Window was still open, attempting to close.");
        Window.Close(); // This will set _isWindowOpen to false
      }

      // Window.Shutdown() handles destroying window, renderer, and SDL.QuitSubSystem(SDL.InitFlags.Video)
      // It's important that Shutdown is called AFTER the error handler's visual loop might have used the window/renderer.
      Window.Shutdown();

      CleanUpSDL();
    }

    private static void CleanUpSDL()
    {
      if (isSdlInitialized)
      {
        // SDL.QuitSubSystem was already called for Video by Window.Shutdown().
        // We only need to quit other subsystems explicitly initialized by Run if they weren't covered.
        // However, SDL.Quit() handles all initialized subsystems.
        SDL.Quit();
        isSdlInitialized = false;
        IsInputInitialized = false;
        initializedSubsystems = 0;
      }
    }
  }
}



================================================
File: src/Night/Night.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <AssemblyName>Night</AssemblyName>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <LangVersion>13.0</LangVersion>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="SDL3-CS" Version="*" />
  </ItemGroup>

</Project>



================================================
File: src/Night/Types.cs
================================================
// <copyright file="Types.cs" company="PlaceholderCompany">
// Copyright (c) PlaceholderCompany. All rights reserved.
// </copyright>

using System;

namespace Night
{
  /// <summary>
  /// Interface for a game that can be run by the Night Engine.
  /// Game developers will implement this interface in their main game class.
  /// </summary>
  public interface IGame
  {
    /// <summary>
    /// Called exactly once when the game starts for loading resources.
    /// </summary>
    void Load();

    /// <summary>
    /// Callback function used to update the state of the game every frame.
    /// </summary>
    /// <param name="deltaTime">The time elapsed since the last frame, in seconds.</param>
    void Update(double deltaTime);

    /// <summary>
    /// Callback function used to draw on the screen every frame.
    /// </summary>
    void Draw();

    /// <summary>
    /// Callback function triggered when a key is pressed.
    /// </summary>
    /// <param name="key">The logical key symbol that was pressed.</param>
    /// <param name="scancode">The physical key (scancode) that was pressed.</param>
    /// <param name="isRepeat">True if this is a key repeat event, false otherwise.</param>
    void KeyPressed(KeySymbol key, KeyCode scancode, bool isRepeat);

    /// <summary>
    /// Callback function triggered when a key is released.
    /// </summary>
    /// <param name="key">The logical key symbol that was released.</param>
    /// <param name="scancode">The physical key (scancode) that was released.</param>
    void KeyReleased(KeySymbol key, KeyCode scancode)
    { /* Optional: Default empty implementation */
    }

    /// <summary>
    /// Callback function triggered when a mouse button is pressed.
    /// </summary>
    /// <param name="x">The x-coordinate of the mouse cursor relative to the window.</param>
    /// <param name="y">The y-coordinate of the mouse cursor relative to the window.</param>
    /// <param name="button">The mouse button that was pressed.</param>
    /// <param name="istouch">True if the event was generated by a touch input device, false otherwise.</param>
    /// <param name="presses">The number of clicks (1 for single-click, 2 for double-click, etc.).</param>
    void MousePressed(int x, int y, MouseButton button, bool istouch, int presses)
    { /* Optional: Default empty implementation */
    }

    /// <summary>
    /// Callback function triggered when a mouse button is released.
    /// </summary>
    /// <param name="x">The x-coordinate of the mouse cursor relative to the window.</param>
    /// <param name="y">The y-coordinate of the mouse cursor relative to the window.</param>
    /// <param name="button">The mouse button that was released.</param>
    /// <param name="istouch">True if the event was generated by a touch input device, false otherwise.</param>
    /// <param name="presses">The number of clicks (typically 1 for release, but may vary).</param>
    void MouseReleased(int x, int y, MouseButton button, bool istouch, int presses)
    { /* Optional: Default empty implementation */
    }
  }
}



================================================
File: src/Night/Configuration/ConfigurationManager.cs
================================================
// <copyright file="ConfigurationManager.cs" company="PlaceholderCompany">
// Copyright (c) PlaceholderCompany. All rights reserved.
// </copyright>

using System;
using System.IO;
using System.Text.Json;

using Night;

namespace Night
{
  public static class ConfigurationManager
  {
    private static readonly string ConfigFileName = "config.json";
    private static GameConfig currentConfig = new GameConfig();
    private static bool isLoaded = false;

    public static GameConfig CurrentConfig => currentConfig;

    public static bool IsLoaded => isLoaded;

    public static void LoadConfig(string? gameDirectory = null)
    {
      if (isLoaded)
      {
        return;
      }

      string effectiveGameDirectory = gameDirectory ?? AppContext.BaseDirectory;
      string configFilePath = Path.Combine(effectiveGameDirectory, ConfigFileName);

      if (File.Exists(configFilePath))
      {
        try
        {
          string jsonContent = File.ReadAllText(configFilePath);
          if (!string.IsNullOrEmpty(jsonContent))
          {
            var options = new JsonSerializerOptions
            {
              PropertyNameCaseInsensitive = true,
              AllowTrailingCommas = true,
              ReadCommentHandling = JsonCommentHandling.Skip,
            };
            GameConfig? loadedConfig = JsonSerializer.Deserialize<GameConfig>(jsonContent, options);
            if (loadedConfig != null)
            {
              currentConfig = loadedConfig;
              Console.WriteLine($"Info: Successfully loaded '{ConfigFileName}' from '{configFilePath}'.");
            }
            else
            {
              Console.WriteLine($"Warning: Could not parse '{ConfigFileName}' from '{configFilePath}'. Using default configuration.");
            }
          }
          else
          {
            Console.WriteLine($"Warning: '{ConfigFileName}' found at '{configFilePath}' is empty. Using default configuration.");
          }
        }
        catch (JsonException jsonEx)
        {
          Console.WriteLine($"Error deserializing '{ConfigFileName}' from '{configFilePath}': {jsonEx.Message}. Using default configuration.");
        }
        catch (Exception ex) // Catches IOExceptions, SecurityExceptions, etc.
        {
          Console.WriteLine($"Error loading '{ConfigFileName}' from '{configFilePath}': {ex.Message}. Using default configuration.");
        }
      }
      else
      {
        Console.WriteLine($"Info: '{ConfigFileName}' not found at '{configFilePath}'. Using default configuration.");
      }

      isLoaded = true;
    }
  }
}



================================================
File: src/Night/Configuration/GameConfig.cs
================================================
// <copyright file="GameConfig.cs" company="PlaceholderCompany">
// Copyright (c) PlaceholderCompany. All rights reserved.
// </copyright>

using System.Text.Json.Serialization;

namespace Night
{

  public class GameConfig
  {
    [JsonPropertyName("identity")]
    public string? Identity { get; set; } = null;

    [JsonPropertyName("appendidentity")]
    public bool AppendIdentity { get; set; } = false;

    [JsonPropertyName("version")]
    public string Version { get; set; } = "11.4"; // Default to LÖVE 11.4

    [JsonPropertyName("console")]
    public bool Console { get; set; } = false;

    [JsonPropertyName("accelerometerjoystick")]
    public bool AccelerometerJoystick { get; set; } = true;

    [JsonPropertyName("externalstorage")]
    public bool ExternalStorage { get; set; } = false;

    [JsonPropertyName("gammacorrect")]
    public bool GammaCorrect { get; set; } = false;

    [JsonPropertyName("audio")]
    public AudioConfig Audio { get; set; } = new AudioConfig();

    [JsonPropertyName("window")]
    public WindowConfig Window { get; set; } = new WindowConfig();

    [JsonPropertyName("modules")]
    public ModulesConfig Modules { get; set; } = new ModulesConfig();
  }

  public class AudioConfig
  {
    [JsonPropertyName("mic")]
    public bool Mic { get; set; } = false;

    [JsonPropertyName("mixwithsystem")]
    public bool MixWithSystem { get; set; } = true;
  }

  public class WindowConfig
  {
    [JsonPropertyName("title")]
    public string Title { get; set; } = "Untitled";

    [JsonPropertyName("icon")]
    public string? Icon { get; set; } = null;

    [JsonPropertyName("width")]
    public int Width { get; set; } = 800;

    [JsonPropertyName("height")]
    public int Height { get; set; } = 600;

    [JsonPropertyName("borderless")]
    public bool Borderless { get; set; } = false;

    [JsonPropertyName("resizable")]
    public bool Resizable { get; set; } = false;

    [JsonPropertyName("minwidth")]
    public int MinWidth { get; set; } = 1;

    [JsonPropertyName("minheight")]
    public int MinHeight { get; set; } = 1;

    [JsonPropertyName("fullscreen")]
    public bool Fullscreen { get; set; } = false;

    [JsonPropertyName("fullscreentype")]
    public string FullscreenType { get; set; } = "desktop"; // "desktop" or "exclusive"

    [JsonPropertyName("vsync")]
    public int VSync { get; set; } = 1; // -1 adaptive, 0 disabled, 1 enabled

    [JsonPropertyName("msaa")]
    public int MSAA { get; set; } = 0;

    [JsonPropertyName("depth")]
    public int? Depth { get; set; } = null;

    [JsonPropertyName("stencil")]
    public int? Stencil { get; set; } = null;

    [JsonPropertyName("display")]
    public int Display { get; set; } = 1; // 1-indexed

    [JsonPropertyName("highdpi")]
    public bool HighDPI { get; set; } = false;

    [JsonPropertyName("usedpiscale")]
    public bool UseDPIScale { get; set; } = true;

    [JsonPropertyName("x")]
    public int? X { get; set; } = null;

    [JsonPropertyName("y")]
    public int? Y { get; set; } = null;
  }

  public class ModulesConfig
  {
    // TODO: Implement actual module enabling/disabling based on these flags.
    // For now, they are just placeholders. love.filesystem, love.data, and love (Night core) are mandatory.
    // love.graphics needs love.window.
    [JsonPropertyName("audio")]
    public bool Audio { get; set; } = true;

    [JsonPropertyName("data")]
    public bool Data { get; set; } = true; // Mandatory in LÖVE

    [JsonPropertyName("event")]
    public bool Event { get; set; } = true;

    [JsonPropertyName("font")]
    public bool Font { get; set; } = true;

    [JsonPropertyName("graphics")]
    public bool Graphics { get; set; } = true; // Needs Window

    [JsonPropertyName("image")]
    public bool Image { get; set; } = true;

    [JsonPropertyName("joystick")]
    public bool Joystick { get; set; } = true;

    [JsonPropertyName("keyboard")]
    public bool Keyboard { get; set; } = true;

    [JsonPropertyName("math")]
    public bool Math { get; set; } = true;

    [JsonPropertyName("mouse")]
    public bool Mouse { get; set; } = true;

    [JsonPropertyName("physics")]
    public bool Physics { get; set; } = true;

    [JsonPropertyName("sound")]
    public bool Sound { get; set; } = true;

    [JsonPropertyName("system")]
    public bool System { get; set; } = true;

    [JsonPropertyName("thread")]
    public bool Thread { get; set; } = true;

    [JsonPropertyName("timer")]
    public bool Timer { get; set; } = true;

    [JsonPropertyName("touch")]
    public bool Touch { get; set; } = true;

    [JsonPropertyName("video")]
    public bool Video { get; set; } = true;

    [JsonPropertyName("window")]
    public bool Window { get; set; } = true; // Mandatory for Graphics
  }
}



================================================
File: src/Night/Engine/.gitkeep
================================================



================================================
File: src/Night/Filesystem/Enums.cs
================================================
// <copyright file="Enums.cs" company="PlaceholderCompany">
// Copyright (c) PlaceholderCompany. All rights reserved.
// </copyright>

using System;

namespace Night
{
  /// <summary>
  /// Represents the type of a file system object.
  /// </summary>
  public enum FileType
  {
    /// <summary>
    /// A regular file.
    /// </summary>
    File,

    /// <summary>
    /// A directory.
    /// </summary>
    Directory,

    /// <summary>
    /// A symbolic link.
    /// </summary>
    Symlink,

    /// <summary>
    /// Other type (e.g., device, pipe).
    /// </summary>
    Other,

    /// <summary>
    /// The path does not exist or its type cannot be determined.
    /// </summary>
    None,
  }

  /// <summary>
  /// Represents the different modes you can open a File in.
  /// </summary>
  public enum FileMode
  {
    /// <summary>
    /// Open a file for read.
    /// </summary>
    Read,

    /// <summary>
    /// Open a file for write.
    /// </summary>
    Write,

    /// <summary>
    /// Open a file for append.
    /// </summary>
    Append,

    /// <summary>
    /// Do not open a file (represents a closed file.)
    /// </summary>
    Close,

    /// <summary>
    /// Open a file for write.
    /// </summary>
    W = Write,

    /// <summary>
    /// Open a file for read.
    /// </summary>
    R = Read,

    /// <summary>
    /// Open a file for append.
    /// </summary>
    A = Append,

    /// <summary>
    /// Do not open a file (represents a closed file.)
    /// </summary>
    C = Close,
  }
}



================================================
File: src/Night/Filesystem/Filesystem.cs
================================================
// <copyright file="Filesystem.cs" company="PlaceholderCompany">
// Copyright (c) PlaceholderCompany. All rights reserved.
// </copyright>

using System;
using System.IO;

namespace Night
{
  /// <summary>
  /// Provides basic file system operations.
  /// Inspired by Love2D's love.filesystem module.
  /// </summary>
  public static class Filesystem
  {
    /// <summary>
    /// Gets information about the specified file or directory.
    /// </summary>
    /// <param name="path">The file or directory path to check.</param>
    /// <param name="filterType">If supplied, this parameter causes getInfo to only return the info table if the item at the given path matches the specified file type.</param>
    /// <returns>A FileSystemInfo object containing information about the specified path, or null if nothing exists at the path or if it doesn't match the filterType.</returns>
    public static FileSystemInfo? GetInfo(string path, FileType? filterType = null)
    {
      if (string.IsNullOrEmpty(path))
      {
        return null;
      }

      long? size = null;
      FileType type;
      long? modTime;
      try
      {
        if (File.Exists(path))
        {
          var fileInfo = new FileInfo(path);
          if ((fileInfo.Attributes & FileAttributes.ReparsePoint) == FileAttributes.ReparsePoint)
          {
            type = FileType.Symlink;
          }
          else
          {
            type = FileType.File;
          }

          size = fileInfo.Length;
          modTime = ((DateTimeOffset)fileInfo.LastWriteTimeUtc).ToUnixTimeSeconds();
        }
        else if (Directory.Exists(path))
        {
          var dirInfo = new DirectoryInfo(path);
          if ((dirInfo.Attributes & FileAttributes.ReparsePoint) == FileAttributes.ReparsePoint)
          {
            type = FileType.Symlink;
          }
          else
          {
            type = FileType.Directory;
          }

          modTime = ((DateTimeOffset)dirInfo.LastWriteTimeUtc).ToUnixTimeSeconds();
        }
        else
        {
          return null;
        }
      }
      catch (Exception)
      {
        return null;
      }

      if (filterType.HasValue && type != filterType.Value)
      {
        return null;
      }

      return new FileSystemInfo(type, size, modTime);
    }

    /// <summary>
    /// Gets information about the specified file or directory and populates an existing FileSystemInfo object.
    /// </summary>
    /// <param name="path">The file or directory path to check.</param>
    /// <param name="info">A FileSystemInfo object which will be filled in.</param>
    /// <returns>The FileSystemInfo object given as an argument, filled with information, or null if nothing exists at the path.</returns>
    public static FileSystemInfo? GetInfo(string path, FileSystemInfo info)
    {
      if (info == null)
      {
        return null;
      }

      var newInfo = GetInfo(path);
      if (newInfo != null)
      {
        info.Type = newInfo.Type;
        info.Size = newInfo.Size;
        info.ModTime = newInfo.ModTime;
        return info;
      }

      return null;
    }

    /// <summary>
    /// Gets information about the specified file or directory, filtered by type, and populates an existing FileSystemInfo object.
    /// </summary>
    /// <param name="path">The file or directory path to check.</param>
    /// <param name="filterType">Causes getInfo to only return the info table if the item at the given path matches the specified file type.</param>
    /// <param name="info">A FileSystemInfo object which will be filled in.</param>
    /// <returns>The FileSystemInfo object given as an argument, filled with information, or null if nothing exists at the path or if it doesn't match the filterType.</returns>
    public static FileSystemInfo? GetInfo(string path, FileType filterType, FileSystemInfo info)
    {
      if (info == null)
      {
        return null;
      }

      var newInfo = GetInfo(path, filterType);
      if (newInfo != null)
      {
        info.Type = newInfo.Type;
        info.Size = newInfo.Size;
        info.ModTime = newInfo.ModTime;
        return info;
      }

      return null;
    }

    /// <summary>
    /// Reads the entire content of a file into a byte array.
    /// </summary>
    /// <param name="path">The path to the file to read.</param>
    /// <returns>A byte array containing the contents of the file.</returns>
    /// <exception cref="System.IO.FileNotFoundException">Thrown if the file is not found.</exception>
    public static byte[] ReadBytes(string path)
    {
      return File.ReadAllBytes(path);
    }

    /// <summary>
    /// Reads the entire content of a file into a string.
    /// </summary>
    /// <param name="path">The path to the file to read.</param>
    /// <returns>A string containing the contents of the file.</returns>
    /// <exception cref="System.IO.FileNotFoundException">Thrown if the file is not found.</exception>
    public static string ReadText(string path)
    {
      return File.ReadAllText(path);
    }
  }
}



================================================
File: src/Night/Filesystem/Types.cs
================================================
// <copyright file="Types.cs" company="PlaceholderCompany">
// Copyright (c) PlaceholderCompany. All rights reserved.
// </copyright>

using System;

namespace Night
{
  /// <summary>
  /// Contains information about a file or directory.
  /// </summary>
  public class FileSystemInfo
  {
    /// <summary>
    /// Gets or sets the type of the object at the path (file, directory, symlink, etc.).
    /// Default is None.
    /// </summary>
    public FileType Type { get; set; } = FileType.None;

    /// <summary>
    /// Gets or sets the size in bytes of the file, or null if it can't be determined or not applicable (e.g. for a directory).
    /// </summary>
    public long? Size { get; set; }

    /// <summary>
    /// Gets or sets the file's last modification time in seconds since the Unix epoch, or null if it can't be determined.
    /// </summary>
    public long? ModTime { get; set; }

    /// <summary>
    /// Initializes a new instance of the <see cref="FileSystemInfo"/> class.
    /// </summary>
    public FileSystemInfo()
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="FileSystemInfo"/> class with specified values.
    /// </summary>
    /// <param name="type">The type of the file system object.</param>
    /// <param name="size">The size of the file in bytes.</param>
    /// <param name="modTime">The last modification time in Unix epoch seconds.</param>
    public FileSystemInfo(FileType type, long? size, long? modTime)
    {
      this.Type = type;
      this.Size = size;
      this.ModTime = modTime;
    }
  }
}



================================================
File: src/Night/Graphics/Enums.cs
================================================
// <copyright file="Enums.cs" company="PlaceholderCompany">
// Copyright (c) PlaceholderCompany. All rights reserved.
// </copyright>

using System;

namespace Night
{
  /// <summary>
  /// Specifies whether a shape should be drawn filled or as an outline.
  /// </summary>
  public enum DrawMode
  {
    /// <summary>
    /// Draw the shape filled.
    /// </summary>
    Fill,

    /// <summary>
    /// Draw the shape as an outline.
    /// </summary>
    Line,
  }
}



================================================
File: src/Night/Graphics/Graphics.cs
================================================
// <copyright file="Graphics.cs" company="PlaceholderCompany">
// Copyright (c) PlaceholderCompany. All rights reserved.
// </copyright>

using System;
using System.IO;
using System.Runtime.InteropServices;

using Night;

using SDL3;

namespace Night
{
  /// <summary>
  /// Provides functionality for drawing graphics.
  /// Mimics Love2D's love.graphics module.
  /// </summary>
  public static class Graphics
  {
    /// <summary>
    /// Creates a new image (Sprite) from a file.
    /// </summary>
    /// <param name="filePath">The path to the image file.</param>
    /// <returns>A new Sprite object.</returns>
    public static Sprite? NewImage(string filePath)
    {
      IntPtr rendererPtr = Window.RendererPtr;
      if (rendererPtr == IntPtr.Zero)
      {
        Console.WriteLine("Error in Graphics.NewImage: Renderer pointer is null. Was Window.SetMode called successfully?");
        return null;
      }

      if (!File.Exists(filePath))
      {
        Console.WriteLine($"Error in Graphics.NewImage: Image file not found at '{filePath}'.");
        return null;
      }

      IntPtr surfacePtr = SDL3.Image.Load(filePath);

      if (surfacePtr == IntPtr.Zero)
      {
        string sdlError = SDL.GetError();
        Console.WriteLine($"Error in Graphics.NewImage: Failed to load image into surface from '{filePath}'. SDL_image Error: {sdlError}");
        return null;
      }

      SDL.Surface surface = Marshal.PtrToStructure<SDL.Surface>(surfacePtr);
      int width = surface.Width;
      int height = surface.Height;

      if (width <= 0 || height <= 0)
      {
        Console.WriteLine($"Error: Invalid surface dimensions ({width}x{height}) for '{filePath}'.");
        SDL.DestroySurface(surfacePtr);
        return null;
      }

      IntPtr texturePtr = SDL.CreateTextureFromSurface(rendererPtr, surfacePtr);
      SDL.DestroySurface(surfacePtr);

      if (texturePtr == IntPtr.Zero)
      {
        string sdlError = SDL.GetError();
        Console.WriteLine($"Error in Graphics.NewImage: Failed to create texture from surface for '{filePath}'. SDL Error: {sdlError}");
        return null;
      }

      return new Sprite(texturePtr, width, height);
    }

    /// <summary>
    /// Sets the active color for drawing operations.
    /// </summary>
    /// <param name="color">The color to set.</param>
    public static void SetColor(Color color)
    {
      IntPtr rendererPtr = Window.RendererPtr;
      if (rendererPtr == IntPtr.Zero)
      {
        Console.WriteLine("Error in Graphics.SetColor: Renderer pointer is null. Was Window.SetMode called successfully?");
        return;
      }

      if (!SDL.SetRenderDrawColor(rendererPtr, color.R, color.G, color.B, color.A))
      {
        string sdlError = SDL.GetError();
        Console.WriteLine($"Error in Graphics.SetColor (SetRenderDrawColor): {sdlError}");
      }
    }

    /// <summary>
    /// Sets the active color for drawing operations using individual RGBA components.
    /// </summary>
    /// <param name="r">The red component (0-255).</param>
    /// <param name="g">The green component (0-255).</param>
    /// <param name="b">The blue component (0-255).</param>
    /// <param name="a">The alpha component (0-255), defaults to 255 (opaque).</param>
    public static void SetColor(byte r, byte g, byte b, byte a = 255)
    {
      SetColor(new Color(r, g, b, a));
    }

    /// <summary>
    /// Draws a rectangle.
    /// </summary>
    /// <param name="mode">The drawing mode (Fill or Line).</param>
    /// <param name="x">The x-coordinate of the top-left corner.</param>
    /// <param name="y">The y-coordinate of the top-left corner.</param>
    /// <param name="width">The width of the rectangle.</param>
    /// <param name="height">The height of the rectangle.</param>
    public static void Rectangle(DrawMode mode, float x, float y, float width, float height)
    {
      IntPtr rendererPtr = Window.RendererPtr;
      if (rendererPtr == IntPtr.Zero)
      {
        Console.WriteLine("Error in Graphics.Rectangle: Renderer pointer is null. Was Window.SetMode called successfully?");
        return;
      }

      SDL.FRect rect = new SDL.FRect { X = x, Y = y, W = width, H = height };

      bool success;
      if (mode == DrawMode.Fill)
      {
        success = SDL.RenderFillRect(rendererPtr, rect);
      }
      else // GraphicsTypes.DrawMode.Line
      {
        success = SDL.RenderRect(rendererPtr, rect);
      }

      if (!success)
      {
        string sdlError = SDL.GetError();
        Console.WriteLine($"Error in Graphics.Rectangle (Mode: {mode}): {sdlError}");
      }
    }

    /// <summary>
    /// Draws a line segment between two points.
    /// </summary>
    /// <param name="x1">The x-coordinate of the first point.</param>
    /// <param name="y1">The y-coordinate of the first point.</param>
    /// <param name="x2">The x-coordinate of the second point.</param>
    /// <param name="y2">The y-coordinate of the second point.</param>
    public static void Line(float x1, float y1, float x2, float y2)
    {
      IntPtr rendererPtr = Window.RendererPtr;
      if (rendererPtr == IntPtr.Zero)
      {
        Console.WriteLine("Error in Graphics.Line: Renderer pointer is null. Was Window.SetMode called successfully?");
        return;
      }

      if (!SDL.RenderLine(rendererPtr, x1, y1, x2, y2))
      {
        string sdlError = SDL.GetError();
        Console.WriteLine($"Error in Graphics.Line: {sdlError}");
      }
    }

    /// <summary>
    /// Draws a sequence of connected line segments.
    /// </summary>
    /// <param name="points">An array of points to connect.</param>
    public static void Line(PointF[] points)
    {
      IntPtr rendererPtr = Window.RendererPtr;
      if (rendererPtr == IntPtr.Zero)
      {
        Console.WriteLine("Error in Graphics.Line (multiple points): Renderer pointer is null. Was Window.SetMode called successfully?");
        return;
      }

      if (points == null || points.Length < 2)
      {
        Console.WriteLine("Error in Graphics.Line (multiple points): At least two points are required to draw lines.");
        return;
      }

      SDL.FPoint[] sdlPoints = new SDL.FPoint[points.Length];
      for (int i = 0; i < points.Length; i++)
      {
        sdlPoints[i] = new SDL.FPoint { X = points[i].X, Y = points[i].Y };
      }

      if (!SDL.RenderLines(rendererPtr, sdlPoints, sdlPoints.Length))
      {
        string sdlError = SDL.GetError();
        Console.WriteLine($"Error in Graphics.Line (multiple points): {sdlError}");
      }
    }

    /// <summary>
    /// Draws a polygon.
    /// </summary>
    /// <param name="mode">The drawing mode (Fill or Line).</param>
    /// <param name="vertices">An array of points representing the polygon's vertices.</param>
    public static void Polygon(DrawMode mode, PointF[] vertices)
    {
      IntPtr rendererPtr = Window.RendererPtr;
      if (rendererPtr == IntPtr.Zero)
      {
        Console.WriteLine("Error in Graphics.Polygon: Renderer pointer is null. Was Window.SetMode called successfully?");
        return;
      }

      if (vertices == null || vertices.Length < 3)
      {
        Console.WriteLine("Error in Graphics.Polygon: At least three vertices are required to draw a polygon.");
        return;
      }

      if (mode == DrawMode.Line)
      {
        SDL.FPoint[] lineVertices = new SDL.FPoint[vertices.Length + 1];
        for (int i = 0; i < vertices.Length; i++)
        {
          lineVertices[i] = new SDL.FPoint { X = vertices[i].X, Y = vertices[i].Y };
        }

        lineVertices[vertices.Length] = new SDL.FPoint { X = vertices[0].X, Y = vertices[0].Y }; // Close the polygon

        if (!SDL.RenderLines(rendererPtr, lineVertices, lineVertices.Length))
        {
          string sdlError = SDL.GetError();
          Console.WriteLine($"Error in Graphics.Polygon (Line Mode): {sdlError}");
        }
      }
      else // GraphicsTypes.DrawMode.Fill
      {
        if (vertices.Length < 3)
        {
          return;
        }

        float[] xy = new float[vertices.Length * 2];
        SDL.FColor[] vertexColors = new SDL.FColor[vertices.Length];

        byte r, g, b, a;
        _ = SDL.GetRenderDrawColor(rendererPtr, out r, out g, out b, out a);
        SDL.FColor drawColor = new SDL.FColor { R = r / 255f, G = g / 255f, B = b / 255f, A = a / 255f };

        for (int i = 0; i < vertices.Length; i++)
        {
          xy[i * 2] = vertices[i].X;
          xy[(i * 2) + 1] = vertices[i].Y;
          vertexColors[i] = drawColor;
        }

        byte[] indices = new byte[(vertices.Length - 2) * 3];
        for (int i = 0; i < vertices.Length - 2; i++)
        {
          indices[i * 3] = 0;
          indices[(i * 3) + 1] = (byte)(i + 1);
          indices[(i * 3) + 2] = (byte)(i + 2);
        }

        GCHandle xyHandle = default;
        GCHandle colorsHandle = default;
        GCHandle indicesHandle = default;

        try
        {
          xyHandle = GCHandle.Alloc(xy, GCHandleType.Pinned);
          colorsHandle = GCHandle.Alloc(vertexColors, GCHandleType.Pinned);
          indicesHandle = GCHandle.Alloc(indices, GCHandleType.Pinned);

          IntPtr xyPtr = xyHandle.AddrOfPinnedObject();
          IntPtr colorsPtr = colorsHandle.AddrOfPinnedObject();
          IntPtr indicesPtr = indicesHandle.AddrOfPinnedObject();

          if (!SDL.RenderGeometryRaw(rendererPtr, IntPtr.Zero, // texture
                                     xyPtr, sizeof(float) * 2, // xy, xy_stride
                                     colorsPtr, Marshal.SizeOf<SDL.FColor>(), // colors, color_stride
                                     IntPtr.Zero, 0, // tex_coords, tex_coord_stride
                                     vertices.Length, // num_vertices
                                     indicesPtr, indices.Length, sizeof(byte))) // indices, num_indices, index_type (sizeof(byte) for byte indices)
          {
            string sdlError = SDL.GetError();
            Console.WriteLine($"Error in Graphics.Polygon (Fill Mode - RenderGeometryRaw): {sdlError}");
          }
        }
        finally
        {
          if (xyHandle.IsAllocated)
          {
            xyHandle.Free();
          }

          if (colorsHandle.IsAllocated)
          {
            colorsHandle.Free();
          }

          if (indicesHandle.IsAllocated)
          {
            indicesHandle.Free();
          }
        }
      }
    }

    /// <summary>
    /// Draws a circle.
    /// </summary>
    /// <param name="mode">The drawing mode (Fill or Line).</param>
    /// <param name="x">The x-coordinate of the circle's center.</param>
    /// <param name="y">The y-coordinate of the circle's center.</param>
    /// <param name="radius">The radius of the circle.</param>
    /// <param name="segments">The number of segments to use to approximate the circle. More segments result in a smoother circle.</param>
    public static void Circle(DrawMode mode, float x, float y, float radius, int segments = 12)
    {
      if (radius <= 0)
      {
        Console.WriteLine("Error in Graphics.Circle: Radius must be positive.");
        return;
      }

      if (segments < 3)
      {
        Console.WriteLine("Error in Graphics.Circle: Segments must be 3 or greater.");
        return;
      }

      PointF[] circleVertices = new PointF[segments];
      double angleStep = 2.0 * Math.PI / segments;

      for (int i = 0; i < segments; i++)
      {
        double currentAngle = i * angleStep;
        float vertX = x + (radius * (float)Math.Cos(currentAngle));
        float vertY = y + (radius * (float)Math.Sin(currentAngle));
        circleVertices[i] = new PointF(vertX, vertY);
      }

      Polygon(mode, circleVertices);
    }

    /// <summary>
    /// Draws a sprite to the screen.
    /// </summary>
    /// <param name="sprite">The sprite to draw.</param>
    /// <param name="x">The x-coordinate to draw the sprite at.</param>
    /// <param name="y">The y-coordinate to draw the sprite at.</param>
    /// <param name="rotation">The rotation of the sprite (in radians).</param>
    /// <param name="scaleX">The horizontal scale factor.</param>
    /// <param name="scaleY">The vertical scale factor.</param>
    /// <param name="offsetX">The x-offset for the sprite's origin.</param>
    /// <param name="offsetY">The y-offset for the sprite's origin.</param>
    public static void Draw(
        Sprite sprite,
        float x,
        float y,
        float rotation = 0,
        float scaleX = 1,
        float scaleY = 1,
        float offsetX = 0,
        float offsetY = 0)
    {
      IntPtr rendererPtr = Window.RendererPtr;
      if (rendererPtr == IntPtr.Zero)
      {
        Console.WriteLine("Error in Graphics.Draw: Renderer pointer is null. Was Window.SetMode called successfully?");
        return;
      }

      if (sprite == null || sprite.Texture == IntPtr.Zero)
      {
        Console.WriteLine("Error in Graphics.Draw: Sprite or sprite texture is null.");
        return;
      }

      SDL.FRect dstRectStruct = new SDL.FRect
      {
        X = x,
        Y = y,
        W = sprite.Width * scaleX,
        H = sprite.Height * scaleY,
      };

      SDL.FPoint centerPointStruct = new SDL.FPoint
      {
        X = offsetX * scaleX,
        Y = offsetY * scaleY,
      };

      double angleInDegrees = rotation * (180.0 / Math.PI);

      IntPtr dstRectPtr = IntPtr.Zero;
      IntPtr centerPointPtr = IntPtr.Zero;

      try
      {
        dstRectPtr = Marshal.AllocHGlobal(Marshal.SizeOf(dstRectStruct));
        Marshal.StructureToPtr(dstRectStruct, dstRectPtr, false);

        centerPointPtr = Marshal.AllocHGlobal(Marshal.SizeOf(centerPointStruct));
        Marshal.StructureToPtr(centerPointStruct, centerPointPtr, false);

        if (!SDL.RenderTextureRotated(rendererPtr, sprite.Texture, IntPtr.Zero, dstRectPtr, angleInDegrees, centerPointPtr, SDL.FlipMode.None))
        {
          string sdlError = SDL.GetError();
          Console.WriteLine($"Error in Graphics.Draw (RenderTextureRotated): {sdlError}");
        }
      }
      finally
      {
        if (dstRectPtr != IntPtr.Zero)
        {
          Marshal.FreeHGlobal(dstRectPtr);
        }

        if (centerPointPtr != IntPtr.Zero)
        {
          Marshal.FreeHGlobal(centerPointPtr);
        }
      }
    }

    /// <summary>
    /// Clears the screen to a specific color.
    /// </summary>
    /// <param name="color">The color to clear the screen with.</param>
    public static void Clear(Color color)
    {
      IntPtr rendererPtr = Window.RendererPtr;
      if (rendererPtr == IntPtr.Zero)
      {
        Console.WriteLine("Error in Graphics.Clear: Renderer pointer is null. Was Window.SetMode called successfully?");
        return;
      }

      if (!SDL.SetRenderDrawColor(rendererPtr, color.R, color.G, color.B, color.A))
      {
        string sdlError = SDL.GetError();
        Console.WriteLine($"Error in Graphics.Clear (SetRenderDrawColor): {sdlError}");
      }

      if (!SDL.RenderClear(rendererPtr))
      {
        string sdlError = SDL.GetError();
        Console.WriteLine($"Error in Graphics.Clear (RenderClear): {sdlError}");
      }
    }

    /// <summary>
    /// Presents the drawn graphics to the screen (swaps buffers).
    /// </summary>
    public static void Present()
    {
      IntPtr rendererPtr = Window.RendererPtr;
      if (rendererPtr == IntPtr.Zero)
      {
        Console.WriteLine("Error in Graphics.Present: Renderer pointer is null. Was Window.SetMode called successfully?");
        return;
      }

      if (!SDL.RenderPresent(rendererPtr))
      {
        string sdlError = SDL.GetError();
        Console.WriteLine($"Error in Graphics.Present (RenderPresent): {sdlError}");
      }
    }
  }
}



================================================
File: src/Night/Graphics/Structs.cs
================================================
// <copyright file="Structs.cs" company="PlaceholderCompany">
// Copyright (c) PlaceholderCompany. All rights reserved.
// </copyright>

using System;

namespace Night
{
  /// <summary>
  /// Represents a color with Red, Green, Blue, and Alpha components. Implements Love2D's RGBA color table.
  /// Each component is a byte value ranging from 0 to 255.
  /// The Alpha component controls the transparency of the color, where 0 is fully transparent and 255 is fully opaque.
  /// </summary>
  public struct Color
  {
    public byte R;
    public byte G;
    public byte B;
    public byte A;

    public Color(byte r, byte g, byte b, byte a = 255)
    {
      this.R = r;
      this.G = g;
      this.B = b;
      this.A = a;
    }

    // Common color presets
    public static readonly Color Black = new(0, 0, 0);
    public static readonly Color White = new(255, 255, 255);
    public static readonly Color Red = new(255, 0, 0);
    public static readonly Color Green = new(0, 255, 0);
    public static readonly Color Blue = new(0, 0, 255);
    public static readonly Color Yellow = new(255, 255, 0);
    public static readonly Color Magenta = new(255, 0, 255);
    public static readonly Color Cyan = new(0, 255, 255);
    public static readonly Color Transparent = new(0, 0, 0, 0);
  }

  /// <summary>
  /// Represents a rectangle with position (X, Y) and dimensions (Width, Height).
  /// </summary>
  public struct Rectangle
  {
    public int X;
    public int Y;
    public int Width;
    public int Height;

    public Rectangle(int x, int y, int width, int height)
    {
      this.X = x;
      this.Y = y;
      this.Width = width;
      this.Height = height;
    }
  }

  /// <summary>
  /// Represents a 2D point with floating-point coordinates.
  /// </summary>
  public struct PointF
  {
    public float X;
    public float Y;

    public PointF(float x, float y)
    {
      this.X = x;
      this.Y = y;
    }
  }
}



================================================
File: src/Night/Graphics/Types.cs
================================================
// <copyright file="Types.cs" company="PlaceholderCompany">
// Copyright (c) PlaceholderCompany. All rights reserved.
// </copyright>

using System;

namespace Night
{
  /// <summary>
  /// Represents a 2D sprite, typically an image loaded into a texture.
  /// </summary>
  public class Sprite
  {
    /// <summary>
    /// Gets the SDL texture handle.
    /// </summary>
    public IntPtr Texture { get; }

    /// <summary>
    /// Gets the width of the sprite in pixels.
    /// </summary>
    public int Width { get; }

    /// <summary>
    /// Gets the height of the sprite in pixels.
    /// </summary>
    public int Height { get; }

    /// <summary>
    /// Initializes a new instance of the <see cref="Sprite"/> class.
    /// </summary>
    /// <param name="texture">The SDL texture handle.</param>
    /// <param name="width">The width of the texture.</param>
    /// <param name="height">The height of the texture.</param>
    public Sprite(IntPtr texture, int width, int height)
    {
      this.Texture = texture;
      this.Width = width;
      this.Height = height;
    }
  }
}



================================================
File: src/Night/Keyboard/Enums.cs
================================================
// <copyright file="Enums.cs" company="PlaceholderCompany">
// Copyright (c) PlaceholderCompany. All rights reserved.
// </copyright>

using System;

using SDL3;

namespace Night
{
  /// <summary>
  /// Represents keyboard keys. Values correspond to SDL_Scancode.
  /// </summary>
  /// <remarks>
  /// See SDL_scancode.h for the full list of SDL_Scancode values.
  /// This enum maps directly to SDL_Scancode values.
  /// </remarks>
  public enum KeyCode
  {
    Unknown = 0, // SDL.Scancode.Unknown

    // Letters
    A = 4,  // SDL.Scancode.A
    B = 5,  // SDL.Scancode.B
    C = 6,  // SDL.Scancode.C
    D = 7,  // SDL.Scancode.D
    E = 8,  // SDL.Scancode.E
    F = 9,  // SDL.Scancode.F
    G = 10, // SDL.Scancode.G
    H = 11, // SDL.Scancode.H
    I = 12, // SDL.Scancode.I
    J = 13, // SDL.Scancode.J
    K = 14, // SDL.Scancode.K
    L = 15, // SDL.Scancode.L
    M = 16, // SDL.Scancode.M
    N = 17, // SDL.Scancode.N
    O = 18, // SDL.Scancode.O
    P = 19, // SDL.Scancode.P
    Q = 20, // SDL.Scancode.Q
    R = 21, // SDL.Scancode.R
    S = 22, // SDL.Scancode.S
    T = 23, // SDL.Scancode.T
    U = 24, // SDL.Scancode.U
    V = 25, // SDL.Scancode.V
    W = 26, // SDL.Scancode.W
    X = 27, // SDL.Scancode.X
    Y = 28, // SDL.Scancode.Y
    Z = 29, // SDL.Scancode.Z

    // Numbers (Top row)
    Alpha1 = 30, // SDL.Scancode.Alpha1
    Alpha2 = 31, // SDL.Scancode.Alpha2
    Alpha3 = 32, // SDL.Scancode.Alpha3
    Alpha4 = 33, // SDL.Scancode.Alpha4
    Alpha5 = 34, // SDL.Scancode.Alpha5
    Alpha6 = 35, // SDL.Scancode.Alpha6
    Alpha7 = 36, // SDL.Scancode.Alpha7
    Alpha8 = 37, // SDL.Scancode.Alpha8
    Alpha9 = 38, // SDL.Scancode.Alpha9
    Alpha0 = 39, // SDL.Scancode.Alpha0

    // Control keys
    Return = 40,       // SDL.Scancode.Return
    Escape = 41,      // SDL.Scancode.Escape
    Backspace = 42,   // SDL.Scancode.Backspace
    Tab = 43,         // SDL.Scancode.Tab
    Space = 44,       // SDL.Scancode.Space
    Minus = 45,       // SDL.Scancode.Minus
    Equals = 46,      // SDL.Scancode.Equals
    Leftbracket = 47, // SDL.Scancode.Leftbracket
    Rightbracket = 48, // SDL.Scancode.Rightbracket
    Backslash = 49,   // SDL.Scancode.Backslash
    NonUshash = 50,   // SDL.Scancode.NonUshash
    Semicolon = 51,   // SDL.Scancode.Semicolon
    Apostrophe = 52,  // SDL.Scancode.Apostrophe
    Grave = 53,       // SDL.Scancode.Grave
    Comma = 54,       // SDL.Scancode.Comma
    Period = 55,      // SDL.Scancode.Period
    Slash = 56,       // SDL.Scancode.Slash
    Capslock = 57,    // SDL.Scancode.Capslock

    // Function keys
    F1 = 58,  // SDL.Scancode.F1
    F2 = 59,  // SDL.Scancode.F2
    F3 = 60,  // SDL.Scancode.F3
    F4 = 61,  // SDL.Scancode.F4
    F5 = 62,  // SDL.Scancode.F5
    F6 = 63,  // SDL.Scancode.F6
    F7 = 64,  // SDL.Scancode.F7
    F8 = 65,  // SDL.Scancode.F8
    F9 = 66,  // SDL.Scancode.F9
    F10 = 67, // SDL.Scancode.F10
    F11 = 68, // SDL.Scancode.F11
    F12 = 69, // SDL.Scancode.F12

    Printscreen = 70, // SDL.Scancode.Printscreen
    Scrolllock = 71,  // SDL.Scancode.Scrolllock
    Pause = 72,       // SDL.Scancode.Pause
    Insert = 73,      // SDL.Scancode.Insert
    Home = 74,        // SDL.Scancode.Home
    Pageup = 75,      // SDL.Scancode.Pageup
    Delete = 76,      // SDL.Scancode.Delete
    End = 77,         // SDL.Scancode.End
    Pagedown = 78,    // SDL.Scancode.Pagedown

    // Arrow keys
    Right = 79, // SDL.Scancode.Right
    Left = 80,  // SDL.Scancode.Left
    Down = 81,  // SDL.Scancode.Down
    Up = 82,    // SDL.Scancode.Up

    NumlockClear = 83, // SDL.Scancode.NumlockClear

    // Keypad
    KpDivide = 84,   // SDL.Scancode.KpDivide
    KpMultiply = 85, // SDL.Scancode.KpMultiply
    KpMinus = 86,    // SDL.Scancode.KpMinus
    KpPlus = 87,     // SDL.Scancode.KpPlus
    KpEnter = 88,    // SDL.Scancode.KpEnter
    Kp1 = 89,        // SDL.Scancode.Kp1
    Kp2 = 90,        // SDL.Scancode.Kp2
    Kp3 = 91,        // SDL.Scancode.Kp3
    Kp4 = 92,        // SDL.Scancode.Kp4
    Kp5 = 93,        // SDL.Scancode.Kp5
    Kp6 = 94,        // SDL.Scancode.Kp6
    Kp7 = 95,        // SDL.Scancode.Kp7
    Kp8 = 96,        // SDL.Scancode.Kp8
    Kp9 = 97,        // SDL.Scancode.Kp9
    Kp0 = 98,        // SDL.Scancode.Kp0
    KpPeriod = 99,   // SDL.Scancode.KpPeriod

    NonUsbackslash = 100, // SDL.Scancode.NonUsbackslash
    Application = 101,    // SDL.Scancode.Application
    Power = 102,          // SDL.Scancode.Power

    KpEquals = 103, // SDL.Scancode.KpEquals
    F13 = 104,      // SDL.Scancode.F13
    F14 = 105,      // SDL.Scancode.F14
    F15 = 106,      // SDL.Scancode.F15
    F16 = 107,      // SDL.Scancode.F16
    F17 = 108,      // SDL.Scancode.F17
    F18 = 109,      // SDL.Scancode.F18
    F19 = 110,      // SDL.Scancode.F19
    F20 = 111,      // SDL.Scancode.F20
    F21 = 112,      // SDL.Scancode.F21
    F22 = 113,      // SDL.Scancode.F22
    F23 = 114,      // SDL.Scancode.F23
    F24 = 115,      // SDL.Scancode.F24

    Execute = 116, // SDL.Scancode.Execute
    Help = 117,    // SDL.Scancode.Help
    Menu = 118,    // SDL.Scancode.Menu
    Select = 119,  // SDL.Scancode.Select
    Stop = 120,    // SDL.Scancode.Stop
    Again = 121,   // SDL.Scancode.Again
    Undo = 122,    // SDL.Scancode.Undo
    Cut = 123,     // SDL.Scancode.Cut
    Copy = 124,    // SDL.Scancode.Copy
    Paste = 125,   // SDL.Scancode.Paste
    Find = 126,    // SDL.Scancode.Find
    Mute = 127,    // SDL.Scancode.Mute
    VolumeUp = 128,   // SDL.Scancode.VolumeUp
    VolumeDown = 129, // SDL.Scancode.VolumeDown

    KpComma = 133, // SDL.Scancode.KpComma

    // Modifier keys
    LCtrl = 224,   // SDL.Scancode.LCtrl
    LShift = 225,  // SDL.Scancode.LShift
    LAlt = 226,    // SDL.Scancode.LAlt
    LGUI = 227,  // SDL.Scancode.LGUI
    RCtrl = 228,  // SDL.Scancode.RCtrl
    RShift = 229, // SDL.Scancode.RShift
    RAlt = 230,   // SDL.Scancode.RAlt
    RGUI = 231, // SDL.Scancode.RGUI

    Mode = 257, // SDL.Scancode.Mode

    // Media keys (subset)
    MediaPlay = 262,        // SDL.Scancode.MediaPlay
    MediaPause = 263,       // SDL.Scancode.MediaPause
    MediaRecord = 264,      // SDL.Scancode.MediaRecord
    MediaFastForward = 265, // SDL.Scancode.MediaFastForward
    MediaRewind = 266,      // SDL.Scancode.MediaRewind
    MediaNextTrack = 267,   // SDL.Scancode.MediaNextTrack
    MediaPreviousTrack = 268, // SDL.Scancode.MediaPreviousTrack
    MediaStop = 269,        // SDL.Scancode.MediaStop
    MediaEject = 270,       // SDL.Scancode.MediaEject
    MediaPlayPause = 271,   // SDL.Scancode.MediaPlayPause
    MediaSelect = 272,      // SDL.Scancode.MediaSelect

    // Application control keys (subset)
    AppSearch = 280,     // SDL.Scancode.AppSearch
    AppHome = 281,       // SDL.Scancode.AppHome
    AppBack = 282,       // SDL.Scancode.AppBack
    AppForward = 283,    // SDL.Scancode.AppForward
    AppStop = 284,       // SDL.Scancode.AppStop
    AppRefresh = 285,    // SDL.Scancode.AppRefresh
    AppBookmarks = 286,  // SDL.Scancode.AppBookmarks
  }

  /// <summary>
  /// Represents logical key symbols. Values correspond to SDL_Keycode.
  /// </summary>
  /// <remarks>
  /// This enum maps to SDL_Keycode values, representing the symbol produced by a key press
  /// under the current keyboard layout.
  /// </remarks>
  public enum KeySymbol : uint // Explicitly set underlying type to uint
  {
    Unknown = SDL.Keycode.Unknown,

    // Letters (match SDL.Keycode values, which are ASCII for letters)
    A = SDL.Keycode.A,
    B = SDL.Keycode.B,
    C = SDL.Keycode.C,
    D = SDL.Keycode.D,
    E = SDL.Keycode.E,
    F = SDL.Keycode.F,
    G = SDL.Keycode.G,
    H = SDL.Keycode.H,
    I = SDL.Keycode.I,
    J = SDL.Keycode.J,
    K = SDL.Keycode.K,
    L = SDL.Keycode.L,
    M = SDL.Keycode.M,
    N = SDL.Keycode.N,
    O = SDL.Keycode.O,
    P = SDL.Keycode.P,
    Q = SDL.Keycode.Q,
    R = SDL.Keycode.R,
    S = SDL.Keycode.S,
    T = SDL.Keycode.T,
    U = SDL.Keycode.U,
    V = SDL.Keycode.V,
    W = SDL.Keycode.W,
    X = SDL.Keycode.X,
    Y = SDL.Keycode.Y,
    Z = SDL.Keycode.Z,

    // Numbers (Top row - match SDL.Keycode values, which are ASCII for numbers)
    Alpha0 = SDL.Keycode.Alpha0,
    Alpha1 = SDL.Keycode.Alpha1,
    Alpha2 = SDL.Keycode.Alpha2,
    Alpha3 = SDL.Keycode.Alpha3,
    Alpha4 = SDL.Keycode.Alpha4,
    Alpha5 = SDL.Keycode.Alpha5,
    Alpha6 = SDL.Keycode.Alpha6,
    Alpha7 = SDL.Keycode.Alpha7,
    Alpha8 = SDL.Keycode.Alpha8,
    Alpha9 = SDL.Keycode.Alpha9,

    // Common control keys
    Return = SDL.Keycode.Return,
    Escape = SDL.Keycode.Escape,
    Backspace = SDL.Keycode.Backspace,
    Tab = SDL.Keycode.Tab,
    Space = SDL.Keycode.Space,

    // Punctuation (example, more can be added)
    Minus = SDL.Keycode.Minus,
    Equals = SDL.Keycode.Equals,
    Leftbracket = SDL.Keycode.LeftBracket,
    Rightbracket = SDL.Keycode.RightBracket,
    Backslash = SDL.Keycode.Backslash,
    Semicolon = SDL.Keycode.Semicolon,
    Apostrophe = SDL.Keycode.Apostrophe,
    Grave = SDL.Keycode.Grave,
    Comma = SDL.Keycode.Comma,
    Period = SDL.Keycode.Period,
    Slash = SDL.Keycode.Slash,

    // Function keys
    F1 = SDL.Keycode.F1,
    F2 = SDL.Keycode.F2,
    F3 = SDL.Keycode.F3,
    F4 = SDL.Keycode.F4,
    F5 = SDL.Keycode.F5,
    F6 = SDL.Keycode.F6,
    F7 = SDL.Keycode.F7,
    F8 = SDL.Keycode.F8,
    F9 = SDL.Keycode.F9,
    F10 = SDL.Keycode.F10,
    F11 = SDL.Keycode.F11,
    F12 = SDL.Keycode.F12,

    // Arrow keys
    Right = SDL.Keycode.Right,
    Left = SDL.Keycode.Left,
    Down = SDL.Keycode.Down,
    Up = SDL.Keycode.Up,

    // Modifiers
    LCtrl = SDL.Keycode.LCtrl,
    LShift = SDL.Keycode.LShift,
    LAlt = SDL.Keycode.LAlt,
    LGUI = SDL.Keycode.LGui,
    RCtrl = SDL.Keycode.RCtrl,
    RShift = SDL.Keycode.RShift,
    RAlt = SDL.Keycode.RAlt,
    RGUI = SDL.Keycode.RGUI,
  }
}



================================================
File: src/Night/Keyboard/Keyboard.cs
================================================
// <copyright file="Keyboard.cs" company="PlaceholderCompany">
// Copyright (c) PlaceholderCompany. All rights reserved.
// </copyright>

using System;
using System.Runtime.InteropServices;

using Night;

using SDL3;

namespace Night
{

  /// <summary>
  /// Provides an interface to the user's keyboard.
  /// </summary>
  public static class Keyboard
  {
    /// <summary>
    /// Checks whether a certain key is down.
    /// </summary>
    /// <param name="key">The key to check.</param>
    /// <returns>True if the key is down, false otherwise.</returns>
    public static bool IsDown(KeyCode key)
    {
      if (!Framework.IsInputInitialized)
      {
        Console.WriteLine("Warning: Night.Keyboard.IsDown called before input system is initialized. Returning false.");
        return false;
      }

      bool[] keyboardState = SDL.GetKeyboardState(out int _);

      if (keyboardState == null)
      {
        Console.WriteLine("Warning: SDL.GetKeyboardState returned a null array.");
        return false;
      }

      SDL.Scancode sdlScancode = (SDL.Scancode)key;

      if (sdlScancode == SDL.Scancode.Unknown)
      {
        return false;
      }

      if ((int)sdlScancode >= keyboardState.Length || (int)sdlScancode < 0)
      {
        Console.WriteLine($"Warning: Scancode {(int)sdlScancode} is out of bounds (numKeys: {keyboardState.Length}).");
        return false;
      }

      return keyboardState[(int)sdlScancode];
    }
  }
}



================================================
File: src/Night/Mouse/Enums.cs
================================================
// <copyright file="Enums.cs" company="PlaceholderCompany">
// Copyright (c) PlaceholderCompany. All rights reserved.
// </copyright>

using System;

namespace Night
{
  /// <summary>
  /// Represents mouse buttons. Values correspond to SDL_MouseButtonFlags/
  /// SDL3.SDL.Button* constants.
  /// (e.g., Left is 1, Middle is 2, etc.)
  /// </summary>
  public enum MouseButton
  {
    Unknown = 0, // Not a direct SDL button constant
    Left = 1,    // Corresponds to SDL.ButtonLeft
    Middle = 2,  // Corresponds to SDL.ButtonMiddle
    Right = 3,   // Corresponds to SDL.ButtonRight
    X1 = 4,      // Corresponds to SDL.ButtonX1 (Typically "back")
    X2 = 5,       // Corresponds to SDL.ButtonX2 (Typically "forward")
  }
}



================================================
File: src/Night/Mouse/Mouse.cs
================================================
// <copyright file="Mouse.cs" company="PlaceholderCompany">
// Copyright (c) PlaceholderCompany. All rights reserved.
// </copyright>

using System;

using Night;

using SDL3;

namespace Night
{
  /// <summary>
  /// Provides an interface to the user's mouse.
  /// </summary>
  public static class Mouse
  {
    /// <summary>
    /// Checks whether a certain mouse button is down.
    /// This function does not detect mouse wheel scrolling.
    /// </summary>
    /// <param name="button">The index of a button to check. 1 is the primary mouse button, 2 is the secondary mouse button, 3 is the middle button, 4 is the X1 button (typically "back"), and 5 is the X2 button (typically "forward").</param>
    /// <returns>True if the button is down, false otherwise.</returns>
    public static bool IsDown(MouseButton button)
    {
      if (!Framework.IsInputInitialized)
      {
        Console.WriteLine("Warning: Night.Mouse.IsDown called before input system is initialized. Returning false.");
        return false;
      }

      SDL.MouseButtonFlags mouseState = SDL.GetMouseState(out float _, out float _);

      SDL.MouseButtonFlags buttonMask;
      switch (button)
      {
        case MouseButton.Left:
          buttonMask = SDL.MouseButtonFlags.Left;
          break;
        case MouseButton.Middle:
          buttonMask = SDL.MouseButtonFlags.Middle;
          break;
        case MouseButton.Right:
          buttonMask = SDL.MouseButtonFlags.Right;
          break;
        case MouseButton.X1:
          buttonMask = SDL.MouseButtonFlags.X1;
          break;
        case MouseButton.X2:
          buttonMask = SDL.MouseButtonFlags.X2;
          break;
        case MouseButton.Unknown:
        default:
          return false;
      }

      return (mouseState & buttonMask) != 0;
    }

    /// <summary>
    /// Gets the current position of the mouse cursor in the window.
    /// </summary>
    /// <returns>A tuple (int x, int y) representing the mouse cursor coordinates.</returns>
    public static (int x, int y) GetPosition()
    {
      if (!Framework.IsInputInitialized)
      {
        Console.WriteLine("Warning: Night.Mouse.GetPosition called before input system is initialized. Returning (0,0).");
        return (0, 0);
      }

      float mouseX, mouseY;
      _ = SDL.GetMouseState(out mouseX, out mouseY);
      return ((int)mouseX, (int)mouseY);
    }

    /// <summary>
    /// Sets the visibility of the mouse cursor.
    /// </summary>
    /// <param name="visible">True to show the cursor, false to hide it.</param>
    public static void SetVisible(bool visible)
    {
      if (!Framework.IsInputInitialized)
      {
        return;
      }

      if (visible)
      {
        _ = SDL.ShowCursor();
      }
      else
      {
        _ = SDL.HideCursor();
      }
    }

    /// <summary>
    /// Grabs the mouse, confining it to the window.
    /// </summary>
    /// <param name="grabbed">True to grab the mouse, false to release it.</param>
    public static void SetGrabbed(bool grabbed)
    {
      if (!Framework.IsInputInitialized || Window.Handle == nint.Zero)
      {
        return;
      }

      _ = SDL.SetWindowMouseGrab(Window.Handle, grabbed);
    }

    /// <summary>
    /// Sets whether relative mouse mode is enabled for the current window.
    /// In relative mode, the cursor is hidden and mouse motion is reported as relative to the last position.
    /// </summary>
    /// <param name="enabled">True to enable relative mode, false to disable it.</param>
    public static void SetRelativeMode(bool enabled)
    {
      if (!Framework.IsInputInitialized || Window.Handle == nint.Zero)
      {
        return;
      }

      _ = SDL.SetWindowRelativeMouseMode(Window.Handle, enabled);
    }
  }
}



================================================
File: src/Night/SDL/NightSDL.cs
================================================
// <copyright file="NightSDL.cs" company="PlaceholderCompany">
// Copyright (c) PlaceholderCompany. All rights reserved.
// </copyright>

using System;

using SDL3;

namespace Night
{
  /// <summary>
  /// Provides direct access to some SDL3 functions using SDL3-CS bindings.
  /// </summary>
  public static class NightSDL
  {
    /// <summary>
    /// Get the version of SDL that is linked against the Night Engine.
    /// Calls the SDL3-CS binding for SDL_GetVersion() and returns a packed int.
    /// https://wiki.libsdl.org/SDL3/SDL_GetVersion.
    /// </summary>
    /// <returns>A string representing the SDL version "major.minor.patch".</returns>
    public static string GetVersion()
    {
      int sdl_version = SDL.GetVersion();
      int major = sdl_version / 1000000;
      int minor = (sdl_version / 1000) % 1000;
      int patch = sdl_version % 1000;
      return $"{major}.{minor}.{patch}";
    }

    /// <summary>
    /// Retrieve a message about the last error that occurred on the current thread.
    /// Calls the SDL3-CS binding for SDL_GetError() and returns a string.
    /// https://wiki.libsdl.org/SDL3/SDL_GetError.
    /// </summary>
    /// <returns>Returns a message with information about the specific error that occurred, or an empty string if there hasn't been an error message set since the last call to SDL_ClearError().</returns>
    public static string GetError()
    {
      return SDL.GetError();
    }
  }
}



================================================
File: src/Night/System/System.cs
================================================
// <copyright file="System.cs" company="PlaceholderCompany">
// Copyright (c) PlaceholderCompany. All rights reserved.
// </copyright>

namespace Night
{
  using SDL3;

  /// <summary>
  /// Provides access to system-level information and functions.
  /// </summary>
  public static class System
  {
    /// <summary>
    /// Puts text in the system's clipboard.
    /// </summary>
    /// <param name="text">The new text to hold in the system's clipboard.</param>
    /// <returns>True if the operation was successful, false otherwise.</returns>
    public static bool SetClipboardText(string text)
    {
      return SDL.SetClipboardText(text);
    }

    // TODO: Consider adding GetClipboardText if in scope for future versions.
    // public static string GetClipboardText()
    // {
    //     return SDL.GetClipboardText();
    // }
  }
}



================================================
File: src/Night/Timer/Timer.cs
================================================
// <copyright file="Timer.cs" company="PlaceholderCompany">
// Copyright (c) PlaceholderCompany. All rights reserved.
// </copyright>

using System;
using System.Threading;

using SDL3;

namespace Night
{
  /// <summary>
  /// Provides high-resolution timing functionality.
  /// </summary>
  public static class Timer
  {
    // _timerStartTime is initialized when the Timer class is first loaded.
    private static readonly ulong TimerStartTime = SDL.GetPerformanceCounter();

    // These are updated by FrameworkLoop.cs or by Timer methods themselves
    internal static int CurrentFPS { get; set; } = 0;

    internal static float CurrentDelta { get; set; } = 0.0f;

    internal static double CurrentAverageDelta { get; set; } = 0.0;

    internal static ulong LastStepTime { get; set; } = 0; // Initialized by Initialize()

    internal static ulong PerformanceFrequency { get; private set; } = 1; // Initialized by Initialize(), made private set

    /// <summary>
    /// Initializes essential timer values. Must be called once by the framework
    /// before the game loop begins and after SDL has been initialized.
    /// </summary>
    internal static void Initialize()
    {
      PerformanceFrequency = SDL.GetPerformanceFrequency();
      if (PerformanceFrequency == 0)
      {
        PerformanceFrequency = 1; // Avoid division by zero, though SDL should provide valid freq.
      }

      LastStepTime = SDL.GetPerformanceCounter(); // Initialize for the first call to Step()

      // _timerStartTime is already initialized at class load (line 14) and should remain as such
      // to reflect "time since module loaded" for GetTime().
      // Do not re-assign _timerStartTime here.
    }

    /// <summary>
    /// Gets the time elapsed since the Timer module was loaded, in seconds.
    /// </summary>
    /// <returns>The time in seconds. Given as a decimal, accurate to the microsecond.</returns>
    public static double GetTime()
    {
      if (PerformanceFrequency == 0)
      {
        return 0.0;
      }

      ulong currentTimeCounter = SDL.GetPerformanceCounter();
      return (double)(currentTimeCounter - TimerStartTime) / PerformanceFrequency;
    }

    /// <summary>
    /// Gets the current frames per second (FPS).
    /// </summary>
    /// <returns>The current FPS.</returns>
    public static int GetFPS()
    {
      return CurrentFPS;
    }

    /// <summary>
    /// Gets the time elapsed since the last frame, in seconds.
    /// This is the same value passed to. <code>IGame.Update(float deltaTime)</code>.
    /// </summary>
    /// <returns>The delta time in seconds.</returns>
    public static float GetDelta()
    {
      return CurrentDelta;
    }

    /// <summary>
    /// Returns the average delta time (seconds per frame) over the last second.
    /// </summary>
    /// <returns>The average delta time over the last second.</returns>
    public static double GetAverageDelta()
    {
      return CurrentAverageDelta;
    }

    /// <summary>
    /// Pauses the current thread for the specified amount of time.
    /// This function causes the entire thread to pause. Graphics will not draw,
    /// input events will not trigger, code will not run, and the window will
    /// be unresponsive if you use this in the main game thread.
    /// </summary>
    /// <param name="seconds">Seconds to sleep for.</param>
    public static void Sleep(double seconds)
    {
      if (seconds < 0)
      {
        return;
      }

      Thread.Sleep(TimeSpan.FromSeconds(seconds));
    }

    /// <summary>
    /// Measures the time between the last call to this function and the current one.
    /// Calling this function updates the value returned by <see cref="GetDelta()"/>.
    /// This is typically called once per frame by the game loop to determine the delta time for that frame.
    /// </summary>
    /// <returns>The time passed (in seconds) since the last call to Step().</returns>
    public static double Step()
    {
      ulong now = SDL.GetPerformanceCounter();
      double deltaTimeSeconds = 0;

      if (LastStepTime > 0 && PerformanceFrequency > 0) // Ensure LastStepTime and PerformanceFrequency have been initialized
      {
        ulong elapsedTicks = now - LastStepTime;
        deltaTimeSeconds = (double)elapsedTicks / PerformanceFrequency;
      }

      // Clamp deltaTime to avoid large jumps
      if (deltaTimeSeconds > 0.0666) // Approx 15 FPS, or 66.6ms
      {
        deltaTimeSeconds = 0.0666;
      }

      LastStepTime = now;
      CurrentDelta = (float)deltaTimeSeconds;

      return deltaTimeSeconds;
    }
  }
}



================================================
File: src/Night/Window/Enums.cs
================================================
// <copyright file="Enums.cs" company="PlaceholderCompany">
// Copyright (c) PlaceholderCompany. All rights reserved.
// </copyright>

using System;

namespace Night
{
  /// <summary>
  /// Types of fullscreen modes.
  /// </summary>
  public enum FullscreenType
  {
    /// <summary>
    /// Standard exclusive-fullscreen mode. Changes the display mode (actual resolution) of the monitor.
    /// </summary>
    Exclusive,

    /// <summary>
    /// Borderless fullscreen windowed mode. A borderless screen-sized window is created which sits on top of all desktop UI elements.
    /// The window is automatically resized to match the dimensions of the desktop, and its size cannot be changed.
    /// </summary>
    Desktop,
  }
}



================================================
File: src/Night/Window/Structs.cs
================================================
// <copyright file="Structs.cs" company="PlaceholderCompany">
// Copyright (c) PlaceholderCompany. All rights reserved.
// </copyright>

using System;

namespace Night
{
  /// <summary>
  /// Represents the display mode of a window, including width, height, and other properties.
  /// </summary>
  public struct WindowMode
  {
    /// <summary>
    /// Window width.
    /// </summary>
    public int Width;

    /// <summary>
    /// Window height.
    /// </summary>
    public int Height;

    /// <summary>
    /// Fullscreen (true), or windowed (false).
    /// </summary>
    public bool Fullscreen;

    /// <summary>
    /// The type of fullscreen mode used.
    /// </summary>
    public FullscreenType FullscreenType;
    public bool Borderless;

    /// <summary>
    /// 1 if the graphics framerate is synchronized with the monitor's refresh rate, 0 otherwise.
    /// </summary>
    public int Vsync;

    /// <summary>
    /// The number of antialiasing samples used (0 if MSAA is disabled).
    /// </summary>
    public int Msaa;

    /// <summary>
    /// True if the window is resizable in windowed mode, false otherwise.
    /// </summary>
    public bool Resizable;

    /// <summary>
    /// True if the window is centered in windowed mode, false otherwise.
    /// </summary>
    public bool Centered;

    /// <summary>
    /// The index of the display the window is currently in (1-based).
    /// </summary>
    public int Display;

    /// <summary>
    /// The minimum width of the window, if resizable.
    /// </summary>
    public int MinWidth;

    /// <summary>
    /// The minimum height of the window, if resizable.
    /// </summary>
    public int MinHeight;

    /// <summary>
    /// True if high-dpi mode is allowed on Retina displays (macOS).
    /// </summary>
    public bool HighDpi;

    /// <summary>
    /// The refresh rate of the screen's current display mode in Hz (0 if undetermined).
    /// </summary>
    public int RefreshRate;

    /// <summary>
    /// The x-coordinate of the window's position.
    /// </summary>
    public int X;

    /// <summary>
    /// The y-coordinate of the window's position.
    /// </summary>
    public int Y;
  }
}



================================================
File: src/Night/Window/Window.cs
================================================
// <copyright file="Window.cs" company="PlaceholderCompany">
// Copyright (c) PlaceholderCompany. All rights reserved.
// </copyright>

using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;

using SDL3;

namespace Night
{

  /// <summary>
  /// Provides an interface for modifying and retrieving information about the program's window.
  /// </summary>
  public static class Window
  {
    private static nint window = nint.Zero;
    private static nint renderer = nint.Zero;
    private static bool isVideoInitialized = false;
    private static bool isWindowOpen = false;
    private static FullscreenType currentFullscreenType = FullscreenType.Desktop;

    // Internal accessor for the renderer, to be used by Night.Graphics
    internal static nint RendererPtr => renderer;

    // Internal accessor for the window handle, to be used by other Night modules if needed
    // And for the methods within this class that need the handle, which is now _window.
    internal static nint Handle => window;

    /// <summary>
    ///     Sets the display mode and properties of the window.
    /// </summary>
    /// <param name="width">The width of the window.</param>
    /// <param name="height">The height of the window.</param>
    /// <param name="flags">SDL Window flags to apply.</param>
    /// <returns>True if the mode was set successfully, false otherwise.</returns>
    public static bool SetMode(int width, int height, SDL.WindowFlags flags)
    {
      if (!isVideoInitialized)
      {
        if (!SDL.InitSubSystem(SDL.InitFlags.Video))
        {
          return false;
        }

        isVideoInitialized = true;
      }

      if (window != nint.Zero) // Clean up existing window and renderer
      {
        if (renderer != nint.Zero)
        {
          SDL.DestroyRenderer(renderer);
          renderer = nint.Zero;
        }

        SDL.DestroyWindow(window);
        window = nint.Zero;
        isWindowOpen = false;
      }

      window = SDL.CreateWindow("Night Engine", width, height, flags);
      if (window == nint.Zero)
      {
        isWindowOpen = false;
        return false;
      }

      renderer = SDL.CreateRenderer(window, null);
      if (renderer == nint.Zero)
      {
        SDL.DestroyWindow(window);
        window = nint.Zero;
        isWindowOpen = false;
        return false;
      }

      isWindowOpen = true;
      return true;
    }

    /// <summary>
    /// Sets the window title.
    /// </summary>
    /// <param name="title">The new window title.</param>
    public static void SetTitle(string title)
    {
      if (window == nint.Zero)
      {
        string errorMsg = "Error in Night.Window.SetTitle: Window handle is null. Was SetMode called successfully?";
        throw new InvalidOperationException(errorMsg);
      }

      if (!SDL.SetWindowTitle(window, title))
      {
        string sdlError = SDL.GetError();
        throw new Exception($"SDL Error in Night.Window.SetTitle: {sdlError}");
      }
    }

    /// <summary>
    /// Checks if the window is open.
    /// </summary>
    /// <returns>True if the window is open, false otherwise.</returns>
    public static bool IsOpen()
    {
      return isWindowOpen && window != nint.Zero;
    }

    /// <summary>
    /// Signals that the window should close.
    /// This is typically called by the engine when a quit event is received.
    /// TODO: Does this need to align with Love2D more? https://love2d.org/wiki/love.window.close.
    /// </summary>
    public static void Close()
    {
      isWindowOpen = false;
    }

    /// <summary>
    /// Internal method to shut down the window and renderer, and quit the video subsystem.
    /// Should be called by the FrameworkLoop at the end of the application.
    /// </summary>
    internal static void Shutdown()
    {
      if (renderer != nint.Zero)
      {
        SDL.DestroyRenderer(renderer);
        renderer = nint.Zero;
      }

      if (window != nint.Zero)
      {
        SDL.DestroyWindow(window);
        window = nint.Zero;
      }

      if (isVideoInitialized)
      {
        SDL.QuitSubSystem(SDL.InitFlags.Video);
        isVideoInitialized = false;
      }

      isWindowOpen = false;
    }

    /// <summary>
    /// Gets the number of connected monitors.
    /// </summary>
    /// <returns>The number of currently connected displays.</returns>
    public static int GetDisplayCount()
    {
      if (!isVideoInitialized)
      {
        EnsureVideoInitialized();
      }

      uint[]? displays = SDL.GetDisplays(out int count);
      if (displays == null || count < 0)
      {
        return 0;
      }

      return count;
    }

    /// <summary>
    /// Gets the width and height of the desktop.
    /// </summary>
    /// <param name="displayIndex">The index of the display to query (0 for the primary display).</param>
    /// <returns>A tuple containing the width and height of the desktop, or (0,0) if an error occurs.</returns>
    public static (int Width, int Height) GetDesktopDimensions(int displayIndex = 0)
    {
      if (!isVideoInitialized)
      {
        EnsureVideoInitialized();
      }

      uint[]? actualDisplayIDs = SDL.GetDisplays(out int displayCount);
      if (actualDisplayIDs == null || displayCount <= 0 || displayIndex < 0 || displayIndex >= displayCount)
      {
        return (0, 0);
      }

      uint targetDisplayID = actualDisplayIDs[displayIndex];

      SDL.DisplayMode? mode = SDL.GetDesktopDisplayMode(targetDisplayID);
      if (mode == null)
      {
        return (0, 0);
      }

      return (mode.Value.W, mode.Value.H);
    }

    /// <summary>
    /// Gets whether the window is fullscreen.
    /// </summary>
    /// <returns>A tuple: (bool IsFullscreen, FullscreenType fsType).
    /// IsFullscreen is true if the window is in any fullscreen mode, false otherwise.
    /// fsType indicates the type of fullscreen mode used.</returns>
    public static (bool isFullscreen, FullscreenType fsType) GetFullscreen()
    {
      if (window == nint.Zero)
      {
        return (false, currentFullscreenType);
      }

      var flags = SDL.GetWindowFlags(window);
      if ((flags & SDL.WindowFlags.Fullscreen) != 0)
      {
        return (true, currentFullscreenType);
      }

      return (false, currentFullscreenType);
    }

    /// <summary>
    /// Enters or exits fullscreen. The display to use when entering fullscreen is chosen
    /// based on which display the window is currently in, if multiple monitors are connected.
    /// </summary>
    /// <param name="fullscreen">Whether to enter or exit fullscreen mode.</param>
    /// <param name="fsType">The type of fullscreen mode to use (Desktop or Exclusive).</param>
    /// <returns>True if the operation was successful, false otherwise.</returns>
    public static bool SetFullscreen(bool fullscreen, FullscreenType fsType = FullscreenType.Desktop)
    {
      if (window == nint.Zero)
      {
        return false;
      }

      if (fullscreen)
      {
        currentFullscreenType = fsType;
        if (fsType == FullscreenType.Exclusive)
        {
          uint displayID = SDL.GetDisplayForWindow(window);
          if (displayID == 0 && SDL.GetError() != null && SDL.GetError().Length > 0)
          {
            return false;
          }

          SDL.DisplayMode? dm = SDL.GetDesktopDisplayMode(displayID);
          if (dm.HasValue)
          {
            if (!SDL.SetWindowFullscreenMode(window, dm.Value))
            {
              return false;
            }
          }
          else
          {
            return false;
          }
        }
        else // FullscreenType.Desktop
        {
          if (!SDL.SetWindowFullscreenMode(window, nint.Zero))
          {
          }

          if (!SDL.SetWindowBordered(window, false))
          {
            return false;
          }

          uint displayID = SDL.GetDisplayForWindow(window);
          if (displayID == 0 && SDL.GetError() != null && SDL.GetError().Length > 0)
          {
            return false;
          }

          var (desktopW, desktopH) = GetDesktopDimensionsForDisplayID(displayID);
          if (desktopW > 0 && desktopH > 0)
          {
            _ = SDL.SetWindowPosition(window, 0, 0);
            if (!SDL.SetWindowSize(window, desktopW, desktopH))
            {
              return false;
            }
          }
          else
          {
            return false;
          }
        }
      }
      else // Not fullscreen (go windowed)
      {
        currentFullscreenType = FullscreenType.Desktop;
        if (!SDL.SetWindowFullscreenMode(window, nint.Zero))
        {
        }

        if (!SDL.SetWindowBordered(window, true))
        {
          return false;
        }

        _ = SDL.RestoreWindow(window);
      }

      return true;
    }

    /// <summary>
    /// Gets a list of available fullscreen display modes for a given display.
    /// </summary>
    /// <param name="displayIndex">The index of the display (0 for primary).</param>
    /// <returns>A list of (Width, Height) tuples representing available modes, or an empty list on error.</returns>
    public static List<(int Width, int Height)> GetFullscreenModes(int displayIndex = 0)
    {
      if (!isVideoInitialized)
      {
        EnsureVideoInitialized();
      }

      var modesList = new List<(int Width, int Height)>();
      var uniqueModes = new HashSet<(int Width, int Height)>(); // Keep track of unique modes

      uint[]? actualDisplayIDs = SDL.GetDisplays(out int displayCount);
      if (actualDisplayIDs == null || displayCount <= 0 || displayIndex < 0 || displayIndex >= displayCount)
      {
        return modesList;
      }

      uint targetDisplayID = actualDisplayIDs[displayIndex];

      SDL.DisplayMode[]? displayModes = SDL.GetFullscreenDisplayModes(targetDisplayID, out int count);

      if (displayModes == null || count <= 0 || displayModes.Length != count)
      {
        return modesList;
      }

      foreach (var mode in displayModes)
      {
        var currentModeTuple = (mode.W, mode.H);
        if (uniqueModes.Add(currentModeTuple)) // Add returns true if the item was added (i.e., it was unique)
        {
          modesList.Add(currentModeTuple);
        }
      }

      return modesList;
    }

    /// <summary>
    /// Gets the current window mode (width, height, and flags).
    /// </summary>
    /// <returns>A WindowMode struct containing width, height, and current flags.</returns>
    public static WindowMode GetMode()
    {
      if (window == nint.Zero)
      {
        return new WindowMode { Width = 0, Height = 0, Fullscreen = false, FullscreenType = currentFullscreenType, Borderless = false };
      }

      _ = SDL.GetWindowSize(window, out int w, out int h);
      var flags = SDL.GetWindowFlags(window);

      bool isSdlExclusiveFullscreen = (flags & SDL.WindowFlags.Fullscreen) != 0;
      bool isSdlBorderless = (flags & SDL.WindowFlags.Borderless) != 0;
      FullscreenType reportedFsType = currentFullscreenType;

      bool actualReportedFullscreenState;
      if (isSdlExclusiveFullscreen)
      {
        actualReportedFullscreenState = true;
        reportedFsType = FullscreenType.Exclusive;
      }
      else if (isSdlBorderless)
      {
        if (currentFullscreenType == FullscreenType.Desktop)
        {
          uint currentDisplayID = SDL.GetDisplayForWindow(window);
          if (currentDisplayID != 0)
          {
            var (desktopW, desktopH) = GetDesktopDimensionsForDisplayID(currentDisplayID);
            if (w == desktopW && h == desktopH)
            {
              actualReportedFullscreenState = true;
            }
            else
            {
              actualReportedFullscreenState = false;
            }
          }
          else
          {
            actualReportedFullscreenState = false;
          }
        }
        else
        {
          actualReportedFullscreenState = false;
        }
      }
      else
      {
        actualReportedFullscreenState = false;
      }

      return new WindowMode
      {
        Width = w,
        Height = h,
        Fullscreen = actualReportedFullscreenState,
        FullscreenType = reportedFsType,
        Borderless = isSdlBorderless,
      };
    }

    /// <summary>
    /// Gets the DPI scale factor of the display containing the window.
    /// </summary>
    /// <returns>The DPI scale factor, or 1.0f on error or if not applicable.</returns>
    public static float GetDPIScale()
    {
      if (window == nint.Zero)
      {
        return 1.0f;
      }

      float dpiScale = SDL.GetWindowDisplayScale(window);
      if (dpiScale <= 0f)
      {
        return 1.0f;
      }

      return dpiScale;
    }

    /// <summary>
    /// Converts a value from density-independent units to pixels, using the window's current DPI scale.
    /// </summary>
    /// <param name="value">The value in density-independent units.</param>
    /// <returns>The equivalent value in pixels.</returns>
    public static float ToPixels(float value)
    {
      return value * GetDPIScale();
    }

    /// <summary>
    /// Converts a value from pixels to density-independent units, using the window's current DPI scale.
    /// </summary>
    /// <param name="value">The value in pixels.</param>
    /// <returns>The equivalent value in density-independent units.</returns>
    public static float FromPixels(float value)
    {
      float dpiScale = GetDPIScale();
      if (dpiScale == 0)
      {
        return value;
      }

      return value / dpiScale;
    }

    /// <summary>
    /// Ensures the SDL Video subsystem is initialized.
    /// </summary>
    private static void EnsureVideoInitialized()
    {
      if (!isVideoInitialized)
      {
        if (!SDL.InitSubSystem(SDL.InitFlags.Video))
        {
          string sdlError = SDL.GetError();
          throw new Exception($"SDL Error initializing video subsystem: {sdlError}");
        }

        isVideoInitialized = true;
      }
    }

    /// <summary>
    /// Gets the dimensions of the desktop for a specific display ID.
    /// </summary>
    /// <param name="displayID">The actual ID of the display to query.</param>
    /// <returns>A tuple containing the width and height of the desktop, or (0,0) if an error occurs.</returns>
    private static (int Width, int Height) GetDesktopDimensionsForDisplayID(uint displayID)
    {
      if (!isVideoInitialized)
      {
        EnsureVideoInitialized();
      }

      SDL.DisplayMode? mode = SDL.GetDesktopDisplayMode(displayID);
      if (mode == null)
      {
        return (0, 0);
      }

      return (mode.Value.W, mode.Value.H);
    }
  }
}



================================================
File: src/Night/bin/Debug/net9.0/Night.deps.json
================================================
{
  "runtimeTarget": {
    "name": ".NETCoreApp,Version=v9.0",
    "signature": ""
  },
  "compilationOptions": {},
  "targets": {
    ".NETCoreApp,Version=v9.0": {
      "Night/1.0.0": {
        "dependencies": {
          "SDL3-CS": "3.2.14.2"
        },
        "runtime": {
          "Night.dll": {}
        }
      },
      "SDL3-CS/3.2.14.2": {
        "runtime": {
          "lib/net9.0/SDL3-CS.dll": {
            "assemblyVersion": "3.2.14.2",
            "fileVersion": "3.2.14.2"
          }
        }
      }
    }
  },
  "libraries": {
    "Night/1.0.0": {
      "type": "project",
      "serviceable": false,
      "sha512": ""
    },
    "SDL3-CS/3.2.14.2": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-wqWjIm2EP7PmXRQfwSxY4YJDSrXZ0QmolJMCJcs9KY4b3vYBdlwo0U4/olPMdBx6yRzqhN1nGJjmeC9OJT6L1g==",
      "path": "sdl3-cs/3.2.14.2",
      "hashPath": "sdl3-cs.3.2.14.2.nupkg.sha512"
    }
  }
}


================================================
File: src/Night/obj/Night.csproj.nuget.dgspec.json
================================================
{
  "format": 1,
  "restore": {
    "/home/danny/git/any2/src/Night/Night.csproj": {}
  },
  "projects": {
    "/home/danny/git/any2/src/Night/Night.csproj": {
      "version": "1.0.0",
      "restore": {
        "projectUniqueName": "/home/danny/git/any2/src/Night/Night.csproj",
        "projectName": "Night",
        "projectPath": "/home/danny/git/any2/src/Night/Night.csproj",
        "packagesPath": "/home/danny/.nuget/packages/",
        "outputPath": "/home/danny/git/any2/src/Night/obj/",
        "projectStyle": "PackageReference",
        "configFilePaths": [
          "/home/danny/.nuget/NuGet/NuGet.Config"
        ],
        "originalTargetFrameworks": [
          "net9.0"
        ],
        "sources": {
          "https://api.nuget.org/v3/index.json": {}
        },
        "frameworks": {
          "net9.0": {
            "targetAlias": "net9.0",
            "projectReferences": {}
          }
        },
        "warningProperties": {
          "warnAsError": [
            "NU1605"
          ]
        },
        "restoreAuditProperties": {
          "enableAudit": "true",
          "auditLevel": "low",
          "auditMode": "direct"
        },
        "SdkAnalysisLevel": "9.0.300"
      },
      "frameworks": {
        "net9.0": {
          "targetAlias": "net9.0",
          "dependencies": {
            "SDL3-CS": {
              "target": "Package",
              "version": "[*, )"
            }
          },
          "imports": [
            "net461",
            "net462",
            "net47",
            "net471",
            "net472",
            "net48",
            "net481"
          ],
          "assetTargetFallback": true,
          "warn": true,
          "frameworkReferences": {
            "Microsoft.NETCore.App": {
              "privateAssets": "all"
            }
          },
          "runtimeIdentifierGraphPath": "/home/danny/.local/share/mise/installs/dotnet/9.0.300/sdk/9.0.300/PortableRuntimeIdentifierGraph.json"
        }
      }
    }
  }
}


================================================
File: src/Night/obj/Night.csproj.nuget.g.props
================================================
﻿<?xml version="1.0" encoding="utf-8" standalone="no"?>
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition=" '$(ExcludeRestorePackageImports)' != 'true' ">
    <RestoreSuccess Condition=" '$(RestoreSuccess)' == '' ">True</RestoreSuccess>
    <RestoreTool Condition=" '$(RestoreTool)' == '' ">NuGet</RestoreTool>
    <ProjectAssetsFile Condition=" '$(ProjectAssetsFile)' == '' ">$(MSBuildThisFileDirectory)project.assets.json</ProjectAssetsFile>
    <NuGetPackageRoot Condition=" '$(NuGetPackageRoot)' == '' ">/home/danny/.nuget/packages/</NuGetPackageRoot>
    <NuGetPackageFolders Condition=" '$(NuGetPackageFolders)' == '' ">/home/danny/.nuget/packages/</NuGetPackageFolders>
    <NuGetProjectStyle Condition=" '$(NuGetProjectStyle)' == '' ">PackageReference</NuGetProjectStyle>
    <NuGetToolVersion Condition=" '$(NuGetToolVersion)' == '' ">6.14.0</NuGetToolVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(ExcludeRestorePackageImports)' != 'true' ">
    <SourceRoot Include="/home/danny/.nuget/packages/" />
  </ItemGroup>
</Project>


================================================
File: src/Night/obj/Night.csproj.nuget.g.targets
================================================
﻿<?xml version="1.0" encoding="utf-8" standalone="no"?>
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />


================================================
File: src/Night/obj/project.assets.json
================================================
{
  "version": 3,
  "targets": {
    "net9.0": {
      "SDL3-CS/3.2.14.2": {
        "type": "package",
        "compile": {
          "lib/net9.0/SDL3-CS.dll": {
            "related": ".xml"
          }
        },
        "runtime": {
          "lib/net9.0/SDL3-CS.dll": {
            "related": ".xml"
          }
        }
      }
    }
  },
  "libraries": {
    "SDL3-CS/3.2.14.2": {
      "sha512": "wqWjIm2EP7PmXRQfwSxY4YJDSrXZ0QmolJMCJcs9KY4b3vYBdlwo0U4/olPMdBx6yRzqhN1nGJjmeC9OJT6L1g==",
      "type": "package",
      "path": "sdl3-cs/3.2.14.2",
      "files": [
        ".nupkg.metadata",
        ".signature.p7s",
        "CODE_OF_CONDUCT.md",
        "LICENSE",
        "README-nuget.md",
        "README.md",
        "SDL3-CS.xml",
        "lib/net7.0/SDL3-CS.dll",
        "lib/net7.0/SDL3-CS.xml",
        "lib/net8.0/SDL3-CS.dll",
        "lib/net8.0/SDL3-CS.xml",
        "lib/net9.0/SDL3-CS.dll",
        "lib/net9.0/SDL3-CS.xml",
        "logo.png",
        "sdl3-cs.3.2.14.2.nupkg.sha512",
        "sdl3-cs.nuspec"
      ]
    }
  },
  "projectFileDependencyGroups": {
    "net9.0": [
      "SDL3-CS >= *"
    ]
  },
  "packageFolders": {
    "/home/danny/.nuget/packages/": {}
  },
  "project": {
    "version": "1.0.0",
    "restore": {
      "projectUniqueName": "/home/danny/git/any2/src/Night/Night.csproj",
      "projectName": "Night",
      "projectPath": "/home/danny/git/any2/src/Night/Night.csproj",
      "packagesPath": "/home/danny/.nuget/packages/",
      "outputPath": "/home/danny/git/any2/src/Night/obj/",
      "projectStyle": "PackageReference",
      "configFilePaths": [
        "/home/danny/.nuget/NuGet/NuGet.Config"
      ],
      "originalTargetFrameworks": [
        "net9.0"
      ],
      "sources": {
        "https://api.nuget.org/v3/index.json": {}
      },
      "frameworks": {
        "net9.0": {
          "targetAlias": "net9.0",
          "projectReferences": {}
        }
      },
      "warningProperties": {
        "warnAsError": [
          "NU1605"
        ]
      },
      "restoreAuditProperties": {
        "enableAudit": "true",
        "auditLevel": "low",
        "auditMode": "direct"
      },
      "SdkAnalysisLevel": "9.0.300"
    },
    "frameworks": {
      "net9.0": {
        "targetAlias": "net9.0",
        "dependencies": {
          "SDL3-CS": {
            "target": "Package",
            "version": "[*, )"
          }
        },
        "imports": [
          "net461",
          "net462",
          "net47",
          "net471",
          "net472",
          "net48",
          "net481"
        ],
        "assetTargetFallback": true,
        "warn": true,
        "frameworkReferences": {
          "Microsoft.NETCore.App": {
            "privateAssets": "all"
          }
        },
        "runtimeIdentifierGraphPath": "/home/danny/.local/share/mise/installs/dotnet/9.0.300/sdk/9.0.300/PortableRuntimeIdentifierGraph.json"
      }
    }
  }
}


================================================
File: src/Night/obj/project.nuget.cache
================================================
{
  "version": 2,
  "dgSpecHash": "26ARwza29+8=",
  "success": true,
  "projectFilePath": "/home/danny/git/any2/src/Night/Night.csproj",
  "expectedPackageFiles": [
    "/home/danny/.nuget/packages/sdl3-cs/3.2.14.2/sdl3-cs.3.2.14.2.nupkg.sha512"
  ],
  "logs": []
}


================================================
File: src/Night/obj/Debug/net9.0/Night.AssemblyInfo.cs
================================================
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Night")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+0525ee88c265b33fa6724e0db77184b53b4d713c")]
[assembly: System.Reflection.AssemblyProductAttribute("Night")]
[assembly: System.Reflection.AssemblyTitleAttribute("Night")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.




================================================
File: src/Night/obj/Debug/net9.0/Night.AssemblyInfoInputs.cache
================================================
db14d5e6be7702840fa060052804ca7ce1a204a1bf7765c2a49c11ed17f09662



================================================
File: src/Night/obj/Debug/net9.0/Night.GeneratedMSBuildEditorConfig.editorconfig
================================================
is_global = true
build_property.TargetFramework = net9.0
build_property.TargetPlatformMinVersion = 
build_property.UsingMicrosoftNETSdkWeb = 
build_property.ProjectTypeGuids = 
build_property.InvariantGlobalization = 
build_property.PlatformNeutralAssembly = 
build_property.EnforceExtendedAnalyzerRules = 
build_property._SupportedPlatformList = Linux,macOS,Windows
build_property.RootNamespace = Night
build_property.ProjectDir = /home/danny/git/any2/src/Night/
build_property.EnableComHosting = 
build_property.EnableGeneratedComInterfaceComImportInterop = 
build_property.EffectiveAnalysisLevelStyle = 9.0
build_property.EnableCodeStyleSeverity = 



================================================
File: src/Night/obj/Debug/net9.0/Night.GlobalUsings.g.cs
================================================
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;



================================================
File: src/Night/obj/Debug/net9.0/Night.assets.cache
================================================
[Non-text file]


================================================
File: src/Night/obj/Debug/net9.0/Night.csproj.AssemblyReference.cache
================================================
[Non-text file]


================================================
File: src/Night/obj/Debug/net9.0/Night.csproj.CoreCompileInputs.cache
================================================
cb5d82de82cf2868752796dcad4edbd7810515267684c92faae8d67719d9c500



================================================
File: src/Night/obj/Debug/net9.0/Night.sourcelink.json
================================================
{"documents":{"/home/danny/git/any2/*":"https://raw.githubusercontent.com/nightconcept/any2/0525ee88c265b33fa6724e0db77184b53b4d713c/*","/home/danny/git/any2/lib/SDL3-CS/*":"https://raw.githubusercontent.com/edwardgushchin/SDL3-CS/f910675dcf9e0825b10e97b8583c892e0eee14be/*"}}


================================================
File: src/Night/obj/Debug/net9.0/.NETCoreApp,Version=v9.0.AssemblyAttributes.cs
================================================
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName = ".NET 9.0")]





================================================
File: src/SampleGame/Night.SampleGame.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <LangVersion>13.0</LangVersion>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\Night\Night.csproj" />
  </ItemGroup>

  <ItemGroup>
    <Content Include="assets/**/*">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
    <Content Include="config.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
  </ItemGroup>

  <ItemGroup>
    <Content Include="..\..\lib\SDL3-Prebuilt\windows\SDL3.dll" Condition="$([MSBuild]::IsOSPlatform('Windows'))">
      <Link>SDL3.dll</Link>
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
    <Content Include="..\..\lib\SDL3-Prebuilt\macos\libSDL3.0.dylib" Condition="$([MSBuild]::IsOSPlatform('OSX'))">
      <Link>libSDL3.dylib</Link>
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
    <Content Include="..\..\lib\SDL3-Prebuilt\linux\libSDL3.so.0" Condition="$([MSBuild]::IsOSPlatform('Linux'))">
      <Link>libSDL3.so</Link>
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>

    <!-- SDL3_image native libraries -->
    <Content Include="..\..\lib\SDL3-Prebuilt\windows\SDL3_image.dll" Condition="$([MSBuild]::IsOSPlatform('Windows'))">
      <Link>SDL3_image.dll</Link>
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
    <Content Include="..\..\lib\SDL3-Prebuilt\macos\libSDL3_image.0.dylib" Condition="$([MSBuild]::IsOSPlatform('OSX'))">
      <Link>libSDL3_image.dylib</Link>
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
    <Content Include="..\..\lib\SDL3-Prebuilt\linux\libSDL3_image.so.0" Condition="$([MSBuild]::IsOSPlatform('Linux'))">
      <Link>libSDL3_image.so</Link>
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
  </ItemGroup>

</Project>



================================================
File: src/SampleGame/Player.cs
================================================
using System;
using System.Collections.Generic;
using System.IO;

using Night;

namespace Night.SampleGame
{
  public class Player
  {
    public float X { get; private set; }
    public float Y { get; private set; }
    public int Width { get; private set; }
    public int Height { get; private set; }

    private float _velocityX;
    private float _velocityY;

    private const float HorizontalSpeed = 200f; // Pixels per second
    private const float JumpStrength = -450f;  // Initial upward velocity
    private const float Gravity = 1000f;       // Pixels per second squared

    private bool _isGrounded;

    private Night.Sprite? _playerSprite; // To hold the blue rectangle sprite

    public Player()
    {
      // Initialize properties in Load()
      _isGrounded = false; // Start in the air or assume Load sets initial grounded state
    }

    public void Load()
    {
      Width = 32;
      Height = 64;

      // Initial position: Centered horizontally, resting on the first platform (Y=500, H=50).
      // Player's top-left Y = PlatformTopY - PlayerHeight = 500 - 64 = 436.
      // Player's top-left X = (WindowWidth / 2) - (PlayerWidth / 2) = (800 / 2) - (32 / 2) = 400 - 16 = 384.
      // Assuming window width is 800 as per Game.cs Load()
      X = 384f;
      Y = 436f; // This will be adjusted by gravity until grounded on a floor/platform

      _velocityX = 0f;
      _velocityY = 0f;

      // Attempt to load a pre-made blue image for the player.
      // This file needs to exist: "assets/images/player_sprite_blue_32x64.png"
      // Or a 1x1 blue pixel: "assets/images/pixel_blue.png" which we then scale.
      // For simplicity with current Draw method (no tinting), let's assume a 32x64 blue sprite.
      // If we used a 1x1 pixel_blue.png, scaleX would be Width, scaleY would be Height.
      string baseDirectory = AppContext.BaseDirectory;
      // Using a specific asset name as discussed due to lack of tinting.
      // This asset would be a 32x64 solid blue rectangle image.
      string imageRelativePath = Path.Combine("assets", "images", "player_sprite_blue_32x64.png");
      string imageFullPath = Path.Combine(baseDirectory, imageRelativePath);

      _playerSprite = Graphics.NewImage(imageFullPath);
      if (_playerSprite == null)
      {
        Console.WriteLine($"Player.Load: Failed to load player sprite at '{imageFullPath}'. A blue rectangle will not be drawn.");
      }
      else
      {

      }
      _isGrounded = false; // Player starts potentially in the air and falls to ground.
    }

    private static bool CheckAABBCollision(Night.Rectangle rect1, Night.Rectangle rect2)
    {
      // True if the rectangles are overlapping
      return rect1.X < rect2.X + rect2.Width &&
             rect1.X + rect1.Width > rect2.X &&
             rect1.Y < rect2.Y + rect2.Height &&
             rect1.Y + rect1.Height > rect2.Y;
    }

    public void Update(double deltaTime, List<Night.Rectangle> platforms)
    {
      float dt = (float)deltaTime;

      // 1. Handle Input & Apply Jump Impulse
      _velocityX = 0;
      if (Keyboard.IsDown(KeyCode.Left) || Keyboard.IsDown(KeyCode.A))
      {
        _velocityX = -HorizontalSpeed;
      }
      if (Keyboard.IsDown(KeyCode.Right) || Keyboard.IsDown(KeyCode.D))
      {
        _velocityX = HorizontalSpeed;
      }

      bool tryingToJump = Keyboard.IsDown(KeyCode.Space);
      if (tryingToJump && _isGrounded)
      {
        _velocityY = JumpStrength;
        _isGrounded = false; // Explicitly set to false when jump starts
      }

      // 2. Apply Gravity
      if (!_isGrounded)
      {
        _velocityY += Gravity * dt;
      }

      // 3. Horizontal Movement and Collision
      X += _velocityX * dt;
      Night.Rectangle playerBoundingBox = new Night.Rectangle((int)X, (int)Y, Width, Height);

      foreach (var platform in platforms)
      {
        // Update playerBoundingBox X for current position before check
        playerBoundingBox.X = (int)X;
        playerBoundingBox.Y = (int)Y; // Keep Y fixed for horizontal check pass

        if (CheckAABBCollision(new Night.Rectangle((int)X, (int)Y, Width, Height), platform))
        {
          if (_velocityX > 0) // Moving right, collided with left edge of platform
          {
            X = platform.X - Width;
          }
          else if (_velocityX < 0) // Moving left, collided with right edge of platform
          {
            X = platform.X + platform.Width;
          }
          _velocityX = 0; // Stop horizontal movement on collision
        }
      }

      // 4. Vertical Movement and Collision
      Y += _velocityY * dt;

      // Update playerBoundingBox for vertical check using potentially corrected X and new Y
      playerBoundingBox.X = (int)X;
      playerBoundingBox.Y = (int)Y;

      // Before checking collisions, assume player is not grounded unless a collision proves otherwise.
      // This flag will be set if any interaction during the platform loop results in grounding.
      bool newIsGroundedThisFrame = false;

      foreach (var platform in platforms)
      {
        // Horizontal overlap check (using player's float X for precision against integer platform.X)
        bool horizontalOverlap = (X + Width > platform.X && X < platform.X + platform.Width);

        if (horizontalOverlap)
        {
          float playerFloatTop = Y;
          float playerFloatBottom = Y + Height;

          float platformTop = platform.Y;
          float platformBottom = platform.Y + platform.Height;

          if (_velocityY > 0) // Player is moving downwards
          {
            // Check if player's bottom has landed on or passed through the platform's top surface,
            // and the player's top was above the platform's top (i.e., not starting from inside/below).
            if (playerFloatBottom >= platformTop && playerFloatTop < platformTop)
            {
              Y = platformTop - Height; // Snap player's bottom to platform's top
              _velocityY = 0f;
              newIsGroundedThisFrame = true;
            }
          }
          else if (_velocityY < 0) // Player is moving upwards
          {
            // Check if player's top has hit or passed through the platform's bottom surface,
            // and the player's bottom was below the platform's bottom (i.e., not starting from inside/above).
            if (playerFloatTop <= platformBottom && playerFloatBottom > platformBottom)
            {
              Y = platformBottom; // Snap player's top to platform's bottom
              _velocityY = 0f;
              // Hitting head does not make player grounded
            }
          }

          // Additional check for stable grounding if player is (almost) stationary vertically.
          // This handles cases where player is already on the platform, slid onto it, or just landed.
          // It's important this runs even if _velocityY became 0 in this frame due to landing.
          if (Math.Abs(_velocityY) < 0.1f) // If effectively stationary vertically
          {
            // Check if player's bottom is at or very slightly through the platform's top,
            // and player's head is above the platform's top.
            // The (platformTop + 1.0f) allows for a small 1px penetration to still count as grounded.
            if (playerFloatBottom >= platformTop && playerFloatBottom < (platformTop + 1.0f) && playerFloatTop < platformTop)
            {
              Y = platformTop - Height; // Snap firmly
              _velocityY = 0f;          // Ensure velocity is zeroed
              newIsGroundedThisFrame = true;
            }
          }
        }
      }
      _isGrounded = newIsGroundedThisFrame;

      // If a jump was initiated and _isGrounded became false,
      // and player is still moving upwards (_velocityY < 0), they are not grounded.
      // This ensures that if a jump starts, _isGrounded remains false until landing.
      if (tryingToJump && _velocityY < 0)
      { // Check if jump was initiated *this frame*
        _isGrounded = false;
      }


      // Prevent player from going off-screen left/right (simple boundary)
      // These values should ideally come from Window.GetWidth/Height if game resizes
      float gameWindowWidth = 800;
      if (X < 0) X = 0;
      if (X + Width > gameWindowWidth) X = gameWindowWidth - Width;
      // Top boundary (optional, could allow jumping off screen top)
      // if (Y < 0) { Y = 0; if (_velocityY < 0) _velocityY = 0; }
    }

    public void Draw()
    {
      if (_playerSprite != null)
      {
        // If player_sprite_blue_32x64.png is exactly 32x64, scaleX and scaleY are 1.
        // If it was a 1x1 pixel_blue.png, then scaleX=Width, scaleY=Height.
        // Assuming the loaded sprite is already the correct size (32x64):
        Graphics.Draw(_playerSprite, X, Y);
      }
      else
      {
        // Fallback: Could draw a placeholder or nothing if sprite failed to load.
        // For now, player is invisible if sprite load fails.
        // To draw a white rectangle as a fallback (if we had a white pixel sprite):
        // if (_fallbackWhitePixelSprite != null) {
        //    Graphics.Draw(_fallbackWhitePixelSprite, X, Y, 0, Width, Height);
        // }
      }
    }
  }
}



================================================
File: src/SampleGame/Program.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.IO;

using Night;

using SDL3;

namespace Night.SampleGame;

public class Game : IGame
{
  private Player _player;
  private List<Night.Rectangle> _platforms;
  private Night.Sprite? _platformSprite;
  private Night.Rectangle _goalPlatform;
  private bool _goalReachedMessageShown = false; // To ensure message prints only once

  public Game()
  {
    _player = new Player();
    _platforms = new List<Night.Rectangle>();
  }

  public void Load()
  {
    // _ = Window.SetMode(800, 600, SDL.WindowFlags.Resizable);
    // Window.SetTitle("Night Platformer Sample");
    // Window settings will now be driven by config.json (or defaults if not present/configured)

    _player.Load();

    // Load platform sprite
    string baseDirectory = AppContext.BaseDirectory;
    string platformImageRelativePath = Path.Combine("assets", "images", "pixel_green.png");
    string platformImageFullPath = Path.Combine(baseDirectory, platformImageRelativePath);
    _platformSprite = Graphics.NewImage(platformImageFullPath); // Graphics class will be in Night.Framework
    if (_platformSprite == null)
    {
      Console.WriteLine($"Game.Load: Failed to load platform sprite at '{platformImageFullPath}'. Platforms will not be drawn.");
    }

    // Initialize platforms (as per docs/epics/epic7-design.md)
    _platforms.Add(new Night.Rectangle(50, 500, 700, 50));
    _platforms.Add(new Night.Rectangle(200, 400, 150, 30));
    _platforms.Add(new Night.Rectangle(450, 300, 100, 30));
    _goalPlatform = new Night.Rectangle(600, 200, 100, 30);
    _platforms.Add(_goalPlatform);
  }

  // Helper for collision detection (AABB)
  private static bool CheckAABBCollision(Night.Rectangle rect1, Night.Rectangle rect2)
  {
    // True if the rectangles are overlapping
    return rect1.X < rect2.X + rect2.Width &&
           rect1.X + rect1.Width > rect2.X &&
           rect1.Y < rect2.Y + rect2.Height &&
           rect1.Y + rect1.Height > rect2.Y;
  }

  public void Update(double deltaTime)
  {
    _player.Update(deltaTime, _platforms);

    // Check if player reached the goal platform
    // Adjust playerBounds slightly for the goal check to ensure "touching" counts,
    // as player might be perfectly aligned on top.
    Night.Rectangle playerBoundsForGoalCheck = new Night.Rectangle((int)_player.X, (int)_player.Y, _player.Width, _player.Height + 1);
    if (CheckAABBCollision(playerBoundsForGoalCheck, _goalPlatform) && !_goalReachedMessageShown)
    {
      // Simple win condition: print a message.
      // A real game might change state, show a UI, etc.
      Console.WriteLine("Congratulations! Goal Reached!");
      _goalReachedMessageShown = true; // Set flag so it doesn't print again
      // Optionally, could close the game or trigger another action:
      // Window.Close(); // Window class will be in Night.Framework
    }
  }

  public void Draw()
  {
    Graphics.Clear(new Night.Color(135, 206, 235)); // Sky blue background

    // Draw platforms
    if (_platformSprite != null)
    {
      foreach (var platform in _platforms)
      {
        // Scale the 1x1 pixel sprite to the platform's dimensions
        Graphics.Draw(
            _platformSprite,
            platform.X,
            platform.Y,
            0,
            platform.Width,
            platform.Height
        );
      }
    }

    _player.Draw();
    // --- Graphics Shape Drawing Demonstration ---
    // Rectangle Demo
    Graphics.SetColor(Night.Color.Red);
    Graphics.Rectangle(Night.DrawMode.Fill, 50, 50, 100, 50); // Filled Red Rectangle
    Graphics.SetColor(Night.Color.Black);
    Graphics.Rectangle(Night.DrawMode.Line, 50, 50, 100, 50); // Black outline for Red Rectangle

    Graphics.SetColor(0, 0, 255, 128); // Semi-transparent Blue
    Graphics.Rectangle(Night.DrawMode.Line, 160, 50, 80, 60); // Outlined Blue Rectangle

    // Circle Demo
    Graphics.SetColor(Night.Color.Green);
    Graphics.Circle(Night.DrawMode.Fill, 300, 80, 30); // Filled Green Circle
    Graphics.SetColor(Night.Color.Black);
    Graphics.Circle(Night.DrawMode.Line, 300, 80, 30, 24); // Black outline, 24 segments

    Graphics.SetColor(Night.Color.Yellow);
    Graphics.Circle(Night.DrawMode.Line, 400, 80, 25, 6); // 6-segment "circle" (hexagon) outline

    // Line Demo
    Graphics.SetColor(Night.Color.Magenta);
    Graphics.Line(50, 120, 250, 150); // Single Magenta Line

    Night.PointF[] linePoints = new Night.PointF[]
    {
      new Night.PointF(280, 120),
      new Night.PointF(320, 160),
      new Night.PointF(360, 120),
      new Night.PointF(400, 160),
      new Night.PointF(440, 120)
    };
    Graphics.SetColor(Night.Color.Cyan);
    Graphics.Line(linePoints); // Polyline in Cyan

    // Polygon Demo
    Night.PointF[] triangleVertices = new Night.PointF[]
    {
      new Night.PointF(500, 50),
      new Night.PointF(550, 100),
      new Night.PointF(450, 100)
    };
    Graphics.SetColor(new Night.Color(255, 165, 0)); // Orange
    Graphics.Polygon(Night.DrawMode.Fill, triangleVertices); // Filled Orange Triangle
    Graphics.SetColor(Night.Color.Black);
    Graphics.Polygon(Night.DrawMode.Line, triangleVertices); // Black outline for Triangle

    Night.PointF[] pentagonVertices = new Night.PointF[]
    {
        new Night.PointF(600, 80),
        new Night.PointF(630, 60),
        new Night.PointF(650, 90),
        new Night.PointF(620, 110),
        new Night.PointF(580, 100)
    };
    Graphics.SetColor(new Night.Color(75, 0, 130)); // Indigo
    Graphics.Polygon(Night.DrawMode.Line, pentagonVertices);
  }

  public void KeyPressed(Night.KeySymbol key, Night.KeyCode scancode, bool isRepeat)
  {
    // Minimal key handling for now, primarily for closing the window.
    if (key == Night.KeySymbol.Escape)
    {
      Window.Close();
    }

    // Test error triggering
    if (key == Night.KeySymbol.E && !isRepeat)
    {
      throw new InvalidOperationException("Test error triggered by pressing 'E' in SampleGame!");
    }

    // --- Night.Window Demo: Toggle Fullscreen ---
    if (key == Night.KeySymbol.F11)
    {
      var (isFullscreen, _) = Window.GetFullscreen();
      bool success = Window.SetFullscreen(!isFullscreen, Night.FullscreenType.Desktop);
      Console.WriteLine($"SetFullscreen to {!isFullscreen} (Desktop) attempt: {(success ? "Success" : "Failed")}");
      var newMode = Window.GetMode();
      Console.WriteLine($"New Window Mode: {newMode.Width}x{newMode.Height}, Fullscreen: {newMode.Fullscreen}, Type: {newMode.FullscreenType}, Borderless: {newMode.Borderless}");
    }
    if (key == Night.KeySymbol.F10)
    {
      var (isFullscreen, _) = Window.GetFullscreen();
      bool success = Window.SetFullscreen(!isFullscreen, Night.FullscreenType.Exclusive);
      Console.WriteLine($"SetFullscreen to {!isFullscreen} (Exclusive) attempt: {(success ? "Success" : "Failed")}");
      var newMode = Window.GetMode();
      Console.WriteLine($"New Window Mode: {newMode.Width}x{newMode.Height}, Fullscreen: {newMode.Fullscreen}, Type: {newMode.FullscreenType}, Borderless: {newMode.Borderless}");
    }
    // --- End Night.Window Demo ---
  }
}

public class Program
{
  public static void Main()
  {
    Framework.Run(new Game());
  }
}



================================================
File: src/SampleGame/config.json
================================================
{
  "window": {
    "title": "Configured by JSON!",
    "width": 1024,
    "height": 768,
    "resizable": true,
    "vsync": 0,
    "fullscreen": false,
    "borderless": true,
    "x": 100,
    "y": 100
  }
} 


================================================
File: src/SampleGame/Samples/Program.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.IO;

using Night;

using SDL3;

namespace Night.SampleGame;

public class Platformer : IGame
{
  private Player _player;
  private List<Night.Rectangle> _platforms;
  private Sprite? _platformSprite;
  private Night.Rectangle _goalPlatform;
  private bool _goalReachedMessageShown = false;

  public Platformer()
  {
    _player = new Player();
    _platforms = new List<Night.Rectangle>();
  }

  public void Load()
  {
    _ = Night.Window.SetMode(800, 600, SDL.WindowFlags.Resizable);
    Night.Window.SetTitle("Night Platformer Sample");

    _player.Load();

    string baseDirectory = AppContext.BaseDirectory;
    string platformImageRelativePath = Path.Combine("assets", "images", "pixel_green.png");
    string platformImageFullPath = Path.Combine(baseDirectory, platformImageRelativePath);
    _platformSprite = Graphics.NewImage(platformImageFullPath);
    if (_platformSprite == null)
    {
      Console.WriteLine($"Game.Load: Failed to load platform sprite at '{platformImageFullPath}'. Platforms will not be drawn.");
    }

    _platforms.Add(new Night.Rectangle(50, 500, 700, 50));
    _platforms.Add(new Night.Rectangle(200, 400, 150, 30));
    _platforms.Add(new Night.Rectangle(450, 300, 100, 30));
    _goalPlatform = new Night.Rectangle(600, 200, 100, 30);
    _platforms.Add(_goalPlatform);
  }

  // Helper for collision detection (AABB)
  private static bool CheckAABBCollision(Night.Rectangle rect1, Night.Rectangle rect2)
  {
    // True if the rectangles are overlapping
    return rect1.X < rect2.X + rect2.Width &&
           rect1.X + rect1.Width > rect2.X &&
           rect1.Y < rect2.Y + rect2.Height &&
           rect1.Y + rect1.Height > rect2.Y;
  }

  public void Update(double deltaTime)
  {
    _player.Update(deltaTime, _platforms);

    Night.Rectangle playerBoundsForGoalCheck = new Night.Rectangle((int)_player.X, (int)_player.Y, _player.Width, _player.Height + 1);
    if (CheckAABBCollision(playerBoundsForGoalCheck, _goalPlatform) && !_goalReachedMessageShown)
    {
      // Simple win condition: print a message.
      Console.WriteLine("Congratulations! Goal Reached!");
      _goalReachedMessageShown = true;
    }
  }

  public void Draw()
  {
    Night.Graphics.Clear(new Night.Color(135, 206, 235)); // Sky blue background

    // Draw platforms
    if (_platformSprite != null)
    {
      foreach (var platform in _platforms)
      {
        // Scale the 1x1 pixel sprite to the platform's dimensions
        Graphics.Draw(
            sprite: _platformSprite,
            x: platform.X,
            y: platform.Y,
            rotation: 0,
            scaleX: platform.Width,
            scaleY: platform.Height
        );
      }
    }

    _player.Draw();
    // Player and Level drawing logic will go here in later tasks.
  }

  public void KeyPressed(KeySymbol key, KeyCode scancode, bool isRepeat)
  {
    // Minimal key handling for now, primarily for closing the window.
    // System.Console.WriteLine($"SampleGame: KeyPressed - KeySymbol: {key}, Scancode: {scancode}, IsRepeat: {isRepeat}");
    if (key == KeySymbol.Escape)
    {
      Console.WriteLine("SampleGame: Escape key pressed, closing window.");
      Window.Close();
    }
    // Player input (movement, jump) will be handled in Player.Update using Night.Keyboard.IsDown().
  }
}

public class PlatformerGame
{
  public static void PlatformerGameMain()
  {
    Night.Framework.Run(new Platformer());
  }
}




================================================
File: src/SampleGame/assets/images/pixel_green.pixi
================================================
[Non-text file]


================================================
File: src/SampleGame/assets/images/player_sprite_blue_32x64.aseprite
================================================
[Non-text file]


================================================
File: src/SampleGame/bin/Debug/net9.0/Night.SampleGame
================================================
[Non-text file]


================================================
File: src/SampleGame/bin/Debug/net9.0/Night.SampleGame.deps.json
================================================
{
  "runtimeTarget": {
    "name": ".NETCoreApp,Version=v9.0",
    "signature": ""
  },
  "compilationOptions": {},
  "targets": {
    ".NETCoreApp,Version=v9.0": {
      "Night.SampleGame/1.0.0": {
        "dependencies": {
          "Night": "1.0.0"
        },
        "runtime": {
          "Night.SampleGame.dll": {}
        }
      },
      "SDL3-CS/3.2.14.2": {
        "runtime": {
          "lib/net9.0/SDL3-CS.dll": {
            "assemblyVersion": "3.2.14.2",
            "fileVersion": "3.2.14.2"
          }
        }
      },
      "Night/1.0.0": {
        "dependencies": {
          "SDL3-CS": "3.2.14.2"
        },
        "runtime": {
          "Night.dll": {
            "assemblyVersion": "1.0.0.0",
            "fileVersion": "1.0.0.0"
          }
        }
      }
    }
  },
  "libraries": {
    "Night.SampleGame/1.0.0": {
      "type": "project",
      "serviceable": false,
      "sha512": ""
    },
    "SDL3-CS/3.2.14.2": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-wqWjIm2EP7PmXRQfwSxY4YJDSrXZ0QmolJMCJcs9KY4b3vYBdlwo0U4/olPMdBx6yRzqhN1nGJjmeC9OJT6L1g==",
      "path": "sdl3-cs/3.2.14.2",
      "hashPath": "sdl3-cs.3.2.14.2.nupkg.sha512"
    },
    "Night/1.0.0": {
      "type": "project",
      "serviceable": false,
      "sha512": ""
    }
  }
}


================================================
File: src/SampleGame/bin/Debug/net9.0/Night.SampleGame.runtimeconfig.json
================================================
{
  "runtimeOptions": {
    "tfm": "net9.0",
    "framework": {
      "name": "Microsoft.NETCore.App",
      "version": "9.0.0"
    },
    "configProperties": {
      "System.Runtime.Serialization.EnableUnsafeBinaryFormatterSerialization": false
    }
  }
}


================================================
File: src/SampleGame/bin/Debug/net9.0/config.json
================================================
{
  "window": {
    "title": "Configured by JSON!",
    "width": 1024,
    "height": 768,
    "resizable": true,
    "vsync": 0,
    "fullscreen": false,
    "borderless": true,
    "x": 100,
    "y": 100
  }
} 



================================================
File: src/SampleGame/bin/Debug/net9.0/assets/images/pixel_green.pixi
================================================
[Non-text file]


================================================
File: src/SampleGame/bin/Debug/net9.0/assets/images/player_sprite_blue_32x64.aseprite
================================================
[Non-text file]


================================================
File: src/SampleGame/obj/Night.SampleGame.csproj.nuget.dgspec.json
================================================
{
  "format": 1,
  "restore": {
    "/home/danny/git/any2/src/SampleGame/Night.SampleGame.csproj": {}
  },
  "projects": {
    "/home/danny/git/any2/src/Night/Night.csproj": {
      "version": "1.0.0",
      "restore": {
        "projectUniqueName": "/home/danny/git/any2/src/Night/Night.csproj",
        "projectName": "Night",
        "projectPath": "/home/danny/git/any2/src/Night/Night.csproj",
        "packagesPath": "/home/danny/.nuget/packages/",
        "outputPath": "/home/danny/git/any2/src/Night/obj/",
        "projectStyle": "PackageReference",
        "configFilePaths": [
          "/home/danny/.nuget/NuGet/NuGet.Config"
        ],
        "originalTargetFrameworks": [
          "net9.0"
        ],
        "sources": {
          "https://api.nuget.org/v3/index.json": {}
        },
        "frameworks": {
          "net9.0": {
            "targetAlias": "net9.0",
            "projectReferences": {}
          }
        },
        "warningProperties": {
          "warnAsError": [
            "NU1605"
          ]
        },
        "restoreAuditProperties": {
          "enableAudit": "true",
          "auditLevel": "low",
          "auditMode": "direct"
        },
        "SdkAnalysisLevel": "9.0.300"
      },
      "frameworks": {
        "net9.0": {
          "targetAlias": "net9.0",
          "dependencies": {
            "SDL3-CS": {
              "target": "Package",
              "version": "[*, )"
            }
          },
          "imports": [
            "net461",
            "net462",
            "net47",
            "net471",
            "net472",
            "net48",
            "net481"
          ],
          "assetTargetFallback": true,
          "warn": true,
          "frameworkReferences": {
            "Microsoft.NETCore.App": {
              "privateAssets": "all"
            }
          },
          "runtimeIdentifierGraphPath": "/home/danny/.local/share/mise/installs/dotnet/9.0.300/sdk/9.0.300/PortableRuntimeIdentifierGraph.json"
        }
      }
    },
    "/home/danny/git/any2/src/SampleGame/Night.SampleGame.csproj": {
      "version": "1.0.0",
      "restore": {
        "projectUniqueName": "/home/danny/git/any2/src/SampleGame/Night.SampleGame.csproj",
        "projectName": "Night.SampleGame",
        "projectPath": "/home/danny/git/any2/src/SampleGame/Night.SampleGame.csproj",
        "packagesPath": "/home/danny/.nuget/packages/",
        "outputPath": "/home/danny/git/any2/src/SampleGame/obj/",
        "projectStyle": "PackageReference",
        "configFilePaths": [
          "/home/danny/.nuget/NuGet/NuGet.Config"
        ],
        "originalTargetFrameworks": [
          "net9.0"
        ],
        "sources": {
          "https://api.nuget.org/v3/index.json": {}
        },
        "frameworks": {
          "net9.0": {
            "targetAlias": "net9.0",
            "projectReferences": {
              "/home/danny/git/any2/src/Night/Night.csproj": {
                "projectPath": "/home/danny/git/any2/src/Night/Night.csproj"
              }
            }
          }
        },
        "warningProperties": {
          "warnAsError": [
            "NU1605"
          ]
        },
        "restoreAuditProperties": {
          "enableAudit": "true",
          "auditLevel": "low",
          "auditMode": "direct"
        },
        "SdkAnalysisLevel": "9.0.300"
      },
      "frameworks": {
        "net9.0": {
          "targetAlias": "net9.0",
          "imports": [
            "net461",
            "net462",
            "net47",
            "net471",
            "net472",
            "net48",
            "net481"
          ],
          "assetTargetFallback": true,
          "warn": true,
          "frameworkReferences": {
            "Microsoft.NETCore.App": {
              "privateAssets": "all"
            }
          },
          "runtimeIdentifierGraphPath": "/home/danny/.local/share/mise/installs/dotnet/9.0.300/sdk/9.0.300/PortableRuntimeIdentifierGraph.json"
        }
      }
    }
  }
}


================================================
File: src/SampleGame/obj/Night.SampleGame.csproj.nuget.g.props
================================================
﻿<?xml version="1.0" encoding="utf-8" standalone="no"?>
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition=" '$(ExcludeRestorePackageImports)' != 'true' ">
    <RestoreSuccess Condition=" '$(RestoreSuccess)' == '' ">True</RestoreSuccess>
    <RestoreTool Condition=" '$(RestoreTool)' == '' ">NuGet</RestoreTool>
    <ProjectAssetsFile Condition=" '$(ProjectAssetsFile)' == '' ">$(MSBuildThisFileDirectory)project.assets.json</ProjectAssetsFile>
    <NuGetPackageRoot Condition=" '$(NuGetPackageRoot)' == '' ">/home/danny/.nuget/packages/</NuGetPackageRoot>
    <NuGetPackageFolders Condition=" '$(NuGetPackageFolders)' == '' ">/home/danny/.nuget/packages/</NuGetPackageFolders>
    <NuGetProjectStyle Condition=" '$(NuGetProjectStyle)' == '' ">PackageReference</NuGetProjectStyle>
    <NuGetToolVersion Condition=" '$(NuGetToolVersion)' == '' ">6.14.0</NuGetToolVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(ExcludeRestorePackageImports)' != 'true' ">
    <SourceRoot Include="/home/danny/.nuget/packages/" />
  </ItemGroup>
</Project>


================================================
File: src/SampleGame/obj/Night.SampleGame.csproj.nuget.g.targets
================================================
﻿<?xml version="1.0" encoding="utf-8" standalone="no"?>
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />


================================================
File: src/SampleGame/obj/project.assets.json
================================================
{
  "version": 3,
  "targets": {
    "net9.0": {
      "SDL3-CS/3.2.14.2": {
        "type": "package",
        "compile": {
          "lib/net9.0/SDL3-CS.dll": {
            "related": ".xml"
          }
        },
        "runtime": {
          "lib/net9.0/SDL3-CS.dll": {
            "related": ".xml"
          }
        }
      },
      "Night/1.0.0": {
        "type": "project",
        "framework": ".NETCoreApp,Version=v9.0",
        "dependencies": {
          "SDL3-CS": "0.0.0"
        },
        "compile": {
          "bin/placeholder/Night.dll": {}
        },
        "runtime": {
          "bin/placeholder/Night.dll": {}
        }
      }
    }
  },
  "libraries": {
    "SDL3-CS/3.2.14.2": {
      "sha512": "wqWjIm2EP7PmXRQfwSxY4YJDSrXZ0QmolJMCJcs9KY4b3vYBdlwo0U4/olPMdBx6yRzqhN1nGJjmeC9OJT6L1g==",
      "type": "package",
      "path": "sdl3-cs/3.2.14.2",
      "files": [
        ".nupkg.metadata",
        ".signature.p7s",
        "CODE_OF_CONDUCT.md",
        "LICENSE",
        "README-nuget.md",
        "README.md",
        "SDL3-CS.xml",
        "lib/net7.0/SDL3-CS.dll",
        "lib/net7.0/SDL3-CS.xml",
        "lib/net8.0/SDL3-CS.dll",
        "lib/net8.0/SDL3-CS.xml",
        "lib/net9.0/SDL3-CS.dll",
        "lib/net9.0/SDL3-CS.xml",
        "logo.png",
        "sdl3-cs.3.2.14.2.nupkg.sha512",
        "sdl3-cs.nuspec"
      ]
    },
    "Night/1.0.0": {
      "type": "project",
      "path": "../Night/Night.csproj",
      "msbuildProject": "../Night/Night.csproj"
    }
  },
  "projectFileDependencyGroups": {
    "net9.0": [
      "Night >= 1.0.0"
    ]
  },
  "packageFolders": {
    "/home/danny/.nuget/packages/": {}
  },
  "project": {
    "version": "1.0.0",
    "restore": {
      "projectUniqueName": "/home/danny/git/any2/src/SampleGame/Night.SampleGame.csproj",
      "projectName": "Night.SampleGame",
      "projectPath": "/home/danny/git/any2/src/SampleGame/Night.SampleGame.csproj",
      "packagesPath": "/home/danny/.nuget/packages/",
      "outputPath": "/home/danny/git/any2/src/SampleGame/obj/",
      "projectStyle": "PackageReference",
      "configFilePaths": [
        "/home/danny/.nuget/NuGet/NuGet.Config"
      ],
      "originalTargetFrameworks": [
        "net9.0"
      ],
      "sources": {
        "https://api.nuget.org/v3/index.json": {}
      },
      "frameworks": {
        "net9.0": {
          "targetAlias": "net9.0",
          "projectReferences": {
            "/home/danny/git/any2/src/Night/Night.csproj": {
              "projectPath": "/home/danny/git/any2/src/Night/Night.csproj"
            }
          }
        }
      },
      "warningProperties": {
        "warnAsError": [
          "NU1605"
        ]
      },
      "restoreAuditProperties": {
        "enableAudit": "true",
        "auditLevel": "low",
        "auditMode": "direct"
      },
      "SdkAnalysisLevel": "9.0.300"
    },
    "frameworks": {
      "net9.0": {
        "targetAlias": "net9.0",
        "imports": [
          "net461",
          "net462",
          "net47",
          "net471",
          "net472",
          "net48",
          "net481"
        ],
        "assetTargetFallback": true,
        "warn": true,
        "frameworkReferences": {
          "Microsoft.NETCore.App": {
            "privateAssets": "all"
          }
        },
        "runtimeIdentifierGraphPath": "/home/danny/.local/share/mise/installs/dotnet/9.0.300/sdk/9.0.300/PortableRuntimeIdentifierGraph.json"
      }
    }
  }
}


================================================
File: src/SampleGame/obj/project.nuget.cache
================================================
{
  "version": 2,
  "dgSpecHash": "1S4DG1WS0dM=",
  "success": true,
  "projectFilePath": "/home/danny/git/any2/src/SampleGame/Night.SampleGame.csproj",
  "expectedPackageFiles": [
    "/home/danny/.nuget/packages/sdl3-cs/3.2.14.2/sdl3-cs.3.2.14.2.nupkg.sha512"
  ],
  "logs": []
}


================================================
File: src/SampleGame/obj/Debug/net9.0/Night.Sa.E6945040.Up2Date
================================================



================================================
File: src/SampleGame/obj/Debug/net9.0/Night.SampleGame.AssemblyInfo.cs
================================================
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Night.SampleGame")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+0525ee88c265b33fa6724e0db77184b53b4d713c")]
[assembly: System.Reflection.AssemblyProductAttribute("Night.SampleGame")]
[assembly: System.Reflection.AssemblyTitleAttribute("Night.SampleGame")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.




================================================
File: src/SampleGame/obj/Debug/net9.0/Night.SampleGame.AssemblyInfoInputs.cache
================================================
7a940e472a22722aeba609865d00e199bddba40d4329a5b1c71603f240779c8d



================================================
File: src/SampleGame/obj/Debug/net9.0/Night.SampleGame.GeneratedMSBuildEditorConfig.editorconfig
================================================
is_global = true
build_property.TargetFramework = net9.0
build_property.TargetPlatformMinVersion = 
build_property.UsingMicrosoftNETSdkWeb = 
build_property.ProjectTypeGuids = 
build_property.InvariantGlobalization = 
build_property.PlatformNeutralAssembly = 
build_property.EnforceExtendedAnalyzerRules = 
build_property._SupportedPlatformList = Linux,macOS,Windows
build_property.RootNamespace = Night.SampleGame
build_property.ProjectDir = /home/danny/git/any2/src/SampleGame/
build_property.EnableComHosting = 
build_property.EnableGeneratedComInterfaceComImportInterop = 
build_property.EffectiveAnalysisLevelStyle = 9.0
build_property.EnableCodeStyleSeverity = 



================================================
File: src/SampleGame/obj/Debug/net9.0/Night.SampleGame.GlobalUsings.g.cs
================================================
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;



================================================
File: src/SampleGame/obj/Debug/net9.0/Night.SampleGame.assets.cache
================================================
[Non-text file]


================================================
File: src/SampleGame/obj/Debug/net9.0/Night.SampleGame.csproj.AssemblyReference.cache
================================================
[Non-text file]


================================================
File: src/SampleGame/obj/Debug/net9.0/Night.SampleGame.csproj.CoreCompileInputs.cache
================================================
40a675710048616e9ebe3cc1ca61c3510b0c9f84cfd8fad5e5d55c4fc11cacfa



================================================
File: src/SampleGame/obj/Debug/net9.0/Night.SampleGame.genruntimeconfig.cache
================================================
dc347d346712591e5aae675a5692bedfe675e498f7c55e8de100f6e2ee179134



================================================
File: src/SampleGame/obj/Debug/net9.0/Night.SampleGame.sourcelink.json
================================================
{"documents":{"/home/danny/git/any2/*":"https://raw.githubusercontent.com/nightconcept/any2/0525ee88c265b33fa6724e0db77184b53b4d713c/*","/home/danny/git/any2/lib/SDL3-CS/*":"https://raw.githubusercontent.com/edwardgushchin/SDL3-CS/f910675dcf9e0825b10e97b8583c892e0eee14be/*"}}


================================================
File: src/SampleGame/obj/Debug/net9.0/apphost
================================================
[Non-text file]


================================================
File: src/SampleGame/obj/Debug/net9.0/.NETCoreApp,Version=v9.0.AssemblyAttributes.cs
================================================
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName = ".NET 9.0")]





================================================
File: tests/Night.Tests/FilesystemTests.cs
================================================
using System;
using System.IO;
using System.Text;

using Night;

using Xunit;

public class FilesystemTests : IDisposable
{
  private const string TestDir = "test_filesystem_temp";
  private const string TestFile = "test_file.txt";
  private const string TestSubDir = "test_subdir";
  private readonly string _testFilePath;
  private readonly string _testDirPath;
  private readonly string _testSubDirPath;
  private readonly string _testSymlinkFilePath;
  private readonly string _testSymlinkDirPath;


  public FilesystemTests()
  {
    // Create a temporary directory for test files relative to the test execution directory
    var executionPath = Path.GetDirectoryName(typeof(FilesystemTests).Assembly.Location);
    var testDirFullPath = Path.Combine(executionPath!, TestDir);
    _ = Directory.CreateDirectory(testDirFullPath);

    _testFilePath = Path.Combine(testDirFullPath, TestFile);
    _testDirPath = Path.Combine(testDirFullPath, "actual_dir_for_symlink");
    _testSubDirPath = Path.Combine(testDirFullPath, TestSubDir);
    _testSymlinkFilePath = Path.Combine(testDirFullPath, "symlink_file.txt");
    _testSymlinkDirPath = Path.Combine(testDirFullPath, "symlink_dir");


    File.WriteAllText(_testFilePath, "Hello Night Engine!");
    _ = Directory.CreateDirectory(_testDirPath);
    _ = Directory.CreateDirectory(_testSubDirPath);

    // Create symlinks if supported (Windows requires admin rights or dev mode)
    try
    {
      _ = File.CreateSymbolicLink(_testSymlinkFilePath, _testFilePath);
    }
    catch (IOException ex) // More specific exception for symlink creation issues
    {
      Console.WriteLine($"Could not create file symlink: {ex.Message}. This test might be skipped or fail if symlinks are essential.");
    }
    catch (Exception ex) // Catch other potential exceptions
    {
      Console.WriteLine($"An unexpected error occurred during file symlink creation: {ex.Message}");
    }
    try
    {
      _ = Directory.CreateSymbolicLink(_testSymlinkDirPath, _testDirPath);
    }
    catch (IOException ex) // More specific exception for symlink creation issues
    {
      Console.WriteLine($"Could not create directory symlink: {ex.Message}. This test might be skipped or fail if symlinks are essential.");
    }
    catch (Exception ex) // Catch other potential exceptions
    {
      Console.WriteLine($"An unexpected error occurred during directory symlink creation: {ex.Message}");
    }
  }

  public void Dispose()
  {
    // Clean up the temporary directory
    var executionPath = Path.GetDirectoryName(typeof(FilesystemTests).Assembly.Location);
    var testDirFullPath = Path.Combine(executionPath!, TestDir);
    if (Directory.Exists(testDirFullPath))
    {
      Directory.Delete(testDirFullPath, true);
    }
  }

  [Fact]
  public void GetInfo_NullPath_ReturnsNull()
  {
    Assert.Null(Night.Filesystem.GetInfo(null!));
  }

  [Fact]
  public void GetInfo_EmptyPath_ReturnsNull()
  {
    Assert.Null(Night.Filesystem.GetInfo(""));
  }

  [Fact]
  public void GetInfo_NonExistentPath_ReturnsNull()
  {
    var executionPath = Path.GetDirectoryName(typeof(FilesystemTests).Assembly.Location);
    var testDirFullPath = Path.Combine(executionPath!, TestDir);
    Assert.Null(Night.Filesystem.GetInfo(Path.Combine(testDirFullPath, "non_existent_file.txt")));
  }

  [Fact]
  public void GetInfo_ExistingFile_ReturnsFileInfo()
  {
    var info = Night.Filesystem.GetInfo(_testFilePath);
    Assert.NotNull(info);
    Assert.Equal(Night.FileType.File, info.Type);
    Assert.Equal(new FileInfo(_testFilePath).Length, info.Size);
    _ = Assert.NotNull(info.ModTime);
  }

  [Fact]
  public void GetInfo_ExistingFile_WithFilterTypeFile_ReturnsFileInfo()
  {
    var info = Night.Filesystem.GetInfo(_testFilePath, Night.FileType.File);
    Assert.NotNull(info);
    Assert.Equal(Night.FileType.File, info.Type);
  }

  [Fact]
  public void GetInfo_ExistingFile_WithFilterTypeDirectory_ReturnsNull()
  {
    var info = Night.Filesystem.GetInfo(_testFilePath, Night.FileType.Directory);
    Assert.Null(info);
  }

  [Fact]
  public void GetInfo_ExistingDirectory_ReturnsDirectoryInfo()
  {
    var info = Night.Filesystem.GetInfo(_testSubDirPath);
    Assert.NotNull(info);
    Assert.Equal(Night.FileType.Directory, info.Type);
    Assert.Null(info.Size); // Size is null for directories in our implementation
    _ = Assert.NotNull(info.ModTime);
  }

  [Fact]
  public void GetInfo_ExistingDirectory_WithFilterTypeDirectory_ReturnsDirectoryInfo()
  {
    var info = Night.Filesystem.GetInfo(_testSubDirPath, Night.FileType.Directory);
    Assert.NotNull(info);
    Assert.Equal(Night.FileType.Directory, info.Type);
  }

  [Fact]
  public void GetInfo_ExistingDirectory_WithFilterTypeFile_ReturnsNull()
  {
    var info = Night.Filesystem.GetInfo(_testSubDirPath, Night.FileType.File);
    Assert.Null(info);
  }

  [Fact]
  public void GetInfo_FileSymlink_ReturnsSymlinkInfo()
  {
    if (!File.Exists(_testSymlinkFilePath) && !Directory.Exists(_testSymlinkFilePath) /* Symlink could point to dir or file, check both just in case File.Exists is tricky with broken file symlinks */)
    {
      // Skip if symlink creation failed (e.g. permissions on Windows or if it points to a now-deleted item and File.Exists returns false)
      Console.WriteLine($"Skipping symlink test for file: {_testSymlinkFilePath} as it does not exist or could not be verified.");
      return;
    }
    var info = Night.Filesystem.GetInfo(_testSymlinkFilePath);
    Assert.NotNull(info);
    Assert.Equal(Night.FileType.Symlink, info.Type);
  }

  [Fact]
  public void GetInfo_DirectorySymlink_ReturnsSymlinkInfo()
  {
    if (!Directory.Exists(_testSymlinkDirPath)) // Directory.Exists should work for directory symlinks
    {
      // Skip if symlink creation failed (e.g. permissions on Windows)
      Console.WriteLine($"Skipping symlink test for directory: {_testSymlinkDirPath} as it does not exist or could not be verified.");
      return;
    }
    var info = Night.Filesystem.GetInfo(_testSymlinkDirPath);
    Assert.NotNull(info);
    Assert.Equal(Night.FileType.Symlink, info.Type);
  }

  [Fact]
  public void GetInfo_PopulatesExistingObject_ValidPath()
  {
    var existingInfo = new Night.FileSystemInfo(Night.FileType.File, 0, 0); // Dummy initial values
    var result = Night.Filesystem.GetInfo(_testFilePath, existingInfo);

    Assert.NotNull(result);
    Assert.Same(existingInfo, result);
    Assert.Equal(Night.FileType.File, existingInfo.Type);
    Assert.Equal(new FileInfo(_testFilePath).Length, existingInfo.Size);
  }

  [Fact]
  public void GetInfo_PopulatesExistingObject_NonExistentPath_ReturnsNullAndDoesNotChangeObject()
  {
    var originalType = Night.FileType.Other; // Different from what GetInfo might set
    long? originalSize = 12345;
    long? originalModTime = 67890;
    var executionPath = Path.GetDirectoryName(typeof(FilesystemTests).Assembly.Location);
    var testDirFullPath = Path.Combine(executionPath!, TestDir);

    var existingInfo = new Night.FileSystemInfo(originalType, originalSize, originalModTime);
    var result = Night.Filesystem.GetInfo(Path.Combine(testDirFullPath, "non_existent_file.txt"), existingInfo);

    Assert.Null(result);
    // Check that the original object was not modified
    Assert.Equal(originalType, existingInfo.Type);
    Assert.Equal(originalSize, existingInfo.Size);
    Assert.Equal(originalModTime, existingInfo.ModTime);
  }

  [Fact]
  public void GetInfo_PopulatesExistingObjectWithFilter_ValidPathAndType()
  {
    var existingInfo = new Night.FileSystemInfo(Night.FileType.Directory, 0, 0); // Dummy initial values
    var result = Night.Filesystem.GetInfo(_testFilePath, Night.FileType.File, existingInfo);

    Assert.NotNull(result);
    Assert.Same(existingInfo, result);
    Assert.Equal(Night.FileType.File, existingInfo.Type);
  }

  [Fact]
  public void GetInfo_PopulatesExistingObjectWithFilter_PathExistsButWrongType_ReturnsNull()
  {
    var originalType = Night.FileType.Other;
    var existingInfo = new Night.FileSystemInfo(originalType, null, null);
    var result = Night.Filesystem.GetInfo(_testFilePath, Night.FileType.Directory, existingInfo); // File exists, but asking for Directory type

    Assert.Null(result);
    Assert.Equal(originalType, existingInfo.Type); // Should not have been modified
  }


  [Fact]
  public void ReadBytes_ExistingFile_ReturnsCorrectBytes()
  {
    var expectedBytes = Encoding.UTF8.GetBytes("Hello Night Engine!");
    var actualBytes = Night.Filesystem.ReadBytes(_testFilePath);
    Assert.Equal(expectedBytes, actualBytes);
  }

  [Fact]
  public void ReadBytes_NonExistentFile_ThrowsFileNotFound()
  {
    var executionPath = Path.GetDirectoryName(typeof(FilesystemTests).Assembly.Location);
    var testDirFullPath = Path.Combine(executionPath!, TestDir);
    _ = Assert.Throws<FileNotFoundException>(() => Night.Filesystem.ReadBytes(Path.Combine(testDirFullPath, "non_existent_file_for_read.txt")));
  }

  [Fact]
  public void ReadText_ExistingFile_ReturnsCorrectText()
  {
    var expectedText = "Hello Night Engine!";
    var actualText = Night.Filesystem.ReadText(_testFilePath);
    Assert.Equal(expectedText, actualText);
  }

  [Fact]
  public void ReadText_NonExistentFile_ThrowsFileNotFound()
  {
    var executionPath = Path.GetDirectoryName(typeof(FilesystemTests).Assembly.Location);
    var testDirFullPath = Path.Combine(executionPath!, TestDir);
    _ = Assert.Throws<FileNotFoundException>(() => Night.Filesystem.ReadText(Path.Combine(testDirFullPath, "non_existent_file_for_read.txt")));
  }
}



================================================
File: tests/Night.Tests/Night.Tests.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <AssemblyName>Night.Tests</AssemblyName>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\src\Night\Night.csproj" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="coverlet.collector" Version="6.0.2" />
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.12.0" />
    <PackageReference Include="xunit" Version="2.9.2" />
    <PackageReference Include="xunit.runner.visualstudio" Version="2.8.2" />
  </ItemGroup>

  <ItemGroup>
    <Using Include="Xunit" />
  </ItemGroup>

</Project>



================================================
File: tests/Night.Tests/UnitTest1.cs
================================================
﻿namespace Night.Engine.Tests;

public class UnitTest1
{
  [Fact]
  public void Test1()
  {

  }
}



================================================
File: tests/Night.Tests/bin/Debug/net9.0/CoverletSourceRootsMapping_Night.Tests
================================================
[Non-text file]


================================================
File: tests/Night.Tests/bin/Debug/net9.0/Night.Tests.deps.json
================================================
{
  "runtimeTarget": {
    "name": ".NETCoreApp,Version=v9.0",
    "signature": ""
  },
  "compilationOptions": {},
  "targets": {
    ".NETCoreApp,Version=v9.0": {
      "Night.Tests/1.0.0": {
        "dependencies": {
          "Microsoft.NET.Test.Sdk": "17.12.0",
          "Night": "1.0.0",
          "coverlet.collector": "6.0.2",
          "xunit": "2.9.2",
          "xunit.runner.visualstudio": "2.8.2"
        },
        "runtime": {
          "Night.Tests.dll": {}
        }
      },
      "coverlet.collector/6.0.2": {},
      "Microsoft.CodeCoverage/17.12.0": {
        "runtime": {
          "lib/netcoreapp3.1/Microsoft.VisualStudio.CodeCoverage.Shim.dll": {
            "assemblyVersion": "15.0.0.0",
            "fileVersion": "17.1200.524.48002"
          }
        }
      },
      "Microsoft.NET.Test.Sdk/17.12.0": {
        "dependencies": {
          "Microsoft.CodeCoverage": "17.12.0",
          "Microsoft.TestPlatform.TestHost": "17.12.0"
        }
      },
      "Microsoft.TestPlatform.ObjectModel/17.12.0": {
        "dependencies": {
          "System.Reflection.Metadata": "1.6.0"
        },
        "runtime": {
          "lib/netcoreapp3.1/Microsoft.TestPlatform.CoreUtilities.dll": {
            "assemblyVersion": "15.0.0.0",
            "fileVersion": "17.1200.24.56501"
          },
          "lib/netcoreapp3.1/Microsoft.TestPlatform.PlatformAbstractions.dll": {
            "assemblyVersion": "15.0.0.0",
            "fileVersion": "17.1200.24.56501"
          },
          "lib/netcoreapp3.1/Microsoft.VisualStudio.TestPlatform.ObjectModel.dll": {
            "assemblyVersion": "15.0.0.0",
            "fileVersion": "17.1200.24.56501"
          }
        },
        "resources": {
          "lib/netcoreapp3.1/cs/Microsoft.TestPlatform.CoreUtilities.resources.dll": {
            "locale": "cs"
          },
          "lib/netcoreapp3.1/cs/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll": {
            "locale": "cs"
          },
          "lib/netcoreapp3.1/de/Microsoft.TestPlatform.CoreUtilities.resources.dll": {
            "locale": "de"
          },
          "lib/netcoreapp3.1/de/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll": {
            "locale": "de"
          },
          "lib/netcoreapp3.1/es/Microsoft.TestPlatform.CoreUtilities.resources.dll": {
            "locale": "es"
          },
          "lib/netcoreapp3.1/es/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll": {
            "locale": "es"
          },
          "lib/netcoreapp3.1/fr/Microsoft.TestPlatform.CoreUtilities.resources.dll": {
            "locale": "fr"
          },
          "lib/netcoreapp3.1/fr/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll": {
            "locale": "fr"
          },
          "lib/netcoreapp3.1/it/Microsoft.TestPlatform.CoreUtilities.resources.dll": {
            "locale": "it"
          },
          "lib/netcoreapp3.1/it/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll": {
            "locale": "it"
          },
          "lib/netcoreapp3.1/ja/Microsoft.TestPlatform.CoreUtilities.resources.dll": {
            "locale": "ja"
          },
          "lib/netcoreapp3.1/ja/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll": {
            "locale": "ja"
          },
          "lib/netcoreapp3.1/ko/Microsoft.TestPlatform.CoreUtilities.resources.dll": {
            "locale": "ko"
          },
          "lib/netcoreapp3.1/ko/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll": {
            "locale": "ko"
          },
          "lib/netcoreapp3.1/pl/Microsoft.TestPlatform.CoreUtilities.resources.dll": {
            "locale": "pl"
          },
          "lib/netcoreapp3.1/pl/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll": {
            "locale": "pl"
          },
          "lib/netcoreapp3.1/pt-BR/Microsoft.TestPlatform.CoreUtilities.resources.dll": {
            "locale": "pt-BR"
          },
          "lib/netcoreapp3.1/pt-BR/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll": {
            "locale": "pt-BR"
          },
          "lib/netcoreapp3.1/ru/Microsoft.TestPlatform.CoreUtilities.resources.dll": {
            "locale": "ru"
          },
          "lib/netcoreapp3.1/ru/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll": {
            "locale": "ru"
          },
          "lib/netcoreapp3.1/tr/Microsoft.TestPlatform.CoreUtilities.resources.dll": {
            "locale": "tr"
          },
          "lib/netcoreapp3.1/tr/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll": {
            "locale": "tr"
          },
          "lib/netcoreapp3.1/zh-Hans/Microsoft.TestPlatform.CoreUtilities.resources.dll": {
            "locale": "zh-Hans"
          },
          "lib/netcoreapp3.1/zh-Hans/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll": {
            "locale": "zh-Hans"
          },
          "lib/netcoreapp3.1/zh-Hant/Microsoft.TestPlatform.CoreUtilities.resources.dll": {
            "locale": "zh-Hant"
          },
          "lib/netcoreapp3.1/zh-Hant/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll": {
            "locale": "zh-Hant"
          }
        }
      },
      "Microsoft.TestPlatform.TestHost/17.12.0": {
        "dependencies": {
          "Microsoft.TestPlatform.ObjectModel": "17.12.0",
          "Newtonsoft.Json": "13.0.1"
        },
        "runtime": {
          "lib/netcoreapp3.1/Microsoft.TestPlatform.CommunicationUtilities.dll": {
            "assemblyVersion": "15.0.0.0",
            "fileVersion": "17.1200.24.56501"
          },
          "lib/netcoreapp3.1/Microsoft.TestPlatform.CrossPlatEngine.dll": {
            "assemblyVersion": "15.0.0.0",
            "fileVersion": "17.1200.24.56501"
          },
          "lib/netcoreapp3.1/Microsoft.TestPlatform.Utilities.dll": {
            "assemblyVersion": "15.0.0.0",
            "fileVersion": "17.1200.24.56501"
          },
          "lib/netcoreapp3.1/Microsoft.VisualStudio.TestPlatform.Common.dll": {
            "assemblyVersion": "15.0.0.0",
            "fileVersion": "17.1200.24.56501"
          },
          "lib/netcoreapp3.1/testhost.dll": {
            "assemblyVersion": "15.0.0.0",
            "fileVersion": "17.1200.24.56501"
          }
        },
        "resources": {
          "lib/netcoreapp3.1/cs/Microsoft.TestPlatform.CommunicationUtilities.resources.dll": {
            "locale": "cs"
          },
          "lib/netcoreapp3.1/cs/Microsoft.TestPlatform.CrossPlatEngine.resources.dll": {
            "locale": "cs"
          },
          "lib/netcoreapp3.1/cs/Microsoft.VisualStudio.TestPlatform.Common.resources.dll": {
            "locale": "cs"
          },
          "lib/netcoreapp3.1/de/Microsoft.TestPlatform.CommunicationUtilities.resources.dll": {
            "locale": "de"
          },
          "lib/netcoreapp3.1/de/Microsoft.TestPlatform.CrossPlatEngine.resources.dll": {
            "locale": "de"
          },
          "lib/netcoreapp3.1/de/Microsoft.VisualStudio.TestPlatform.Common.resources.dll": {
            "locale": "de"
          },
          "lib/netcoreapp3.1/es/Microsoft.TestPlatform.CommunicationUtilities.resources.dll": {
            "locale": "es"
          },
          "lib/netcoreapp3.1/es/Microsoft.TestPlatform.CrossPlatEngine.resources.dll": {
            "locale": "es"
          },
          "lib/netcoreapp3.1/es/Microsoft.VisualStudio.TestPlatform.Common.resources.dll": {
            "locale": "es"
          },
          "lib/netcoreapp3.1/fr/Microsoft.TestPlatform.CommunicationUtilities.resources.dll": {
            "locale": "fr"
          },
          "lib/netcoreapp3.1/fr/Microsoft.TestPlatform.CrossPlatEngine.resources.dll": {
            "locale": "fr"
          },
          "lib/netcoreapp3.1/fr/Microsoft.VisualStudio.TestPlatform.Common.resources.dll": {
            "locale": "fr"
          },
          "lib/netcoreapp3.1/it/Microsoft.TestPlatform.CommunicationUtilities.resources.dll": {
            "locale": "it"
          },
          "lib/netcoreapp3.1/it/Microsoft.TestPlatform.CrossPlatEngine.resources.dll": {
            "locale": "it"
          },
          "lib/netcoreapp3.1/it/Microsoft.VisualStudio.TestPlatform.Common.resources.dll": {
            "locale": "it"
          },
          "lib/netcoreapp3.1/ja/Microsoft.TestPlatform.CommunicationUtilities.resources.dll": {
            "locale": "ja"
          },
          "lib/netcoreapp3.1/ja/Microsoft.TestPlatform.CrossPlatEngine.resources.dll": {
            "locale": "ja"
          },
          "lib/netcoreapp3.1/ja/Microsoft.VisualStudio.TestPlatform.Common.resources.dll": {
            "locale": "ja"
          },
          "lib/netcoreapp3.1/ko/Microsoft.TestPlatform.CommunicationUtilities.resources.dll": {
            "locale": "ko"
          },
          "lib/netcoreapp3.1/ko/Microsoft.TestPlatform.CrossPlatEngine.resources.dll": {
            "locale": "ko"
          },
          "lib/netcoreapp3.1/ko/Microsoft.VisualStudio.TestPlatform.Common.resources.dll": {
            "locale": "ko"
          },
          "lib/netcoreapp3.1/pl/Microsoft.TestPlatform.CommunicationUtilities.resources.dll": {
            "locale": "pl"
          },
          "lib/netcoreapp3.1/pl/Microsoft.TestPlatform.CrossPlatEngine.resources.dll": {
            "locale": "pl"
          },
          "lib/netcoreapp3.1/pl/Microsoft.VisualStudio.TestPlatform.Common.resources.dll": {
            "locale": "pl"
          },
          "lib/netcoreapp3.1/pt-BR/Microsoft.TestPlatform.CommunicationUtilities.resources.dll": {
            "locale": "pt-BR"
          },
          "lib/netcoreapp3.1/pt-BR/Microsoft.TestPlatform.CrossPlatEngine.resources.dll": {
            "locale": "pt-BR"
          },
          "lib/netcoreapp3.1/pt-BR/Microsoft.VisualStudio.TestPlatform.Common.resources.dll": {
            "locale": "pt-BR"
          },
          "lib/netcoreapp3.1/ru/Microsoft.TestPlatform.CommunicationUtilities.resources.dll": {
            "locale": "ru"
          },
          "lib/netcoreapp3.1/ru/Microsoft.TestPlatform.CrossPlatEngine.resources.dll": {
            "locale": "ru"
          },
          "lib/netcoreapp3.1/ru/Microsoft.VisualStudio.TestPlatform.Common.resources.dll": {
            "locale": "ru"
          },
          "lib/netcoreapp3.1/tr/Microsoft.TestPlatform.CommunicationUtilities.resources.dll": {
            "locale": "tr"
          },
          "lib/netcoreapp3.1/tr/Microsoft.TestPlatform.CrossPlatEngine.resources.dll": {
            "locale": "tr"
          },
          "lib/netcoreapp3.1/tr/Microsoft.VisualStudio.TestPlatform.Common.resources.dll": {
            "locale": "tr"
          },
          "lib/netcoreapp3.1/zh-Hans/Microsoft.TestPlatform.CommunicationUtilities.resources.dll": {
            "locale": "zh-Hans"
          },
          "lib/netcoreapp3.1/zh-Hans/Microsoft.TestPlatform.CrossPlatEngine.resources.dll": {
            "locale": "zh-Hans"
          },
          "lib/netcoreapp3.1/zh-Hans/Microsoft.VisualStudio.TestPlatform.Common.resources.dll": {
            "locale": "zh-Hans"
          },
          "lib/netcoreapp3.1/zh-Hant/Microsoft.TestPlatform.CommunicationUtilities.resources.dll": {
            "locale": "zh-Hant"
          },
          "lib/netcoreapp3.1/zh-Hant/Microsoft.TestPlatform.CrossPlatEngine.resources.dll": {
            "locale": "zh-Hant"
          },
          "lib/netcoreapp3.1/zh-Hant/Microsoft.VisualStudio.TestPlatform.Common.resources.dll": {
            "locale": "zh-Hant"
          }
        }
      },
      "Newtonsoft.Json/13.0.1": {
        "runtime": {
          "lib/netstandard2.0/Newtonsoft.Json.dll": {
            "assemblyVersion": "13.0.0.0",
            "fileVersion": "13.0.1.25517"
          }
        }
      },
      "SDL3-CS/3.2.14.2": {
        "runtime": {
          "lib/net9.0/SDL3-CS.dll": {
            "assemblyVersion": "3.2.14.2",
            "fileVersion": "3.2.14.2"
          }
        }
      },
      "System.Reflection.Metadata/1.6.0": {},
      "xunit/2.9.2": {
        "dependencies": {
          "xunit.analyzers": "1.16.0",
          "xunit.assert": "2.9.2",
          "xunit.core": "2.9.2"
        }
      },
      "xunit.abstractions/2.0.3": {
        "runtime": {
          "lib/netstandard2.0/xunit.abstractions.dll": {
            "assemblyVersion": "2.0.0.0",
            "fileVersion": "0.0.0.0"
          }
        }
      },
      "xunit.analyzers/1.16.0": {},
      "xunit.assert/2.9.2": {
        "runtime": {
          "lib/net6.0/xunit.assert.dll": {
            "assemblyVersion": "2.9.2.0",
            "fileVersion": "2.9.2.0"
          }
        }
      },
      "xunit.core/2.9.2": {
        "dependencies": {
          "xunit.extensibility.core": "2.9.2",
          "xunit.extensibility.execution": "2.9.2"
        }
      },
      "xunit.extensibility.core/2.9.2": {
        "dependencies": {
          "xunit.abstractions": "2.0.3"
        },
        "runtime": {
          "lib/netstandard1.1/xunit.core.dll": {
            "assemblyVersion": "2.9.2.0",
            "fileVersion": "2.9.2.0"
          }
        }
      },
      "xunit.extensibility.execution/2.9.2": {
        "dependencies": {
          "xunit.extensibility.core": "2.9.2"
        },
        "runtime": {
          "lib/netstandard1.1/xunit.execution.dotnet.dll": {
            "assemblyVersion": "2.9.2.0",
            "fileVersion": "2.9.2.0"
          }
        }
      },
      "xunit.runner.visualstudio/2.8.2": {},
      "Night/1.0.0": {
        "dependencies": {
          "SDL3-CS": "3.2.14.2"
        },
        "runtime": {
          "Night.dll": {
            "assemblyVersion": "1.0.0.0",
            "fileVersion": "1.0.0.0"
          }
        }
      }
    }
  },
  "libraries": {
    "Night.Tests/1.0.0": {
      "type": "project",
      "serviceable": false,
      "sha512": ""
    },
    "coverlet.collector/6.0.2": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-bJShQ6uWRTQ100ZeyiMqcFlhP7WJ+bCuabUs885dJiBEzMsJMSFr7BOyeCw4rgvQokteGi5rKQTlkhfQPUXg2A==",
      "path": "coverlet.collector/6.0.2",
      "hashPath": "coverlet.collector.6.0.2.nupkg.sha512"
    },
    "Microsoft.CodeCoverage/17.12.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-4svMznBd5JM21JIG2xZKGNanAHNXplxf/kQDFfLHXQ3OnpJkayRK/TjacFjA+EYmoyuNXHo/sOETEfcYtAzIrA==",
      "path": "microsoft.codecoverage/17.12.0",
      "hashPath": "microsoft.codecoverage.17.12.0.nupkg.sha512"
    },
    "Microsoft.NET.Test.Sdk/17.12.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-kt/PKBZ91rFCWxVIJZSgVLk+YR+4KxTuHf799ho8WNiK5ZQpJNAEZCAWX86vcKrs+DiYjiibpYKdGZP6+/N17w==",
      "path": "microsoft.net.test.sdk/17.12.0",
      "hashPath": "microsoft.net.test.sdk.17.12.0.nupkg.sha512"
    },
    "Microsoft.TestPlatform.ObjectModel/17.12.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-TDqkTKLfQuAaPcEb3pDDWnh7b3SyZF+/W9OZvWFp6eJCIiiYFdSB6taE2I6tWrFw5ywhzOb6sreoGJTI6m3rSQ==",
      "path": "microsoft.testplatform.objectmodel/17.12.0",
      "hashPath": "microsoft.testplatform.objectmodel.17.12.0.nupkg.sha512"
    },
    "Microsoft.TestPlatform.TestHost/17.12.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-MiPEJQNyADfwZ4pJNpQex+t9/jOClBGMiCiVVFuELCMSX2nmNfvUor3uFVxNNCg30uxDP8JDYfPnMXQzsfzYyg==",
      "path": "microsoft.testplatform.testhost/17.12.0",
      "hashPath": "microsoft.testplatform.testhost.17.12.0.nupkg.sha512"
    },
    "Newtonsoft.Json/13.0.1": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-ppPFpBcvxdsfUonNcvITKqLl3bqxWbDCZIzDWHzjpdAHRFfZe0Dw9HmA0+za13IdyrgJwpkDTDA9fHaxOrt20A==",
      "path": "newtonsoft.json/13.0.1",
      "hashPath": "newtonsoft.json.13.0.1.nupkg.sha512"
    },
    "SDL3-CS/3.2.14.2": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-wqWjIm2EP7PmXRQfwSxY4YJDSrXZ0QmolJMCJcs9KY4b3vYBdlwo0U4/olPMdBx6yRzqhN1nGJjmeC9OJT6L1g==",
      "path": "sdl3-cs/3.2.14.2",
      "hashPath": "sdl3-cs.3.2.14.2.nupkg.sha512"
    },
    "System.Reflection.Metadata/1.6.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-COC1aiAJjCoA5GBF+QKL2uLqEBew4JsCkQmoHKbN3TlOZKa2fKLz5CpiRQKDz0RsAOEGsVKqOD5bomsXq/4STQ==",
      "path": "system.reflection.metadata/1.6.0",
      "hashPath": "system.reflection.metadata.1.6.0.nupkg.sha512"
    },
    "xunit/2.9.2": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-7LhFS2N9Z6Xgg8aE5lY95cneYivRMfRI8v+4PATa4S64D5Z/Plkg0qa8dTRHSiGRgVZ/CL2gEfJDE5AUhOX+2Q==",
      "path": "xunit/2.9.2",
      "hashPath": "xunit.2.9.2.nupkg.sha512"
    },
    "xunit.abstractions/2.0.3": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-pot1I4YOxlWjIb5jmwvvQNbTrZ3lJQ+jUGkGjWE3hEFM0l5gOnBWS+H3qsex68s5cO52g+44vpGzhAt+42vwKg==",
      "path": "xunit.abstractions/2.0.3",
      "hashPath": "xunit.abstractions.2.0.3.nupkg.sha512"
    },
    "xunit.analyzers/1.16.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-hptYM7vGr46GUIgZt21YHO4rfuBAQS2eINbFo16CV/Dqq+24Tp+P5gDCACu1AbFfW4Sp/WRfDPSK8fmUUb8s0Q==",
      "path": "xunit.analyzers/1.16.0",
      "hashPath": "xunit.analyzers.1.16.0.nupkg.sha512"
    },
    "xunit.assert/2.9.2": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-QkNBAQG4pa66cholm28AxijBjrmki98/vsEh4Sx5iplzotvPgpiotcxqJQMRC8d7RV7nIT8ozh97957hDnZwsQ==",
      "path": "xunit.assert/2.9.2",
      "hashPath": "xunit.assert.2.9.2.nupkg.sha512"
    },
    "xunit.core/2.9.2": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-O6RrNSdmZ0xgEn5kT927PNwog5vxTtKrWMihhhrT0Sg9jQ7iBDciYOwzBgP2krBEk5/GBXI18R1lKvmnxGcb4w==",
      "path": "xunit.core/2.9.2",
      "hashPath": "xunit.core.2.9.2.nupkg.sha512"
    },
    "xunit.extensibility.core/2.9.2": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-Ol+KlBJz1x8BrdnhN2DeOuLrr1I/cTwtHCggL9BvYqFuVd/TUSzxNT5O0NxCIXth30bsKxgMfdqLTcORtM52yQ==",
      "path": "xunit.extensibility.core/2.9.2",
      "hashPath": "xunit.extensibility.core.2.9.2.nupkg.sha512"
    },
    "xunit.extensibility.execution/2.9.2": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-rKMpq4GsIUIJibXuZoZ8lYp5EpROlnYaRpwu9Zr0sRZXE7JqJfEEbCsUriZqB+ByXCLFBJyjkTRULMdC+U566g==",
      "path": "xunit.extensibility.execution/2.9.2",
      "hashPath": "xunit.extensibility.execution.2.9.2.nupkg.sha512"
    },
    "xunit.runner.visualstudio/2.8.2": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-vm1tbfXhFmjFMUmS4M0J0ASXz3/U5XvXBa6DOQUL3fEz4Vt6YPhv+ESCarx6M6D+9kJkJYZKCNvJMas1+nVfmQ==",
      "path": "xunit.runner.visualstudio/2.8.2",
      "hashPath": "xunit.runner.visualstudio.2.8.2.nupkg.sha512"
    },
    "Night/1.0.0": {
      "type": "project",
      "serviceable": false,
      "sha512": ""
    }
  }
}


================================================
File: tests/Night.Tests/bin/Debug/net9.0/Night.Tests.runtimeconfig.json
================================================
{
  "runtimeOptions": {
    "tfm": "net9.0",
    "framework": {
      "name": "Microsoft.NETCore.App",
      "version": "9.0.0"
    },
    "configProperties": {
      "System.Runtime.Serialization.EnableUnsafeBinaryFormatterSerialization": false
    }
  }
}


================================================
File: tests/Night.Tests/bin/Debug/net9.0/.msCoverageSourceRootsMapping_Night.Tests
================================================
[Non-text file]















================================================
File: tests/Night.Tests/obj/Night.Tests.csproj.nuget.dgspec.json
================================================
{
  "format": 1,
  "restore": {
    "/home/danny/git/any2/tests/Night.Tests/Night.Tests.csproj": {}
  },
  "projects": {
    "/home/danny/git/any2/src/Night/Night.csproj": {
      "version": "1.0.0",
      "restore": {
        "projectUniqueName": "/home/danny/git/any2/src/Night/Night.csproj",
        "projectName": "Night",
        "projectPath": "/home/danny/git/any2/src/Night/Night.csproj",
        "packagesPath": "/home/danny/.nuget/packages/",
        "outputPath": "/home/danny/git/any2/src/Night/obj/",
        "projectStyle": "PackageReference",
        "configFilePaths": [
          "/home/danny/.nuget/NuGet/NuGet.Config"
        ],
        "originalTargetFrameworks": [
          "net9.0"
        ],
        "sources": {
          "https://api.nuget.org/v3/index.json": {}
        },
        "frameworks": {
          "net9.0": {
            "targetAlias": "net9.0",
            "projectReferences": {}
          }
        },
        "warningProperties": {
          "warnAsError": [
            "NU1605"
          ]
        },
        "restoreAuditProperties": {
          "enableAudit": "true",
          "auditLevel": "low",
          "auditMode": "direct"
        },
        "SdkAnalysisLevel": "9.0.300"
      },
      "frameworks": {
        "net9.0": {
          "targetAlias": "net9.0",
          "dependencies": {
            "SDL3-CS": {
              "target": "Package",
              "version": "[*, )"
            }
          },
          "imports": [
            "net461",
            "net462",
            "net47",
            "net471",
            "net472",
            "net48",
            "net481"
          ],
          "assetTargetFallback": true,
          "warn": true,
          "frameworkReferences": {
            "Microsoft.NETCore.App": {
              "privateAssets": "all"
            }
          },
          "runtimeIdentifierGraphPath": "/home/danny/.local/share/mise/installs/dotnet/9.0.300/sdk/9.0.300/PortableRuntimeIdentifierGraph.json"
        }
      }
    },
    "/home/danny/git/any2/tests/Night.Tests/Night.Tests.csproj": {
      "version": "1.0.0",
      "restore": {
        "projectUniqueName": "/home/danny/git/any2/tests/Night.Tests/Night.Tests.csproj",
        "projectName": "Night.Tests",
        "projectPath": "/home/danny/git/any2/tests/Night.Tests/Night.Tests.csproj",
        "packagesPath": "/home/danny/.nuget/packages/",
        "outputPath": "/home/danny/git/any2/tests/Night.Tests/obj/",
        "projectStyle": "PackageReference",
        "configFilePaths": [
          "/home/danny/.nuget/NuGet/NuGet.Config"
        ],
        "originalTargetFrameworks": [
          "net9.0"
        ],
        "sources": {
          "https://api.nuget.org/v3/index.json": {}
        },
        "frameworks": {
          "net9.0": {
            "targetAlias": "net9.0",
            "projectReferences": {
              "/home/danny/git/any2/src/Night/Night.csproj": {
                "projectPath": "/home/danny/git/any2/src/Night/Night.csproj"
              }
            }
          }
        },
        "warningProperties": {
          "warnAsError": [
            "NU1605"
          ]
        },
        "restoreAuditProperties": {
          "enableAudit": "true",
          "auditLevel": "low",
          "auditMode": "direct"
        },
        "SdkAnalysisLevel": "9.0.300"
      },
      "frameworks": {
        "net9.0": {
          "targetAlias": "net9.0",
          "dependencies": {
            "Microsoft.NET.Test.Sdk": {
              "target": "Package",
              "version": "[17.12.0, )"
            },
            "coverlet.collector": {
              "target": "Package",
              "version": "[6.0.2, )"
            },
            "xunit": {
              "target": "Package",
              "version": "[2.9.2, )"
            },
            "xunit.runner.visualstudio": {
              "target": "Package",
              "version": "[2.8.2, )"
            }
          },
          "imports": [
            "net461",
            "net462",
            "net47",
            "net471",
            "net472",
            "net48",
            "net481"
          ],
          "assetTargetFallback": true,
          "warn": true,
          "frameworkReferences": {
            "Microsoft.NETCore.App": {
              "privateAssets": "all"
            }
          },
          "runtimeIdentifierGraphPath": "/home/danny/.local/share/mise/installs/dotnet/9.0.300/sdk/9.0.300/PortableRuntimeIdentifierGraph.json"
        }
      }
    }
  }
}


================================================
File: tests/Night.Tests/obj/Night.Tests.csproj.nuget.g.props
================================================
﻿<?xml version="1.0" encoding="utf-8" standalone="no"?>
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition=" '$(ExcludeRestorePackageImports)' != 'true' ">
    <RestoreSuccess Condition=" '$(RestoreSuccess)' == '' ">True</RestoreSuccess>
    <RestoreTool Condition=" '$(RestoreTool)' == '' ">NuGet</RestoreTool>
    <ProjectAssetsFile Condition=" '$(ProjectAssetsFile)' == '' ">$(MSBuildThisFileDirectory)project.assets.json</ProjectAssetsFile>
    <NuGetPackageRoot Condition=" '$(NuGetPackageRoot)' == '' ">/home/danny/.nuget/packages/</NuGetPackageRoot>
    <NuGetPackageFolders Condition=" '$(NuGetPackageFolders)' == '' ">/home/danny/.nuget/packages/</NuGetPackageFolders>
    <NuGetProjectStyle Condition=" '$(NuGetProjectStyle)' == '' ">PackageReference</NuGetProjectStyle>
    <NuGetToolVersion Condition=" '$(NuGetToolVersion)' == '' ">6.14.0</NuGetToolVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(ExcludeRestorePackageImports)' != 'true' ">
    <SourceRoot Include="/home/danny/.nuget/packages/" />
  </ItemGroup>
  <ImportGroup Condition=" '$(ExcludeRestorePackageImports)' != 'true' ">
    <Import Project="$(NuGetPackageRoot)xunit.runner.visualstudio/2.8.2/build/net6.0/xunit.runner.visualstudio.props" Condition="Exists('$(NuGetPackageRoot)xunit.runner.visualstudio/2.8.2/build/net6.0/xunit.runner.visualstudio.props')" />
    <Import Project="$(NuGetPackageRoot)xunit.core/2.9.2/build/xunit.core.props" Condition="Exists('$(NuGetPackageRoot)xunit.core/2.9.2/build/xunit.core.props')" />
    <Import Project="$(NuGetPackageRoot)microsoft.testplatform.testhost/17.12.0/build/netcoreapp3.1/Microsoft.TestPlatform.TestHost.props" Condition="Exists('$(NuGetPackageRoot)microsoft.testplatform.testhost/17.12.0/build/netcoreapp3.1/Microsoft.TestPlatform.TestHost.props')" />
    <Import Project="$(NuGetPackageRoot)microsoft.codecoverage/17.12.0/build/netstandard2.0/Microsoft.CodeCoverage.props" Condition="Exists('$(NuGetPackageRoot)microsoft.codecoverage/17.12.0/build/netstandard2.0/Microsoft.CodeCoverage.props')" />
    <Import Project="$(NuGetPackageRoot)microsoft.net.test.sdk/17.12.0/build/netcoreapp3.1/Microsoft.NET.Test.Sdk.props" Condition="Exists('$(NuGetPackageRoot)microsoft.net.test.sdk/17.12.0/build/netcoreapp3.1/Microsoft.NET.Test.Sdk.props')" />
  </ImportGroup>
  <PropertyGroup Condition=" '$(ExcludeRestorePackageImports)' != 'true' ">
    <Pkgxunit_analyzers Condition=" '$(Pkgxunit_analyzers)' == '' ">/home/danny/.nuget/packages/xunit.analyzers/1.16.0</Pkgxunit_analyzers>
  </PropertyGroup>
</Project>


================================================
File: tests/Night.Tests/obj/Night.Tests.csproj.nuget.g.targets
================================================
﻿<?xml version="1.0" encoding="utf-8" standalone="no"?>
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ImportGroup Condition=" '$(ExcludeRestorePackageImports)' != 'true' ">
    <Import Project="$(NuGetPackageRoot)xunit.core/2.9.2/build/xunit.core.targets" Condition="Exists('$(NuGetPackageRoot)xunit.core/2.9.2/build/xunit.core.targets')" />
    <Import Project="$(NuGetPackageRoot)microsoft.codecoverage/17.12.0/build/netstandard2.0/Microsoft.CodeCoverage.targets" Condition="Exists('$(NuGetPackageRoot)microsoft.codecoverage/17.12.0/build/netstandard2.0/Microsoft.CodeCoverage.targets')" />
    <Import Project="$(NuGetPackageRoot)microsoft.net.test.sdk/17.12.0/build/netcoreapp3.1/Microsoft.NET.Test.Sdk.targets" Condition="Exists('$(NuGetPackageRoot)microsoft.net.test.sdk/17.12.0/build/netcoreapp3.1/Microsoft.NET.Test.Sdk.targets')" />
    <Import Project="$(NuGetPackageRoot)coverlet.collector/6.0.2/build/netstandard2.0/coverlet.collector.targets" Condition="Exists('$(NuGetPackageRoot)coverlet.collector/6.0.2/build/netstandard2.0/coverlet.collector.targets')" />
  </ImportGroup>
</Project>


================================================
File: tests/Night.Tests/obj/project.assets.json
================================================
{
  "version": 3,
  "targets": {
    "net9.0": {
      "coverlet.collector/6.0.2": {
        "type": "package",
        "build": {
          "build/netstandard2.0/coverlet.collector.targets": {}
        }
      },
      "Microsoft.CodeCoverage/17.12.0": {
        "type": "package",
        "compile": {
          "lib/netcoreapp3.1/Microsoft.VisualStudio.CodeCoverage.Shim.dll": {}
        },
        "runtime": {
          "lib/netcoreapp3.1/Microsoft.VisualStudio.CodeCoverage.Shim.dll": {}
        },
        "build": {
          "build/netstandard2.0/Microsoft.CodeCoverage.props": {},
          "build/netstandard2.0/Microsoft.CodeCoverage.targets": {}
        }
      },
      "Microsoft.NET.Test.Sdk/17.12.0": {
        "type": "package",
        "dependencies": {
          "Microsoft.CodeCoverage": "17.12.0",
          "Microsoft.TestPlatform.TestHost": "17.12.0"
        },
        "compile": {
          "lib/netcoreapp3.1/_._": {}
        },
        "runtime": {
          "lib/netcoreapp3.1/_._": {}
        },
        "build": {
          "build/netcoreapp3.1/Microsoft.NET.Test.Sdk.props": {},
          "build/netcoreapp3.1/Microsoft.NET.Test.Sdk.targets": {}
        },
        "buildMultiTargeting": {
          "buildMultiTargeting/Microsoft.NET.Test.Sdk.props": {}
        }
      },
      "Microsoft.TestPlatform.ObjectModel/17.12.0": {
        "type": "package",
        "dependencies": {
          "System.Reflection.Metadata": "1.6.0"
        },
        "compile": {
          "lib/netcoreapp3.1/Microsoft.TestPlatform.CoreUtilities.dll": {},
          "lib/netcoreapp3.1/Microsoft.TestPlatform.PlatformAbstractions.dll": {},
          "lib/netcoreapp3.1/Microsoft.VisualStudio.TestPlatform.ObjectModel.dll": {}
        },
        "runtime": {
          "lib/netcoreapp3.1/Microsoft.TestPlatform.CoreUtilities.dll": {},
          "lib/netcoreapp3.1/Microsoft.TestPlatform.PlatformAbstractions.dll": {},
          "lib/netcoreapp3.1/Microsoft.VisualStudio.TestPlatform.ObjectModel.dll": {}
        },
        "resource": {
          "lib/netcoreapp3.1/cs/Microsoft.TestPlatform.CoreUtilities.resources.dll": {
            "locale": "cs"
          },
          "lib/netcoreapp3.1/cs/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll": {
            "locale": "cs"
          },
          "lib/netcoreapp3.1/de/Microsoft.TestPlatform.CoreUtilities.resources.dll": {
            "locale": "de"
          },
          "lib/netcoreapp3.1/de/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll": {
            "locale": "de"
          },
          "lib/netcoreapp3.1/es/Microsoft.TestPlatform.CoreUtilities.resources.dll": {
            "locale": "es"
          },
          "lib/netcoreapp3.1/es/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll": {
            "locale": "es"
          },
          "lib/netcoreapp3.1/fr/Microsoft.TestPlatform.CoreUtilities.resources.dll": {
            "locale": "fr"
          },
          "lib/netcoreapp3.1/fr/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll": {
            "locale": "fr"
          },
          "lib/netcoreapp3.1/it/Microsoft.TestPlatform.CoreUtilities.resources.dll": {
            "locale": "it"
          },
          "lib/netcoreapp3.1/it/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll": {
            "locale": "it"
          },
          "lib/netcoreapp3.1/ja/Microsoft.TestPlatform.CoreUtilities.resources.dll": {
            "locale": "ja"
          },
          "lib/netcoreapp3.1/ja/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll": {
            "locale": "ja"
          },
          "lib/netcoreapp3.1/ko/Microsoft.TestPlatform.CoreUtilities.resources.dll": {
            "locale": "ko"
          },
          "lib/netcoreapp3.1/ko/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll": {
            "locale": "ko"
          },
          "lib/netcoreapp3.1/pl/Microsoft.TestPlatform.CoreUtilities.resources.dll": {
            "locale": "pl"
          },
          "lib/netcoreapp3.1/pl/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll": {
            "locale": "pl"
          },
          "lib/netcoreapp3.1/pt-BR/Microsoft.TestPlatform.CoreUtilities.resources.dll": {
            "locale": "pt-BR"
          },
          "lib/netcoreapp3.1/pt-BR/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll": {
            "locale": "pt-BR"
          },
          "lib/netcoreapp3.1/ru/Microsoft.TestPlatform.CoreUtilities.resources.dll": {
            "locale": "ru"
          },
          "lib/netcoreapp3.1/ru/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll": {
            "locale": "ru"
          },
          "lib/netcoreapp3.1/tr/Microsoft.TestPlatform.CoreUtilities.resources.dll": {
            "locale": "tr"
          },
          "lib/netcoreapp3.1/tr/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll": {
            "locale": "tr"
          },
          "lib/netcoreapp3.1/zh-Hans/Microsoft.TestPlatform.CoreUtilities.resources.dll": {
            "locale": "zh-Hans"
          },
          "lib/netcoreapp3.1/zh-Hans/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll": {
            "locale": "zh-Hans"
          },
          "lib/netcoreapp3.1/zh-Hant/Microsoft.TestPlatform.CoreUtilities.resources.dll": {
            "locale": "zh-Hant"
          },
          "lib/netcoreapp3.1/zh-Hant/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll": {
            "locale": "zh-Hant"
          }
        }
      },
      "Microsoft.TestPlatform.TestHost/17.12.0": {
        "type": "package",
        "dependencies": {
          "Microsoft.TestPlatform.ObjectModel": "17.12.0",
          "Newtonsoft.Json": "13.0.1"
        },
        "compile": {
          "lib/netcoreapp3.1/Microsoft.TestPlatform.CommunicationUtilities.dll": {},
          "lib/netcoreapp3.1/Microsoft.TestPlatform.CoreUtilities.dll": {},
          "lib/netcoreapp3.1/Microsoft.TestPlatform.CrossPlatEngine.dll": {},
          "lib/netcoreapp3.1/Microsoft.TestPlatform.PlatformAbstractions.dll": {},
          "lib/netcoreapp3.1/Microsoft.TestPlatform.Utilities.dll": {},
          "lib/netcoreapp3.1/Microsoft.VisualStudio.TestPlatform.Common.dll": {},
          "lib/netcoreapp3.1/Microsoft.VisualStudio.TestPlatform.ObjectModel.dll": {},
          "lib/netcoreapp3.1/testhost.dll": {
            "related": ".deps.json"
          }
        },
        "runtime": {
          "lib/netcoreapp3.1/Microsoft.TestPlatform.CommunicationUtilities.dll": {},
          "lib/netcoreapp3.1/Microsoft.TestPlatform.CoreUtilities.dll": {},
          "lib/netcoreapp3.1/Microsoft.TestPlatform.CrossPlatEngine.dll": {},
          "lib/netcoreapp3.1/Microsoft.TestPlatform.PlatformAbstractions.dll": {},
          "lib/netcoreapp3.1/Microsoft.TestPlatform.Utilities.dll": {},
          "lib/netcoreapp3.1/Microsoft.VisualStudio.TestPlatform.Common.dll": {},
          "lib/netcoreapp3.1/Microsoft.VisualStudio.TestPlatform.ObjectModel.dll": {},
          "lib/netcoreapp3.1/testhost.dll": {
            "related": ".deps.json"
          }
        },
        "resource": {
          "lib/netcoreapp3.1/cs/Microsoft.TestPlatform.CommunicationUtilities.resources.dll": {
            "locale": "cs"
          },
          "lib/netcoreapp3.1/cs/Microsoft.TestPlatform.CrossPlatEngine.resources.dll": {
            "locale": "cs"
          },
          "lib/netcoreapp3.1/cs/Microsoft.VisualStudio.TestPlatform.Common.resources.dll": {
            "locale": "cs"
          },
          "lib/netcoreapp3.1/de/Microsoft.TestPlatform.CommunicationUtilities.resources.dll": {
            "locale": "de"
          },
          "lib/netcoreapp3.1/de/Microsoft.TestPlatform.CrossPlatEngine.resources.dll": {
            "locale": "de"
          },
          "lib/netcoreapp3.1/de/Microsoft.VisualStudio.TestPlatform.Common.resources.dll": {
            "locale": "de"
          },
          "lib/netcoreapp3.1/es/Microsoft.TestPlatform.CommunicationUtilities.resources.dll": {
            "locale": "es"
          },
          "lib/netcoreapp3.1/es/Microsoft.TestPlatform.CrossPlatEngine.resources.dll": {
            "locale": "es"
          },
          "lib/netcoreapp3.1/es/Microsoft.VisualStudio.TestPlatform.Common.resources.dll": {
            "locale": "es"
          },
          "lib/netcoreapp3.1/fr/Microsoft.TestPlatform.CommunicationUtilities.resources.dll": {
            "locale": "fr"
          },
          "lib/netcoreapp3.1/fr/Microsoft.TestPlatform.CrossPlatEngine.resources.dll": {
            "locale": "fr"
          },
          "lib/netcoreapp3.1/fr/Microsoft.VisualStudio.TestPlatform.Common.resources.dll": {
            "locale": "fr"
          },
          "lib/netcoreapp3.1/it/Microsoft.TestPlatform.CommunicationUtilities.resources.dll": {
            "locale": "it"
          },
          "lib/netcoreapp3.1/it/Microsoft.TestPlatform.CrossPlatEngine.resources.dll": {
            "locale": "it"
          },
          "lib/netcoreapp3.1/it/Microsoft.VisualStudio.TestPlatform.Common.resources.dll": {
            "locale": "it"
          },
          "lib/netcoreapp3.1/ja/Microsoft.TestPlatform.CommunicationUtilities.resources.dll": {
            "locale": "ja"
          },
          "lib/netcoreapp3.1/ja/Microsoft.TestPlatform.CrossPlatEngine.resources.dll": {
            "locale": "ja"
          },
          "lib/netcoreapp3.1/ja/Microsoft.VisualStudio.TestPlatform.Common.resources.dll": {
            "locale": "ja"
          },
          "lib/netcoreapp3.1/ko/Microsoft.TestPlatform.CommunicationUtilities.resources.dll": {
            "locale": "ko"
          },
          "lib/netcoreapp3.1/ko/Microsoft.TestPlatform.CrossPlatEngine.resources.dll": {
            "locale": "ko"
          },
          "lib/netcoreapp3.1/ko/Microsoft.VisualStudio.TestPlatform.Common.resources.dll": {
            "locale": "ko"
          },
          "lib/netcoreapp3.1/pl/Microsoft.TestPlatform.CommunicationUtilities.resources.dll": {
            "locale": "pl"
          },
          "lib/netcoreapp3.1/pl/Microsoft.TestPlatform.CrossPlatEngine.resources.dll": {
            "locale": "pl"
          },
          "lib/netcoreapp3.1/pl/Microsoft.VisualStudio.TestPlatform.Common.resources.dll": {
            "locale": "pl"
          },
          "lib/netcoreapp3.1/pt-BR/Microsoft.TestPlatform.CommunicationUtilities.resources.dll": {
            "locale": "pt-BR"
          },
          "lib/netcoreapp3.1/pt-BR/Microsoft.TestPlatform.CrossPlatEngine.resources.dll": {
            "locale": "pt-BR"
          },
          "lib/netcoreapp3.1/pt-BR/Microsoft.VisualStudio.TestPlatform.Common.resources.dll": {
            "locale": "pt-BR"
          },
          "lib/netcoreapp3.1/ru/Microsoft.TestPlatform.CommunicationUtilities.resources.dll": {
            "locale": "ru"
          },
          "lib/netcoreapp3.1/ru/Microsoft.TestPlatform.CrossPlatEngine.resources.dll": {
            "locale": "ru"
          },
          "lib/netcoreapp3.1/ru/Microsoft.VisualStudio.TestPlatform.Common.resources.dll": {
            "locale": "ru"
          },
          "lib/netcoreapp3.1/tr/Microsoft.TestPlatform.CommunicationUtilities.resources.dll": {
            "locale": "tr"
          },
          "lib/netcoreapp3.1/tr/Microsoft.TestPlatform.CrossPlatEngine.resources.dll": {
            "locale": "tr"
          },
          "lib/netcoreapp3.1/tr/Microsoft.VisualStudio.TestPlatform.Common.resources.dll": {
            "locale": "tr"
          },
          "lib/netcoreapp3.1/zh-Hans/Microsoft.TestPlatform.CommunicationUtilities.resources.dll": {
            "locale": "zh-Hans"
          },
          "lib/netcoreapp3.1/zh-Hans/Microsoft.TestPlatform.CrossPlatEngine.resources.dll": {
            "locale": "zh-Hans"
          },
          "lib/netcoreapp3.1/zh-Hans/Microsoft.VisualStudio.TestPlatform.Common.resources.dll": {
            "locale": "zh-Hans"
          },
          "lib/netcoreapp3.1/zh-Hant/Microsoft.TestPlatform.CommunicationUtilities.resources.dll": {
            "locale": "zh-Hant"
          },
          "lib/netcoreapp3.1/zh-Hant/Microsoft.TestPlatform.CrossPlatEngine.resources.dll": {
            "locale": "zh-Hant"
          },
          "lib/netcoreapp3.1/zh-Hant/Microsoft.VisualStudio.TestPlatform.Common.resources.dll": {
            "locale": "zh-Hant"
          }
        },
        "build": {
          "build/netcoreapp3.1/Microsoft.TestPlatform.TestHost.props": {}
        }
      },
      "Newtonsoft.Json/13.0.1": {
        "type": "package",
        "compile": {
          "lib/netstandard2.0/Newtonsoft.Json.dll": {
            "related": ".xml"
          }
        },
        "runtime": {
          "lib/netstandard2.0/Newtonsoft.Json.dll": {
            "related": ".xml"
          }
        }
      },
      "SDL3-CS/3.2.14.2": {
        "type": "package",
        "compile": {
          "lib/net9.0/SDL3-CS.dll": {
            "related": ".xml"
          }
        },
        "runtime": {
          "lib/net9.0/SDL3-CS.dll": {
            "related": ".xml"
          }
        }
      },
      "System.Reflection.Metadata/1.6.0": {
        "type": "package",
        "compile": {
          "lib/netstandard2.0/System.Reflection.Metadata.dll": {
            "related": ".xml"
          }
        },
        "runtime": {
          "lib/netstandard2.0/System.Reflection.Metadata.dll": {
            "related": ".xml"
          }
        }
      },
      "xunit/2.9.2": {
        "type": "package",
        "dependencies": {
          "xunit.analyzers": "1.16.0",
          "xunit.assert": "2.9.2",
          "xunit.core": "[2.9.2]"
        }
      },
      "xunit.abstractions/2.0.3": {
        "type": "package",
        "compile": {
          "lib/netstandard2.0/xunit.abstractions.dll": {
            "related": ".xml"
          }
        },
        "runtime": {
          "lib/netstandard2.0/xunit.abstractions.dll": {
            "related": ".xml"
          }
        }
      },
      "xunit.analyzers/1.16.0": {
        "type": "package"
      },
      "xunit.assert/2.9.2": {
        "type": "package",
        "compile": {
          "lib/net6.0/xunit.assert.dll": {
            "related": ".xml"
          }
        },
        "runtime": {
          "lib/net6.0/xunit.assert.dll": {
            "related": ".xml"
          }
        }
      },
      "xunit.core/2.9.2": {
        "type": "package",
        "dependencies": {
          "xunit.extensibility.core": "[2.9.2]",
          "xunit.extensibility.execution": "[2.9.2]"
        },
        "build": {
          "build/xunit.core.props": {},
          "build/xunit.core.targets": {}
        },
        "buildMultiTargeting": {
          "buildMultiTargeting/xunit.core.props": {},
          "buildMultiTargeting/xunit.core.targets": {}
        }
      },
      "xunit.extensibility.core/2.9.2": {
        "type": "package",
        "dependencies": {
          "xunit.abstractions": "2.0.3"
        },
        "compile": {
          "lib/netstandard1.1/xunit.core.dll": {
            "related": ".xml"
          }
        },
        "runtime": {
          "lib/netstandard1.1/xunit.core.dll": {
            "related": ".xml"
          }
        }
      },
      "xunit.extensibility.execution/2.9.2": {
        "type": "package",
        "dependencies": {
          "xunit.extensibility.core": "[2.9.2]"
        },
        "compile": {
          "lib/netstandard1.1/xunit.execution.dotnet.dll": {
            "related": ".xml"
          }
        },
        "runtime": {
          "lib/netstandard1.1/xunit.execution.dotnet.dll": {
            "related": ".xml"
          }
        }
      },
      "xunit.runner.visualstudio/2.8.2": {
        "type": "package",
        "compile": {
          "lib/net6.0/_._": {}
        },
        "runtime": {
          "lib/net6.0/_._": {}
        },
        "build": {
          "build/net6.0/xunit.runner.visualstudio.props": {}
        }
      },
      "Night/1.0.0": {
        "type": "project",
        "framework": ".NETCoreApp,Version=v9.0",
        "dependencies": {
          "SDL3-CS": "0.0.0"
        },
        "compile": {
          "bin/placeholder/Night.dll": {}
        },
        "runtime": {
          "bin/placeholder/Night.dll": {}
        }
      }
    }
  },
  "libraries": {
    "coverlet.collector/6.0.2": {
      "sha512": "bJShQ6uWRTQ100ZeyiMqcFlhP7WJ+bCuabUs885dJiBEzMsJMSFr7BOyeCw4rgvQokteGi5rKQTlkhfQPUXg2A==",
      "type": "package",
      "path": "coverlet.collector/6.0.2",
      "files": [
        ".nupkg.metadata",
        ".signature.p7s",
        "VSTestIntegration.md",
        "build/netstandard2.0/Microsoft.Bcl.AsyncInterfaces.dll",
        "build/netstandard2.0/Microsoft.Extensions.DependencyInjection.Abstractions.dll",
        "build/netstandard2.0/Microsoft.Extensions.DependencyInjection.dll",
        "build/netstandard2.0/Microsoft.Extensions.DependencyModel.dll",
        "build/netstandard2.0/Microsoft.Extensions.FileSystemGlobbing.dll",
        "build/netstandard2.0/Microsoft.TestPlatform.CoreUtilities.dll",
        "build/netstandard2.0/Microsoft.TestPlatform.PlatformAbstractions.dll",
        "build/netstandard2.0/Microsoft.VisualStudio.TestPlatform.ObjectModel.dll",
        "build/netstandard2.0/Mono.Cecil.Mdb.dll",
        "build/netstandard2.0/Mono.Cecil.Pdb.dll",
        "build/netstandard2.0/Mono.Cecil.Rocks.dll",
        "build/netstandard2.0/Mono.Cecil.dll",
        "build/netstandard2.0/Newtonsoft.Json.dll",
        "build/netstandard2.0/NuGet.Frameworks.dll",
        "build/netstandard2.0/NuGet.Versioning.dll",
        "build/netstandard2.0/System.Buffers.dll",
        "build/netstandard2.0/System.Collections.Immutable.dll",
        "build/netstandard2.0/System.Memory.dll",
        "build/netstandard2.0/System.Numerics.Vectors.dll",
        "build/netstandard2.0/System.Reflection.Metadata.dll",
        "build/netstandard2.0/System.Runtime.CompilerServices.Unsafe.dll",
        "build/netstandard2.0/System.Text.Encodings.Web.dll",
        "build/netstandard2.0/System.Text.Json.dll",
        "build/netstandard2.0/System.Threading.Tasks.Extensions.dll",
        "build/netstandard2.0/coverlet.collector.deps.json",
        "build/netstandard2.0/coverlet.collector.dll",
        "build/netstandard2.0/coverlet.collector.pdb",
        "build/netstandard2.0/coverlet.collector.targets",
        "build/netstandard2.0/coverlet.core.dll",
        "build/netstandard2.0/coverlet.core.pdb",
        "build/netstandard2.0/coverlet.core.xml",
        "build/netstandard2.0/cs/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "build/netstandard2.0/cs/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "build/netstandard2.0/de/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "build/netstandard2.0/de/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "build/netstandard2.0/es/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "build/netstandard2.0/es/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "build/netstandard2.0/fr/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "build/netstandard2.0/fr/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "build/netstandard2.0/it/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "build/netstandard2.0/it/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "build/netstandard2.0/ja/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "build/netstandard2.0/ja/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "build/netstandard2.0/ko/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "build/netstandard2.0/ko/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "build/netstandard2.0/pl/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "build/netstandard2.0/pl/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "build/netstandard2.0/pt-BR/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "build/netstandard2.0/pt-BR/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "build/netstandard2.0/ru/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "build/netstandard2.0/ru/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "build/netstandard2.0/tr/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "build/netstandard2.0/tr/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "build/netstandard2.0/zh-Hans/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "build/netstandard2.0/zh-Hans/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "build/netstandard2.0/zh-Hant/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "build/netstandard2.0/zh-Hant/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "coverlet-icon.png",
        "coverlet.collector.6.0.2.nupkg.sha512",
        "coverlet.collector.nuspec"
      ]
    },
    "Microsoft.CodeCoverage/17.12.0": {
      "sha512": "4svMznBd5JM21JIG2xZKGNanAHNXplxf/kQDFfLHXQ3OnpJkayRK/TjacFjA+EYmoyuNXHo/sOETEfcYtAzIrA==",
      "type": "package",
      "path": "microsoft.codecoverage/17.12.0",
      "files": [
        ".nupkg.metadata",
        ".signature.p7s",
        "Icon.png",
        "ThirdPartyNotices.txt",
        "build/netstandard2.0/CodeCoverage/CodeCoverage.config",
        "build/netstandard2.0/CodeCoverage/CodeCoverage.exe",
        "build/netstandard2.0/CodeCoverage/Cov_x86.config",
        "build/netstandard2.0/CodeCoverage/amd64/CodeCoverage.exe",
        "build/netstandard2.0/CodeCoverage/amd64/Cov_x64.config",
        "build/netstandard2.0/CodeCoverage/amd64/covrun64.dll",
        "build/netstandard2.0/CodeCoverage/amd64/msdia140.dll",
        "build/netstandard2.0/CodeCoverage/arm64/Cov_arm64.config",
        "build/netstandard2.0/CodeCoverage/arm64/covrunarm64.dll",
        "build/netstandard2.0/CodeCoverage/arm64/msdia140.dll",
        "build/netstandard2.0/CodeCoverage/codecoveragemessages.dll",
        "build/netstandard2.0/CodeCoverage/coreclr/Microsoft.VisualStudio.CodeCoverage.Shim.dll",
        "build/netstandard2.0/CodeCoverage/covrun32.dll",
        "build/netstandard2.0/CodeCoverage/msdia140.dll",
        "build/netstandard2.0/Microsoft.CodeCoverage.Core.dll",
        "build/netstandard2.0/Microsoft.CodeCoverage.Instrumentation.Core.dll",
        "build/netstandard2.0/Microsoft.CodeCoverage.Instrumentation.dll",
        "build/netstandard2.0/Microsoft.CodeCoverage.Interprocess.dll",
        "build/netstandard2.0/Microsoft.CodeCoverage.props",
        "build/netstandard2.0/Microsoft.CodeCoverage.targets",
        "build/netstandard2.0/Microsoft.DiaSymReader.dll",
        "build/netstandard2.0/Microsoft.VisualStudio.TraceDataCollector.dll",
        "build/netstandard2.0/Mono.Cecil.Pdb.dll",
        "build/netstandard2.0/Mono.Cecil.Rocks.dll",
        "build/netstandard2.0/Mono.Cecil.dll",
        "build/netstandard2.0/ThirdPartyNotices.txt",
        "build/netstandard2.0/alpine/x64/Cov_x64.config",
        "build/netstandard2.0/alpine/x64/libCoverageInstrumentationMethod.so",
        "build/netstandard2.0/alpine/x64/libInstrumentationEngine.so",
        "build/netstandard2.0/arm64/MicrosoftInstrumentationEngine_arm64.dll",
        "build/netstandard2.0/cs/Microsoft.VisualStudio.TraceDataCollector.resources.dll",
        "build/netstandard2.0/de/Microsoft.VisualStudio.TraceDataCollector.resources.dll",
        "build/netstandard2.0/es/Microsoft.VisualStudio.TraceDataCollector.resources.dll",
        "build/netstandard2.0/fr/Microsoft.VisualStudio.TraceDataCollector.resources.dll",
        "build/netstandard2.0/it/Microsoft.VisualStudio.TraceDataCollector.resources.dll",
        "build/netstandard2.0/ja/Microsoft.VisualStudio.TraceDataCollector.resources.dll",
        "build/netstandard2.0/ko/Microsoft.VisualStudio.TraceDataCollector.resources.dll",
        "build/netstandard2.0/macos/x64/Cov_x64.config",
        "build/netstandard2.0/macos/x64/libCoverageInstrumentationMethod.dylib",
        "build/netstandard2.0/macos/x64/libInstrumentationEngine.dylib",
        "build/netstandard2.0/pl/Microsoft.VisualStudio.TraceDataCollector.resources.dll",
        "build/netstandard2.0/pt-BR/Microsoft.VisualStudio.TraceDataCollector.resources.dll",
        "build/netstandard2.0/ru/Microsoft.VisualStudio.TraceDataCollector.resources.dll",
        "build/netstandard2.0/tr/Microsoft.VisualStudio.TraceDataCollector.resources.dll",
        "build/netstandard2.0/ubuntu/x64/Cov_x64.config",
        "build/netstandard2.0/ubuntu/x64/libCoverageInstrumentationMethod.so",
        "build/netstandard2.0/ubuntu/x64/libInstrumentationEngine.so",
        "build/netstandard2.0/x64/MicrosoftInstrumentationEngine_x64.dll",
        "build/netstandard2.0/x86/MicrosoftInstrumentationEngine_x86.dll",
        "build/netstandard2.0/zh-Hans/Microsoft.VisualStudio.TraceDataCollector.resources.dll",
        "build/netstandard2.0/zh-Hant/Microsoft.VisualStudio.TraceDataCollector.resources.dll",
        "lib/net462/Microsoft.VisualStudio.CodeCoverage.Shim.dll",
        "lib/netcoreapp3.1/Microsoft.VisualStudio.CodeCoverage.Shim.dll",
        "microsoft.codecoverage.17.12.0.nupkg.sha512",
        "microsoft.codecoverage.nuspec"
      ]
    },
    "Microsoft.NET.Test.Sdk/17.12.0": {
      "sha512": "kt/PKBZ91rFCWxVIJZSgVLk+YR+4KxTuHf799ho8WNiK5ZQpJNAEZCAWX86vcKrs+DiYjiibpYKdGZP6+/N17w==",
      "type": "package",
      "path": "microsoft.net.test.sdk/17.12.0",
      "files": [
        ".nupkg.metadata",
        ".signature.p7s",
        "Icon.png",
        "build/net462/Microsoft.NET.Test.Sdk.props",
        "build/net462/Microsoft.NET.Test.Sdk.targets",
        "build/netcoreapp3.1/Microsoft.NET.Test.Sdk.Program.cs",
        "build/netcoreapp3.1/Microsoft.NET.Test.Sdk.Program.fs",
        "build/netcoreapp3.1/Microsoft.NET.Test.Sdk.Program.vb",
        "build/netcoreapp3.1/Microsoft.NET.Test.Sdk.props",
        "build/netcoreapp3.1/Microsoft.NET.Test.Sdk.targets",
        "buildMultiTargeting/Microsoft.NET.Test.Sdk.props",
        "lib/net462/_._",
        "lib/netcoreapp3.1/_._",
        "microsoft.net.test.sdk.17.12.0.nupkg.sha512",
        "microsoft.net.test.sdk.nuspec"
      ]
    },
    "Microsoft.TestPlatform.ObjectModel/17.12.0": {
      "sha512": "TDqkTKLfQuAaPcEb3pDDWnh7b3SyZF+/W9OZvWFp6eJCIiiYFdSB6taE2I6tWrFw5ywhzOb6sreoGJTI6m3rSQ==",
      "type": "package",
      "path": "microsoft.testplatform.objectmodel/17.12.0",
      "files": [
        ".nupkg.metadata",
        ".signature.p7s",
        "Icon.png",
        "lib/net462/Microsoft.TestPlatform.CoreUtilities.dll",
        "lib/net462/Microsoft.TestPlatform.PlatformAbstractions.dll",
        "lib/net462/Microsoft.VisualStudio.TestPlatform.ObjectModel.dll",
        "lib/net462/cs/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/net462/cs/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/net462/de/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/net462/de/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/net462/es/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/net462/es/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/net462/fr/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/net462/fr/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/net462/it/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/net462/it/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/net462/ja/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/net462/ja/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/net462/ko/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/net462/ko/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/net462/pl/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/net462/pl/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/net462/pt-BR/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/net462/pt-BR/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/net462/ru/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/net462/ru/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/net462/tr/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/net462/tr/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/net462/zh-Hans/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/net462/zh-Hans/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/net462/zh-Hant/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/net462/zh-Hant/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/netcoreapp3.1/Microsoft.TestPlatform.CoreUtilities.dll",
        "lib/netcoreapp3.1/Microsoft.TestPlatform.PlatformAbstractions.dll",
        "lib/netcoreapp3.1/Microsoft.VisualStudio.TestPlatform.ObjectModel.dll",
        "lib/netcoreapp3.1/cs/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/netcoreapp3.1/cs/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/netcoreapp3.1/de/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/netcoreapp3.1/de/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/netcoreapp3.1/es/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/netcoreapp3.1/es/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/netcoreapp3.1/fr/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/netcoreapp3.1/fr/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/netcoreapp3.1/it/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/netcoreapp3.1/it/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/netcoreapp3.1/ja/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/netcoreapp3.1/ja/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/netcoreapp3.1/ko/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/netcoreapp3.1/ko/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/netcoreapp3.1/pl/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/netcoreapp3.1/pl/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/netcoreapp3.1/pt-BR/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/netcoreapp3.1/pt-BR/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/netcoreapp3.1/ru/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/netcoreapp3.1/ru/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/netcoreapp3.1/tr/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/netcoreapp3.1/tr/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/netcoreapp3.1/zh-Hans/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/netcoreapp3.1/zh-Hans/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/netcoreapp3.1/zh-Hant/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/netcoreapp3.1/zh-Hant/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/netstandard2.0/Microsoft.TestPlatform.CoreUtilities.dll",
        "lib/netstandard2.0/Microsoft.TestPlatform.PlatformAbstractions.dll",
        "lib/netstandard2.0/Microsoft.VisualStudio.TestPlatform.ObjectModel.dll",
        "lib/netstandard2.0/cs/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/netstandard2.0/cs/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/netstandard2.0/de/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/netstandard2.0/de/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/netstandard2.0/es/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/netstandard2.0/es/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/netstandard2.0/fr/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/netstandard2.0/fr/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/netstandard2.0/it/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/netstandard2.0/it/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/netstandard2.0/ja/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/netstandard2.0/ja/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/netstandard2.0/ko/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/netstandard2.0/ko/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/netstandard2.0/pl/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/netstandard2.0/pl/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/netstandard2.0/pt-BR/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/netstandard2.0/pt-BR/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/netstandard2.0/ru/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/netstandard2.0/ru/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/netstandard2.0/tr/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/netstandard2.0/tr/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/netstandard2.0/zh-Hans/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/netstandard2.0/zh-Hans/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "lib/netstandard2.0/zh-Hant/Microsoft.TestPlatform.CoreUtilities.resources.dll",
        "lib/netstandard2.0/zh-Hant/Microsoft.VisualStudio.TestPlatform.ObjectModel.resources.dll",
        "microsoft.testplatform.objectmodel.17.12.0.nupkg.sha512",
        "microsoft.testplatform.objectmodel.nuspec"
      ]
    },
    "Microsoft.TestPlatform.TestHost/17.12.0": {
      "sha512": "MiPEJQNyADfwZ4pJNpQex+t9/jOClBGMiCiVVFuELCMSX2nmNfvUor3uFVxNNCg30uxDP8JDYfPnMXQzsfzYyg==",
      "type": "package",
      "path": "microsoft.testplatform.testhost/17.12.0",
      "files": [
        ".nupkg.metadata",
        ".signature.p7s",
        "Icon.png",
        "ThirdPartyNotices.txt",
        "build/netcoreapp3.1/Microsoft.TestPlatform.TestHost.props",
        "build/netcoreapp3.1/x64/testhost.dll",
        "build/netcoreapp3.1/x64/testhost.exe",
        "build/netcoreapp3.1/x86/testhost.x86.dll",
        "build/netcoreapp3.1/x86/testhost.x86.exe",
        "lib/net462/_._",
        "lib/netcoreapp3.1/Microsoft.TestPlatform.CommunicationUtilities.dll",
        "lib/netcoreapp3.1/Microsoft.TestPlatform.CoreUtilities.dll",
        "lib/netcoreapp3.1/Microsoft.TestPlatform.CrossPlatEngine.dll",
        "lib/netcoreapp3.1/Microsoft.TestPlatform.PlatformAbstractions.dll",
        "lib/netcoreapp3.1/Microsoft.TestPlatform.Utilities.dll",
        "lib/netcoreapp3.1/Microsoft.VisualStudio.TestPlatform.Common.dll",
        "lib/netcoreapp3.1/Microsoft.VisualStudio.TestPlatform.ObjectModel.dll",
        "lib/netcoreapp3.1/cs/Microsoft.TestPlatform.CommunicationUtilities.resources.dll",
        "lib/netcoreapp3.1/cs/Microsoft.TestPlatform.CrossPlatEngine.resources.dll",
        "lib/netcoreapp3.1/cs/Microsoft.VisualStudio.TestPlatform.Common.resources.dll",
        "lib/netcoreapp3.1/de/Microsoft.TestPlatform.CommunicationUtilities.resources.dll",
        "lib/netcoreapp3.1/de/Microsoft.TestPlatform.CrossPlatEngine.resources.dll",
        "lib/netcoreapp3.1/de/Microsoft.VisualStudio.TestPlatform.Common.resources.dll",
        "lib/netcoreapp3.1/es/Microsoft.TestPlatform.CommunicationUtilities.resources.dll",
        "lib/netcoreapp3.1/es/Microsoft.TestPlatform.CrossPlatEngine.resources.dll",
        "lib/netcoreapp3.1/es/Microsoft.VisualStudio.TestPlatform.Common.resources.dll",
        "lib/netcoreapp3.1/fr/Microsoft.TestPlatform.CommunicationUtilities.resources.dll",
        "lib/netcoreapp3.1/fr/Microsoft.TestPlatform.CrossPlatEngine.resources.dll",
        "lib/netcoreapp3.1/fr/Microsoft.VisualStudio.TestPlatform.Common.resources.dll",
        "lib/netcoreapp3.1/it/Microsoft.TestPlatform.CommunicationUtilities.resources.dll",
        "lib/netcoreapp3.1/it/Microsoft.TestPlatform.CrossPlatEngine.resources.dll",
        "lib/netcoreapp3.1/it/Microsoft.VisualStudio.TestPlatform.Common.resources.dll",
        "lib/netcoreapp3.1/ja/Microsoft.TestPlatform.CommunicationUtilities.resources.dll",
        "lib/netcoreapp3.1/ja/Microsoft.TestPlatform.CrossPlatEngine.resources.dll",
        "lib/netcoreapp3.1/ja/Microsoft.VisualStudio.TestPlatform.Common.resources.dll",
        "lib/netcoreapp3.1/ko/Microsoft.TestPlatform.CommunicationUtilities.resources.dll",
        "lib/netcoreapp3.1/ko/Microsoft.TestPlatform.CrossPlatEngine.resources.dll",
        "lib/netcoreapp3.1/ko/Microsoft.VisualStudio.TestPlatform.Common.resources.dll",
        "lib/netcoreapp3.1/pl/Microsoft.TestPlatform.CommunicationUtilities.resources.dll",
        "lib/netcoreapp3.1/pl/Microsoft.TestPlatform.CrossPlatEngine.resources.dll",
        "lib/netcoreapp3.1/pl/Microsoft.VisualStudio.TestPlatform.Common.resources.dll",
        "lib/netcoreapp3.1/pt-BR/Microsoft.TestPlatform.CommunicationUtilities.resources.dll",
        "lib/netcoreapp3.1/pt-BR/Microsoft.TestPlatform.CrossPlatEngine.resources.dll",
        "lib/netcoreapp3.1/pt-BR/Microsoft.VisualStudio.TestPlatform.Common.resources.dll",
        "lib/netcoreapp3.1/ru/Microsoft.TestPlatform.CommunicationUtilities.resources.dll",
        "lib/netcoreapp3.1/ru/Microsoft.TestPlatform.CrossPlatEngine.resources.dll",
        "lib/netcoreapp3.1/ru/Microsoft.VisualStudio.TestPlatform.Common.resources.dll",
        "lib/netcoreapp3.1/testhost.deps.json",
        "lib/netcoreapp3.1/testhost.dll",
        "lib/netcoreapp3.1/tr/Microsoft.TestPlatform.CommunicationUtilities.resources.dll",
        "lib/netcoreapp3.1/tr/Microsoft.TestPlatform.CrossPlatEngine.resources.dll",
        "lib/netcoreapp3.1/tr/Microsoft.VisualStudio.TestPlatform.Common.resources.dll",
        "lib/netcoreapp3.1/x64/msdia140.dll",
        "lib/netcoreapp3.1/x86/msdia140.dll",
        "lib/netcoreapp3.1/zh-Hans/Microsoft.TestPlatform.CommunicationUtilities.resources.dll",
        "lib/netcoreapp3.1/zh-Hans/Microsoft.TestPlatform.CrossPlatEngine.resources.dll",
        "lib/netcoreapp3.1/zh-Hans/Microsoft.VisualStudio.TestPlatform.Common.resources.dll",
        "lib/netcoreapp3.1/zh-Hant/Microsoft.TestPlatform.CommunicationUtilities.resources.dll",
        "lib/netcoreapp3.1/zh-Hant/Microsoft.TestPlatform.CrossPlatEngine.resources.dll",
        "lib/netcoreapp3.1/zh-Hant/Microsoft.VisualStudio.TestPlatform.Common.resources.dll",
        "microsoft.testplatform.testhost.17.12.0.nupkg.sha512",
        "microsoft.testplatform.testhost.nuspec"
      ]
    },
    "Newtonsoft.Json/13.0.1": {
      "sha512": "ppPFpBcvxdsfUonNcvITKqLl3bqxWbDCZIzDWHzjpdAHRFfZe0Dw9HmA0+za13IdyrgJwpkDTDA9fHaxOrt20A==",
      "type": "package",
      "path": "newtonsoft.json/13.0.1",
      "files": [
        ".nupkg.metadata",
        ".signature.p7s",
        "LICENSE.md",
        "lib/net20/Newtonsoft.Json.dll",
        "lib/net20/Newtonsoft.Json.xml",
        "lib/net35/Newtonsoft.Json.dll",
        "lib/net35/Newtonsoft.Json.xml",
        "lib/net40/Newtonsoft.Json.dll",
        "lib/net40/Newtonsoft.Json.xml",
        "lib/net45/Newtonsoft.Json.dll",
        "lib/net45/Newtonsoft.Json.xml",
        "lib/netstandard1.0/Newtonsoft.Json.dll",
        "lib/netstandard1.0/Newtonsoft.Json.xml",
        "lib/netstandard1.3/Newtonsoft.Json.dll",
        "lib/netstandard1.3/Newtonsoft.Json.xml",
        "lib/netstandard2.0/Newtonsoft.Json.dll",
        "lib/netstandard2.0/Newtonsoft.Json.xml",
        "newtonsoft.json.13.0.1.nupkg.sha512",
        "newtonsoft.json.nuspec",
        "packageIcon.png"
      ]
    },
    "SDL3-CS/3.2.14.2": {
      "sha512": "wqWjIm2EP7PmXRQfwSxY4YJDSrXZ0QmolJMCJcs9KY4b3vYBdlwo0U4/olPMdBx6yRzqhN1nGJjmeC9OJT6L1g==",
      "type": "package",
      "path": "sdl3-cs/3.2.14.2",
      "files": [
        ".nupkg.metadata",
        ".signature.p7s",
        "CODE_OF_CONDUCT.md",
        "LICENSE",
        "README-nuget.md",
        "README.md",
        "SDL3-CS.xml",
        "lib/net7.0/SDL3-CS.dll",
        "lib/net7.0/SDL3-CS.xml",
        "lib/net8.0/SDL3-CS.dll",
        "lib/net8.0/SDL3-CS.xml",
        "lib/net9.0/SDL3-CS.dll",
        "lib/net9.0/SDL3-CS.xml",
        "logo.png",
        "sdl3-cs.3.2.14.2.nupkg.sha512",
        "sdl3-cs.nuspec"
      ]
    },
    "System.Reflection.Metadata/1.6.0": {
      "sha512": "COC1aiAJjCoA5GBF+QKL2uLqEBew4JsCkQmoHKbN3TlOZKa2fKLz5CpiRQKDz0RsAOEGsVKqOD5bomsXq/4STQ==",
      "type": "package",
      "path": "system.reflection.metadata/1.6.0",
      "files": [
        ".nupkg.metadata",
        ".signature.p7s",
        "LICENSE.TXT",
        "THIRD-PARTY-NOTICES.TXT",
        "lib/netstandard1.1/System.Reflection.Metadata.dll",
        "lib/netstandard1.1/System.Reflection.Metadata.xml",
        "lib/netstandard2.0/System.Reflection.Metadata.dll",
        "lib/netstandard2.0/System.Reflection.Metadata.xml",
        "lib/portable-net45+win8/System.Reflection.Metadata.dll",
        "lib/portable-net45+win8/System.Reflection.Metadata.xml",
        "system.reflection.metadata.1.6.0.nupkg.sha512",
        "system.reflection.metadata.nuspec",
        "useSharedDesignerContext.txt",
        "version.txt"
      ]
    },
    "xunit/2.9.2": {
      "sha512": "7LhFS2N9Z6Xgg8aE5lY95cneYivRMfRI8v+4PATa4S64D5Z/Plkg0qa8dTRHSiGRgVZ/CL2gEfJDE5AUhOX+2Q==",
      "type": "package",
      "path": "xunit/2.9.2",
      "files": [
        ".nupkg.metadata",
        ".signature.p7s",
        "_content/README.md",
        "_content/logo-128-transparent.png",
        "xunit.2.9.2.nupkg.sha512",
        "xunit.nuspec"
      ]
    },
    "xunit.abstractions/2.0.3": {
      "sha512": "pot1I4YOxlWjIb5jmwvvQNbTrZ3lJQ+jUGkGjWE3hEFM0l5gOnBWS+H3qsex68s5cO52g+44vpGzhAt+42vwKg==",
      "type": "package",
      "path": "xunit.abstractions/2.0.3",
      "files": [
        ".nupkg.metadata",
        ".signature.p7s",
        "lib/net35/xunit.abstractions.dll",
        "lib/net35/xunit.abstractions.xml",
        "lib/netstandard1.0/xunit.abstractions.dll",
        "lib/netstandard1.0/xunit.abstractions.xml",
        "lib/netstandard2.0/xunit.abstractions.dll",
        "lib/netstandard2.0/xunit.abstractions.xml",
        "xunit.abstractions.2.0.3.nupkg.sha512",
        "xunit.abstractions.nuspec"
      ]
    },
    "xunit.analyzers/1.16.0": {
      "sha512": "hptYM7vGr46GUIgZt21YHO4rfuBAQS2eINbFo16CV/Dqq+24Tp+P5gDCACu1AbFfW4Sp/WRfDPSK8fmUUb8s0Q==",
      "type": "package",
      "path": "xunit.analyzers/1.16.0",
      "hasTools": true,
      "files": [
        ".nupkg.metadata",
        ".signature.p7s",
        "_content/README.md",
        "_content/logo-128-transparent.png",
        "analyzers/dotnet/cs/xunit.analyzers.dll",
        "analyzers/dotnet/cs/xunit.analyzers.fixes.dll",
        "tools/install.ps1",
        "tools/uninstall.ps1",
        "xunit.analyzers.1.16.0.nupkg.sha512",
        "xunit.analyzers.nuspec"
      ]
    },
    "xunit.assert/2.9.2": {
      "sha512": "QkNBAQG4pa66cholm28AxijBjrmki98/vsEh4Sx5iplzotvPgpiotcxqJQMRC8d7RV7nIT8ozh97957hDnZwsQ==",
      "type": "package",
      "path": "xunit.assert/2.9.2",
      "files": [
        ".nupkg.metadata",
        ".signature.p7s",
        "_content/README.md",
        "_content/logo-128-transparent.png",
        "lib/net6.0/xunit.assert.dll",
        "lib/net6.0/xunit.assert.xml",
        "lib/netstandard1.1/xunit.assert.dll",
        "lib/netstandard1.1/xunit.assert.xml",
        "xunit.assert.2.9.2.nupkg.sha512",
        "xunit.assert.nuspec"
      ]
    },
    "xunit.core/2.9.2": {
      "sha512": "O6RrNSdmZ0xgEn5kT927PNwog5vxTtKrWMihhhrT0Sg9jQ7iBDciYOwzBgP2krBEk5/GBXI18R1lKvmnxGcb4w==",
      "type": "package",
      "path": "xunit.core/2.9.2",
      "files": [
        ".nupkg.metadata",
        ".signature.p7s",
        "_content/README.md",
        "_content/logo-128-transparent.png",
        "build/xunit.core.props",
        "build/xunit.core.targets",
        "buildMultiTargeting/xunit.core.props",
        "buildMultiTargeting/xunit.core.targets",
        "xunit.core.2.9.2.nupkg.sha512",
        "xunit.core.nuspec"
      ]
    },
    "xunit.extensibility.core/2.9.2": {
      "sha512": "Ol+KlBJz1x8BrdnhN2DeOuLrr1I/cTwtHCggL9BvYqFuVd/TUSzxNT5O0NxCIXth30bsKxgMfdqLTcORtM52yQ==",
      "type": "package",
      "path": "xunit.extensibility.core/2.9.2",
      "files": [
        ".nupkg.metadata",
        ".signature.p7s",
        "_content/README.md",
        "_content/logo-128-transparent.png",
        "lib/net452/xunit.core.dll",
        "lib/net452/xunit.core.dll.tdnet",
        "lib/net452/xunit.core.xml",
        "lib/net452/xunit.runner.tdnet.dll",
        "lib/net452/xunit.runner.utility.net452.dll",
        "lib/netstandard1.1/xunit.core.dll",
        "lib/netstandard1.1/xunit.core.xml",
        "xunit.extensibility.core.2.9.2.nupkg.sha512",
        "xunit.extensibility.core.nuspec"
      ]
    },
    "xunit.extensibility.execution/2.9.2": {
      "sha512": "rKMpq4GsIUIJibXuZoZ8lYp5EpROlnYaRpwu9Zr0sRZXE7JqJfEEbCsUriZqB+ByXCLFBJyjkTRULMdC+U566g==",
      "type": "package",
      "path": "xunit.extensibility.execution/2.9.2",
      "files": [
        ".nupkg.metadata",
        ".signature.p7s",
        "_content/README.md",
        "_content/logo-128-transparent.png",
        "lib/net452/xunit.execution.desktop.dll",
        "lib/net452/xunit.execution.desktop.xml",
        "lib/netstandard1.1/xunit.execution.dotnet.dll",
        "lib/netstandard1.1/xunit.execution.dotnet.xml",
        "xunit.extensibility.execution.2.9.2.nupkg.sha512",
        "xunit.extensibility.execution.nuspec"
      ]
    },
    "xunit.runner.visualstudio/2.8.2": {
      "sha512": "vm1tbfXhFmjFMUmS4M0J0ASXz3/U5XvXBa6DOQUL3fEz4Vt6YPhv+ESCarx6M6D+9kJkJYZKCNvJMas1+nVfmQ==",
      "type": "package",
      "path": "xunit.runner.visualstudio/2.8.2",
      "files": [
        ".nupkg.metadata",
        ".signature.p7s",
        "_content/README.md",
        "_content/logo-128-transparent.png",
        "build/net462/xunit.abstractions.dll",
        "build/net462/xunit.runner.reporters.net452.dll",
        "build/net462/xunit.runner.utility.net452.dll",
        "build/net462/xunit.runner.visualstudio.props",
        "build/net462/xunit.runner.visualstudio.testadapter.dll",
        "build/net6.0/xunit.abstractions.dll",
        "build/net6.0/xunit.runner.reporters.netcoreapp10.dll",
        "build/net6.0/xunit.runner.utility.netcoreapp10.dll",
        "build/net6.0/xunit.runner.visualstudio.props",
        "build/net6.0/xunit.runner.visualstudio.testadapter.dll",
        "lib/net462/_._",
        "lib/net6.0/_._",
        "xunit.runner.visualstudio.2.8.2.nupkg.sha512",
        "xunit.runner.visualstudio.nuspec"
      ]
    },
    "Night/1.0.0": {
      "type": "project",
      "path": "../../src/Night/Night.csproj",
      "msbuildProject": "../../src/Night/Night.csproj"
    }
  },
  "projectFileDependencyGroups": {
    "net9.0": [
      "Microsoft.NET.Test.Sdk >= 17.12.0",
      "Night >= 1.0.0",
      "coverlet.collector >= 6.0.2",
      "xunit >= 2.9.2",
      "xunit.runner.visualstudio >= 2.8.2"
    ]
  },
  "packageFolders": {
    "/home/danny/.nuget/packages/": {}
  },
  "project": {
    "version": "1.0.0",
    "restore": {
      "projectUniqueName": "/home/danny/git/any2/tests/Night.Tests/Night.Tests.csproj",
      "projectName": "Night.Tests",
      "projectPath": "/home/danny/git/any2/tests/Night.Tests/Night.Tests.csproj",
      "packagesPath": "/home/danny/.nuget/packages/",
      "outputPath": "/home/danny/git/any2/tests/Night.Tests/obj/",
      "projectStyle": "PackageReference",
      "configFilePaths": [
        "/home/danny/.nuget/NuGet/NuGet.Config"
      ],
      "originalTargetFrameworks": [
        "net9.0"
      ],
      "sources": {
        "https://api.nuget.org/v3/index.json": {}
      },
      "frameworks": {
        "net9.0": {
          "targetAlias": "net9.0",
          "projectReferences": {
            "/home/danny/git/any2/src/Night/Night.csproj": {
              "projectPath": "/home/danny/git/any2/src/Night/Night.csproj"
            }
          }
        }
      },
      "warningProperties": {
        "warnAsError": [
          "NU1605"
        ]
      },
      "restoreAuditProperties": {
        "enableAudit": "true",
        "auditLevel": "low",
        "auditMode": "direct"
      },
      "SdkAnalysisLevel": "9.0.300"
    },
    "frameworks": {
      "net9.0": {
        "targetAlias": "net9.0",
        "dependencies": {
          "Microsoft.NET.Test.Sdk": {
            "target": "Package",
            "version": "[17.12.0, )"
          },
          "coverlet.collector": {
            "target": "Package",
            "version": "[6.0.2, )"
          },
          "xunit": {
            "target": "Package",
            "version": "[2.9.2, )"
          },
          "xunit.runner.visualstudio": {
            "target": "Package",
            "version": "[2.8.2, )"
          }
        },
        "imports": [
          "net461",
          "net462",
          "net47",
          "net471",
          "net472",
          "net48",
          "net481"
        ],
        "assetTargetFallback": true,
        "warn": true,
        "frameworkReferences": {
          "Microsoft.NETCore.App": {
            "privateAssets": "all"
          }
        },
        "runtimeIdentifierGraphPath": "/home/danny/.local/share/mise/installs/dotnet/9.0.300/sdk/9.0.300/PortableRuntimeIdentifierGraph.json"
      }
    }
  }
}


================================================
File: tests/Night.Tests/obj/project.nuget.cache
================================================
{
  "version": 2,
  "dgSpecHash": "ifkwnqpwW0U=",
  "success": true,
  "projectFilePath": "/home/danny/git/any2/tests/Night.Tests/Night.Tests.csproj",
  "expectedPackageFiles": [
    "/home/danny/.nuget/packages/coverlet.collector/6.0.2/coverlet.collector.6.0.2.nupkg.sha512",
    "/home/danny/.nuget/packages/microsoft.codecoverage/17.12.0/microsoft.codecoverage.17.12.0.nupkg.sha512",
    "/home/danny/.nuget/packages/microsoft.net.test.sdk/17.12.0/microsoft.net.test.sdk.17.12.0.nupkg.sha512",
    "/home/danny/.nuget/packages/microsoft.testplatform.objectmodel/17.12.0/microsoft.testplatform.objectmodel.17.12.0.nupkg.sha512",
    "/home/danny/.nuget/packages/microsoft.testplatform.testhost/17.12.0/microsoft.testplatform.testhost.17.12.0.nupkg.sha512",
    "/home/danny/.nuget/packages/newtonsoft.json/13.0.1/newtonsoft.json.13.0.1.nupkg.sha512",
    "/home/danny/.nuget/packages/sdl3-cs/3.2.14.2/sdl3-cs.3.2.14.2.nupkg.sha512",
    "/home/danny/.nuget/packages/system.reflection.metadata/1.6.0/system.reflection.metadata.1.6.0.nupkg.sha512",
    "/home/danny/.nuget/packages/xunit/2.9.2/xunit.2.9.2.nupkg.sha512",
    "/home/danny/.nuget/packages/xunit.abstractions/2.0.3/xunit.abstractions.2.0.3.nupkg.sha512",
    "/home/danny/.nuget/packages/xunit.analyzers/1.16.0/xunit.analyzers.1.16.0.nupkg.sha512",
    "/home/danny/.nuget/packages/xunit.assert/2.9.2/xunit.assert.2.9.2.nupkg.sha512",
    "/home/danny/.nuget/packages/xunit.core/2.9.2/xunit.core.2.9.2.nupkg.sha512",
    "/home/danny/.nuget/packages/xunit.extensibility.core/2.9.2/xunit.extensibility.core.2.9.2.nupkg.sha512",
    "/home/danny/.nuget/packages/xunit.extensibility.execution/2.9.2/xunit.extensibility.execution.2.9.2.nupkg.sha512",
    "/home/danny/.nuget/packages/xunit.runner.visualstudio/2.8.2/xunit.runner.visualstudio.2.8.2.nupkg.sha512"
  ],
  "logs": []
}


================================================
File: tests/Night.Tests/obj/Debug/net9.0/Night.Te.8CE7B445.Up2Date
================================================



================================================
File: tests/Night.Tests/obj/Debug/net9.0/Night.Tests.AssemblyInfo.cs
================================================
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Night.Tests")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+0525ee88c265b33fa6724e0db77184b53b4d713c")]
[assembly: System.Reflection.AssemblyProductAttribute("Night.Tests")]
[assembly: System.Reflection.AssemblyTitleAttribute("Night.Tests")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.




================================================
File: tests/Night.Tests/obj/Debug/net9.0/Night.Tests.AssemblyInfoInputs.cache
================================================
a3b0fbcd8a92a59176467de15ff6c93bc37bde2b9f50c5f8bdf715d44d844f9b



================================================
File: tests/Night.Tests/obj/Debug/net9.0/Night.Tests.GeneratedMSBuildEditorConfig.editorconfig
================================================
is_global = true
build_property.TargetFramework = net9.0
build_property.TargetPlatformMinVersion = 
build_property.UsingMicrosoftNETSdkWeb = 
build_property.ProjectTypeGuids = 
build_property.InvariantGlobalization = 
build_property.PlatformNeutralAssembly = 
build_property.EnforceExtendedAnalyzerRules = 
build_property._SupportedPlatformList = Linux,macOS,Windows
build_property.RootNamespace = Night.Tests
build_property.ProjectDir = /home/danny/git/any2/tests/Night.Tests/
build_property.EnableComHosting = 
build_property.EnableGeneratedComInterfaceComImportInterop = 
build_property.EffectiveAnalysisLevelStyle = 9.0
build_property.EnableCodeStyleSeverity = 



================================================
File: tests/Night.Tests/obj/Debug/net9.0/Night.Tests.GlobalUsings.g.cs
================================================
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
global using global::Xunit;



================================================
File: tests/Night.Tests/obj/Debug/net9.0/Night.Tests.assets.cache
================================================
[Non-text file]


================================================
File: tests/Night.Tests/obj/Debug/net9.0/Night.Tests.csproj.AssemblyReference.cache
================================================
[Non-text file]


================================================
File: tests/Night.Tests/obj/Debug/net9.0/Night.Tests.csproj.CoreCompileInputs.cache
================================================
5f71926cd0b586681a58984a8c193885beac7229ad320aca2553c183f02617d0



================================================
File: tests/Night.Tests/obj/Debug/net9.0/Night.Tests.genruntimeconfig.cache
================================================
9c7ef56059aceb4896b478ec314ab9888356c54b70f9d9db044ee65e57549f3e



================================================
File: tests/Night.Tests/obj/Debug/net9.0/Night.Tests.sourcelink.json
================================================
{"documents":{"/home/danny/git/any2/*":"https://raw.githubusercontent.com/nightconcept/any2/0525ee88c265b33fa6724e0db77184b53b4d713c/*","/home/danny/git/any2/lib/SDL3-CS/*":"https://raw.githubusercontent.com/edwardgushchin/SDL3-CS/f910675dcf9e0825b10e97b8583c892e0eee14be/*"}}


================================================
File: tests/Night.Tests/obj/Debug/net9.0/.NETCoreApp,Version=v9.0.AssemblyAttributes.cs
================================================
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName = ".NET 9.0")]





================================================
File: tools/manifest.json
================================================
{
    "crunch": {
        "version": "2025.05.29"
    }
}


================================================
File: tools/codegen/PRD.md
================================================
# Texture Atlas C# Source Generator: Project Overview

## 1. Introduction & Goal

This project will create a C# Source Generator to process JSON texture atlas files. The primary goal is to provide type-safe, auto-generated C# constants and data structures for accessing sprite information within a C# game engine, improving developer workflow and reducing runtime errors.

## 2. Problem Statement

Manually referencing sprite data using strings (e.g., "Orc-Attack01.png") or hardcoded coordinates is error-prone (typos, outdated data) and difficult to maintain. Changes in the atlas require manual updates in code, leading to potential desynchronization and bugs. This generator will eliminate these issues.

## 3. Proposed Solution: Key Features

The C# Source Generator will:

- **Input:** Consume one or more `.json` atlas files (matching the provided structure) marked as `AdditionalFiles` in the consuming C# project.

- **Parsing:** Deserialize the JSON structure, including atlas metadata and the list of images with their properties (Name, X, Y, W, H, TrimOffsetX, TrimOffsetY, UntrimmedWidth, UntrimmedHeight).

- **Code Generation:** For each atlas JSON file, generate a C# static class. For an atlas named "orcs_atlas.json":

  - **Namespace:** The generated code will reside in a configurable or default namespace (e.g., `GameEngine.Generated.Atlases`).

  - **Main Class:** `public static class OrcsAtlasSprites` (derived from the JSON file name).

  - **Sprite Keys:** An enum `public enum SpriteKey { Orc, Orc_Attack02, Orc_Attack01, ... }` for unique sprite identification. Names will be sanitized (e.g., "Orc-Attack01.png" -> `Orc_Attack01`).

  - **Sprite Data Struct:** `public readonly struct SpriteData { public string OriginalName { get; } public int X { get; } ... public int UntrimmedHeight { get; } ... }`.

  - **Access Mechanism:** A static, readonly dictionary: `public static readonly System.Collections.Generic.IReadOnlyDictionary<SpriteKey, SpriteData> Definitions;` providing access to all sprites.

- **Robustness:** Handle potential naming collisions for sanitized sprite keys gracefully (e.g., by appending a unique suffix if necessary, though simple sanitization is the initial focus).

## 4. Success Criteria

- The Source Generator produces C# code that compiles successfully within the game engine project.

- Generated sprite data (coordinates, dimensions) accurately reflects the JSON input.

- Developers can use the generated enums and structs with IDE autocompletion and compile-time type checking.

- Changes to the input JSON files trigger regeneration of the C# code upon the next build.

- Basic error reporting for malformed JSON or critical processing issues.

## 5. Out of Scope (Initial Version)

- Generating code from atlas formats other than the specified JSON structure.

- Aggregating multiple distinct atlas files into a single generated C# class (each JSON will initially generate its own corresponding static class).

- Advanced animation sequence generation from sprite names (focus on individual sprite definitions).

- A GUI or editor interface for managing atlases or the generator.



================================================
File: tools/codegen/example.json
================================================
{
  "Name": "orcs_atlas",
  "Width": 4096,
  "Height": 1024,
  "Images": [
    {
      "Name": "Orc.png",
      "X": 0,
      "Y": 0,
      "W": 724,
      "H": 516,
      "TrimOffsetX": -42,
      "TrimOffsetY": -41,
      "UntrimmedWidth": 800,
      "UntrimmedHeight": 600
    },
    {
      "Name": "Orc-Attack02.png",
      "X": 725,
      "Y": 0,
      "W": 518,
      "H": 33,
      "TrimOffsetX": -44,
      "TrimOffsetY": -33,
      "UntrimmedWidth": 600,
      "UntrimmedHeight": 100
    },
    {
      "Name": "Orc-Attack01.png",
      "X": 1244,
      "Y": 0,
      "W": 527,
      "H": 29,
      "TrimOffsetX": -44,
      "TrimOffsetY": -33,
      "UntrimmedWidth": 600,
      "UntrimmedHeight": 100
    },
    {
      "Name": "Orc-Walk.png",
      "X": 1772,
      "Y": 0,
      "W": 722,
      "H": 16,
      "TrimOffsetX": -44,
      "TrimOffsetY": -41,
      "UntrimmedWidth": 800,
      "UntrimmedHeight": 100
    },
    {
      "Name": "Orc-Idle.png",
      "X": 2495,
      "Y": 0,
      "W": 522,
      "H": 16,
      "TrimOffsetX": -44,
      "TrimOffsetY": -41,
      "UntrimmedWidth": 600,
      "UntrimmedHeight": 100
    },
    {
      "Name": "Orc-Death.png",
      "X": 3018,
      "Y": 0,
      "W": 321,
      "H": 18,
      "TrimOffsetX": -44,
      "TrimOffsetY": -39,
      "UntrimmedWidth": 400,
      "UntrimmedHeight": 100
    },
    {
      "Name": "Orc-Hurt.png",
      "X": 3340,
      "Y": 0,
      "W": 323,
      "H": 15,
      "TrimOffsetX": -42,
      "TrimOffsetY": -42,
      "UntrimmedWidth": 400,
      "UntrimmedHeight": 100
    }
  ]
}


================================================
File: tools/crunch/linux/crunch
================================================
[Non-text file]


================================================
File: tools/crunch/macos/crunch
================================================
[Non-text file]




================================================
File: .github/CODEOWNERS
================================================
# This is a CODEOWNERS file.
#
# Lines starting with '#' are comments.
# Each line is a file pattern followed by one or more owners.
# These patterns follow the same rules as .gitignore.
#
# Owners can be:
# - A GitHub username (e.g., @octocat)
# - A GitHub team name (e.g., @my-org/my-team)
# - An email address (e.g., user@example.com)
#
# Order matters: the last matching pattern takes the most precedence.
#
# Example:
# *       @global-owner1 @global-owner2  # All files are owned by these users/teams
# *.js    @js-owner                      # .js files are owned by @js-owner
# /docs/  docs@example.com               # Files in the /docs/ directory are owned by docs@example.com

# All files in the repository are owned by nightconcept
* @nightconcept dark@nightconcept.net

# You can add more specific rules below if needed.
# For example, if different parts of the project have different owners:
#
# /cmd/      @nightconcept
# /internal/ @nightconcept
# /scripts/  dark@nightconcept.net



================================================
File: .github/copilot-instructions.md
================================================
# AI Project Guidelines (Condensed)

**Objective:** Define mandatory process, coding, testing, and interaction standards for AI assistance.

## 1. Preparation

* **Project Context (Session Start):** ALWAYS review key project docs: `docs/PRD.md` (architecture, goals, tech stack, versions, structure, style guide), `docs/digest.txt` (current state summary), `docs/TASKS.md` (assignments).
* **Task Prep (Before Work):**
    * ALWAYS consult `docs/TASKS.md` for your assignment. If missing, add it (concise description, `YYYY-MM-DD`).
    * ALWAYS review relevant existing code *before* suggesting changes.

## 2. Implementation Planning

**Present this plan before providing code for a task:**

* Problem description (brief).
* Solution overview (high-level).
* Implementation steps (list).
* Risks/Challenges (foreseen).

## 3. Development Workflow

* **Plan First:** Present plan (Sec 2) before coding.
* **Focus:** Target the specific task from `TASKS.md`. No unrelated refactoring unless tasked.
* **Modification Approach:**
    * Prioritize minimal, incremental, clean, elegant, idiomatic changes.
    * Explain significant suggestions (Sec 5.4).
    * Propose beneficial low-risk refactoring.
    * Avoid duplication; use helpers/modules.
    * Explain use of language strengths/pitfalls if relevant.
* **Dependencies:** No new/updated external dependencies without explicit maintainer approval (check `docs/PRD.md` for approved stack/versions). Use only approved dependencies.
* **Commits (User Task):** Follow Conventional Commits (`https://www.conventionalcommits.org/en/v1.0.0/`).
* **Manual Testing:** Provide clear user instructions for manually testing the task's changes.

## 4. Folder Structure

* **Strict Adherence:** Follow structure defined in `docs/PRD.md`.
* **Changes:** No adding/removing/relocating files/dirs without prior maintainer approval. Approved structure changes require updating `docs/PRD.md` *before* implementation.
* **Source Location:** All source code must be in `src/`.
* **Precedence:** This rule is foundational.

## 5. Coding Standards

### 5.1. General & Robustness

* Follow language best practices unless overridden by `docs/PRD.md` or these guidelines.
* Prioritize: Clarity, maintainability, efficiency.
* Consider performance & basic security.
* Implement robust error handling (language norms or `PRD.md` spec); handle errors gracefully.

### 5.2. Modularity & Structure

* Keep files focused (ideally < 500 lines); refactor large ones.
* Prefer small, single-purpose functions.
* Structure code logically (per `docs/PRD.md`) into modules.
* Use clear, consistent imports (relative for local packages). Verify paths.

### 5.3. Style & Formatting

* **Priority:** 1) `docs/PRD.md`, 2) These rules, 3) Language common practices.
* **Type Hinting:** Mandatory for functions/classes/modules (dynamic languages).
* **Indentation:** 2 spaces.
* **Function Calls:** No space: `func()` not `func ()`.
* **Line Structure:** Avoid collapsing statements if clarity suffers.
* **Scope:** Default local. More descriptive names for wider scope. Avoid single-letter vars (except iterators/tiny scope; `i` only for loops). Use `_` for ignored vars.
* **Casing:** Match current file style; else language common style. `UPPER_CASE` for constants only.
* **Booleans:** Prefer `is_` prefix for boolean functions.
* **File Headers:** Top comment: Title (descriptive, not filename) + brief purpose. No version/OS info.

### 5.4. Documentation & Comments

* **Docstrings:** Required for public functions, classes, modules (standard format).
* **Code Comments:** Explain non-obvious logic, complex algorithms, decisions (*why*, not *what*).
* **Reasoning Comments:** Use `# Reason:` for complex block rationale.
* **README Updates:** Update `docs/README.md` for core features, dependency changes, or setup/build modifications.

## 6. Testing

* **Goal:** Tests are living documentation specifying behavior. Use common language framework.
* **Behavior Specification:** Tests specify behavior. Type/scope/timing (e.g., E2E, Unit, Integration) defined in `docs/PRD.md` per project phase.
* **Location:** Place tests in `/src/test` (Lua: `/src/spec`), mirroring `src/` structure (Sec 4).
    * Ex: Tests for `src/engine/mod.js` -> `src/test/engine/mod_test.js`.
    * Ex: Lua spec for `src/engine/mod.lua` -> `src/spec/engine/mod_spec.lua`.
* **Content:** Tests clearly describe expected behavior per `PRD.md` goals for the current phase.
    * **Prototype Phase:** Primary focus on automated E2E tests validating core functionality.
* **Strategy & Coverage:** Defined in `PRD.md`, evolves with phases.
    * **Prototype Phase:** E2E priority. Comprehensive unit tests & code coverage metrics (e.g., 100% statement coverage) are **not** the focus *unless* specified in `docs/PRD.md` for a later phase demanding them.
* **Updating Tests:** Review/update tests with code changes to reflect *current* expected behavior. Fix failing/outdated tests promptly.

## 7. AI Interaction Protocols

### 7.1. Engineering Role & Audience

* **Role:** Act as a **Senior Software Engineer**.
* **Audience:** Target **Mid-Level Software Engineers** (code = best practices, clear, documented; explanations thorough; justify complex choices).

### 7.2. Interaction Guidelines

* Ask clarifying questions if needed; do not assume.
* Verify facts (libs, APIs, file paths); do not invent. Use MCP servers if available.
* Do not delete/overwrite code unless instructed or part of the defined task.
* Report significant blockers/errors *during* implementation promptly with context and suggestions.
* If a task seems complex, state potential benefit from a more advanced model **boldly** at the start (e.g., "**Suggestion: This complex refactoring might benefit from a more advanced model.**").
* Be friendly, helpful, collaborative.
* Explicitly state when task requirements are met. Mark task complete in `docs/TASKS.md`.



================================================
File: .github/dependabot.yml
================================================
version: 2
updates:
  - package-ecosystem: "github-actions"
    directory: "/"
    schedule:
      # Check for updates to GitHub Actions every week
      interval: "weekly"



================================================
File: .github/deactivated/release.yml
================================================
name: Create Release

on:
  workflow_dispatch:
    inputs:
      bump_type:
        description: "Type of version bump (alpha, beta, rc, promote_to_final, patch, minor, major)"
        required: true
        default: "alpha"
        type: choice
        options:
          - alpha
          - beta
          - rc
          - promote_to_final
          - patch
          - minor
          - major
      draft_release:
        description: "Create as a draft release?"
        required: true
        default: "false"
        type: boolean

permissions:
  contents: read

jobs:
  determine_version:
    runs-on: ubuntu-latest
    outputs:
      next_version: ${{ steps.get_version.outputs.next_version }}
      is_prerelease: ${{ steps.get_version.outputs.is_prerelease }}
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
        with:
          egress-policy: audit

      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 0 # Required to fetch all tags

      - name: Set up Python
        uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065 # v5.6.0
        with:
          python-version: '3.x'

      - name: Install dependencies
        run: pip install semver

      - name: Determine next version
        id: get_version
        env:
          BUMP_TYPE: ${{ github.event.inputs.bump_type }}
        run: python .github/scripts/determine_next_version.py

  build_and_release:
    needs: determine_version
    if: needs.determine_version.outputs.next_version != ''
    runs-on: ubuntu-latest
    permissions:
      contents: write # Required to create releases and tags
    strategy:
      matrix:
        goos: [linux, windows, darwin]
        goarch: [amd64, arm64]
        exclude: # Add exclusions if some combinations are not needed/supported
          - goos: windows
            goarch: arm64 # Example: if windows arm64 is not a target

    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
        with:
          egress-policy: audit

      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Set up Go
        uses: actions/setup-go@d35c59abb061a4a6fb18e82ac0862c26744d6ab5 # v5.5.0
        with:
          go-version: '1.21' # As per PRD

      - name: Set version output
        id: version_output
        run: |
          echo "NEXT_VERSION=${{ needs.determine_version.outputs.next_version }}" >> $GITHUB_ENV
          echo "IS_PRERELEASE=${{ needs.determine_version.outputs.is_prerelease }}" >> $GITHUB_ENV

      - name: Build application
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
          VERSION: ${{ env.NEXT_VERSION }}
        run: |
          echo "Building for $GOOS/$GOARCH with version $VERSION"
          BINARY_NAME="almd"
          if [ "$GOOS" == "windows" ]; then
            BINARY_NAME="almd.exe"
          fi
          go build -v -o $BINARY_NAME -ldflags="-X 'main.version=$VERSION'" ./cmd/almd
          ls -la $BINARY_NAME # Verify binary exists

      - name: Archive binary
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
          VERSION_NO_V: ${{ env.NEXT_VERSION }} # Assuming NEXT_VERSION has 'v' prefix
        run: |
          VERSION_TAG=${VERSION_NO_V#v} # Remove 'v' prefix for filename
          ARCHIVE_NAME="almd_${VERSION_TAG}_${GOOS}_${GOARCH}"
          BINARY_NAME="almd"
          if [ "$GOOS" == "windows" ]; then
            BINARY_NAME="almd.exe"
            zip "${ARCHIVE_NAME}.zip" $BINARY_NAME
            echo "ASSET_NAME=${ARCHIVE_NAME}.zip" >> $GITHUB_ENV
            echo "ASSET_PATH=${ARCHIVE_NAME}.zip" >> $GITHUB_ENV
          else
            tar -czvf "${ARCHIVE_NAME}.tar.gz" $BINARY_NAME
            echo "ASSET_NAME=${ARCHIVE_NAME}.tar.gz" >> $GITHUB_ENV
            echo "ASSET_PATH=${ARCHIVE_NAME}.tar.gz" >> $GITHUB_ENV
          fi
          ls -la $ASSET_PATH # Verify archive exists

      - name: Upload artifact for this job
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: almd-binaries-${{ matrix.goos }}-${{ matrix.goarch }}
          path: ${{ env.ASSET_PATH }}

  create_release_tag:
    needs: [determine_version, build_and_release] # Ensure build_and_release completes for all platforms
    runs-on: ubuntu-latest
    if: needs.determine_version.outputs.next_version != ''
    permissions:
      contents: write
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
        with:
          egress-policy: audit

      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 0

      - name: Create Git Tag
        env:
          NEXT_VERSION: ${{ needs.determine_version.outputs.next_version }}
        run: |
          echo "Creating tag $NEXT_VERSION"
          git tag $NEXT_VERSION
          git push origin $NEXT_VERSION

      - name: Download all artifacts
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
        with:
          path: release-artifacts # Download all artifacts to this directory
          # No specific name means download all artifacts from the run

      - name: List downloaded artifacts
        run: |
          ls -R release-artifacts

      - name: Create GitHub Release
        id: create_release
        uses: softprops/action-gh-release@da05d552573ad5aba039eaac05058a918a7bf631 # v2.2.2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.determine_version.outputs.next_version }}
          name: Release ${{ needs.determine_version.outputs.next_version }}
          body: |
            Automated release for version ${{ needs.determine_version.outputs.next_version }}.
            See CHANGELOG.md for details (if available).
          draft: ${{ github.event.inputs.draft_release == 'true' }}
          prerelease: ${{ needs.determine_version.outputs.is_prerelease == 'true' }}
          files: |
            release-artifacts/almd-binaries-linux-amd64/*.tar.gz
            release-artifacts/almd-binaries-linux-arm64/*.tar.gz
            release-artifacts/almd-binaries-windows-amd64/*.zip
            release-artifacts/almd-binaries-darwin-amd64/*.tar.gz
            release-artifacts/almd-binaries-darwin-arm64/*.tar.gz



================================================
File: .github/scripts/determine_next_version.py
================================================
import os
import subprocess
import semver
import sys

def get_tags():
    try:
        result = subprocess.run(['git', 'tag', '-l', 'v*', '--sort=v:refname'], capture_output=True, text=True, check=True)
        tags = result.stdout.strip().split('\n')
        return [tag for tag in tags if tag] # Filter out empty strings if any
    except subprocess.CalledProcessError as e:
        print(f"Error fetching tags: {e}", file=sys.stderr)
        return []

def get_latest_semver(tags):
    latest_v = None
    for tag_str in reversed(tags): # Iterate from newest to oldest based on git sort
        try:
            v = semver.VersionInfo.parse(tag_str[1:]) # Remove 'v' prefix
            if latest_v is None or v > latest_v:
                latest_v = v
        except ValueError:
            # Not a valid semver tag, skip
            continue
    return latest_v

def get_latest_prerelease_for_base(tags, base_version, token):
    """
    Finds the latest prerelease tag for a given base version and token.
    Example: base_version = 0.2.0, token = 'alpha' -> finds latest v0.2.0-alpha.N
    Returns a semver.VersionInfo object or None.
    """
    latest_prerelease_v = None
    for tag_str in reversed(tags): # Assumes tags are sorted v:refname
        try:
            v = semver.VersionInfo.parse(tag_str[1:])
            if v.major == base_version.major and \
               v.minor == base_version.minor and \
               v.patch == base_version.patch and \
               v.prerelease and len(v.prerelease) == 2 and v.prerelease[0] == token:
                # Compare numeric part of the prerelease
                if latest_prerelease_v is None or v.prerelease[1] > latest_prerelease_v.prerelease[1]:
                    latest_prerelease_v = v
        except ValueError:
            # Not a valid semver tag or unexpected prerelease format
            continue
        except TypeError:
            # Handle cases where prerelease[1] might not be comparable (e.g., not an int)
            print(f"Warning: Prerelease part of tag {tag_str} is not as expected for comparison.", file=sys.stderr)
            continue
    return latest_prerelease_v

def main():
    bump_type = os.environ.get('BUMP_TYPE')
    if not bump_type:
        print("Error: BUMP_TYPE environment variable not set.", file=sys.stderr)
        sys.exit(1)

    tags = get_tags()
    latest_v = get_latest_semver(tags)

    next_v_str = ""
    is_prerelease = "true"

    if not latest_v:
        if bump_type == 'alpha':
            next_v = semver.VersionInfo(0, 2, 0, prerelease='alpha.1')
            # Check for existing tags and bump if necessary
            temp_next_v_tag = f"v{str(next_v)}"
            while temp_next_v_tag in tags: # 'tags' contains all existing v* tags
                next_v = next_v.bump_prerelease(token='alpha')
                temp_next_v_tag = f"v{str(next_v)}"
            next_v_str = str(next_v)
        else:
            print(f"Error: No existing tags found. Initial bump must be 'alpha' to start with 0.2.0-alpha.1.", file=sys.stderr)
            sys.exit(1)
    else:
        current_v = latest_v
        if bump_type == 'alpha':
            if current_v.prerelease and current_v.prerelease[0] == 'alpha':
                next_v = current_v.bump_prerelease(token='alpha')
            else: # New alpha series for current major.minor.patch or next patch
                # If current is final (e.g. 0.1.0), new alpha is 0.1.0-alpha.1
                # If current is rc (e.g. 0.1.0-rc.1), new alpha is 0.1.0-alpha.1
                # If current is beta (e.g. 0.1.0-beta.1), new alpha is 0.1.0-alpha.1
                next_v = semver.VersionInfo(current_v.major, current_v.minor, current_v.patch, prerelease='alpha.1')

            # Check for existing tags and bump if necessary
            temp_next_v_tag = f"v{str(next_v)}"
            while temp_next_v_tag in tags:
                next_v = next_v.bump_prerelease(token='alpha') # Bumps 'alpha.1' to 'alpha.2', etc.
                temp_next_v_tag = f"v{str(next_v)}"
            next_v_str = str(next_v)
        elif bump_type == 'beta':
            if current_v.prerelease and current_v.prerelease[0] == 'beta':
                next_v = current_v.bump_prerelease(token='beta')
            else: # New beta series, must come from alpha or be a new beta for a version
                # e.g., 0.1.0-alpha.2 -> 0.1.0-beta.1
                next_v = semver.VersionInfo(current_v.major, current_v.minor, current_v.patch, prerelease='beta.1')

            # Check for existing tags and bump if necessary
            temp_next_v_tag = f"v{str(next_v)}"
            while temp_next_v_tag in tags:
                next_v = next_v.bump_prerelease(token='beta')
                temp_next_v_tag = f"v{str(next_v)}"
            next_v_str = str(next_v)
        elif bump_type == 'rc':
            if current_v.prerelease and current_v.prerelease[0] == 'rc':
                next_v = current_v.bump_prerelease(token='rc')
            else: # New RC series
                next_v = semver.VersionInfo(current_v.major, current_v.minor, current_v.patch, prerelease='rc.1')

            # Check for existing tags and bump if necessary
            temp_next_v_tag = f"v{str(next_v)}"
            while temp_next_v_tag in tags:
                next_v = next_v.bump_prerelease(token='rc')
                temp_next_v_tag = f"v{str(next_v)}"
            next_v_str = str(next_v)
        elif bump_type == 'promote_to_final':
            if not current_v.prerelease:
                print(f"Error: Version {current_v} is already final. Cannot promote.", file=sys.stderr)
                sys.exit(1)
            next_v = current_v.finalize_version()
            next_v_str = str(next_v)
            is_prerelease = "false"
        elif bump_type == 'patch':
            # For patch, minor, major, we always bump from the finalized version of the *overall* latest tag.
            base_v = current_v.finalize_version()
            next_v = base_v.bump_patch()
            next_v_str = str(next_v)
            is_prerelease = "false"
        elif bump_type == 'minor':
            base_v = current_v.finalize_version()
            next_v = base_v.bump_minor()
            next_v_str = str(next_v)
            is_prerelease = "false"
        elif bump_type == 'major':
            base_v = current_v.finalize_version()
            next_v = base_v.bump_major()
            next_v_str = str(next_v)
            is_prerelease = "false"
        else:
            print(f"Error: Unknown BUMP_TYPE '{bump_type}'", file=sys.stderr)
            sys.exit(1)

    if not next_v_str.startswith('v'):
        next_v_tag = f"v{next_v_str}"
    else:
        next_v_tag = next_v_str


    print(f"Calculated next version: {next_v_tag}", file=sys.stderr)
    print(f"::set-output name=next_version::{next_v_tag}")
    print(f"::set-output name=is_prerelease::{is_prerelease}")

if __name__ == "__main__":
    main()



================================================
File: .github/workflows/ci.yml
================================================
name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    runs-on: ${{ matrix.os }}
    steps:
    - uses: actions/checkout@v3
      with:
        submodules: 'recursive' # Ensure submodules like SDL are checked out

    - name: Setup .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: | # Specify SDK versions if particular ones are needed, or remove for latest
          9.0.x

    - name: Check Formatting
      run: dotnet format --verify-no-changes --verbosity diagnostic Night.sln

    - name: Restore dependencies
      run: dotnet restore Night.sln

    - name: Build Solution
      run: dotnet build Night.sln --configuration Release --no-restore

    - name: Run Tests (Night.Tests) # Placeholder for engine unit tests
      run: dotnet test tests/Night.Tests/Night.Tests.csproj --no-build --configuration Release # Adjust path if needed

    # - name: Run Tests (Night.SampleGame.Tests) # Placeholder for sample game integration tests (if any)



================================================
File: .github/workflows/codeql-analysis.yml
================================================
name: "CodeQL C# Analysis"

on:
  push:
    branches: ["main"]
  pull_request:
    # The branches below must be a subset of the branches above
    branches: ["main"]

permissions:
  contents: read

jobs:
  analyze:
    name: Analyze C#
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
      security-events: write

    strategy:
      fail-fast: false
      matrix:
        language: ["csharp"]
        # CodeQL supports [ csharp, cpp, go, java, javascript, python, ruby ]
        # Learn more about CodeQL language support at https://aka.ms/codeql-docs/language-support

    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
        with:
          egress-policy: audit

      - name: Checkout repository
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          # We must fetch all history for CodeQL to correctly analyze commits
          fetch-depth: 0

      # Initializes the CodeQL tools for scanning.
      - name: Initialize CodeQL
        uses: github/codeql-action/init@60168efe1c415ce0f5521ea06d5c2062adbeed1b # v3.28.17
        with:
          languages: ${{ matrix.language }}
          # If you wish to specify custom queries, you can do so here or in a config file.
          # By default, queries listed here will override any specified in a config file.
          # Prefix the list here with "+" to use these queries and those in the config file.

      # Autobuild attempts to build any compiled languages (C/C++, C#, or Java).
      # If this step fails, then you should remove it and run the build manually.
      # For .NET Core, ensure that the .NET SDK is available.
      # You might need to add a setup-dotnet step if not using a GitHub-hosted runner with it pre-installed.
      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: 9.0.x

      - name: Autobuild
        uses: github/codeql-action/autobuild@60168efe1c415ce0f5521ea06d5c2062adbeed1b # v3.28.17

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@60168efe1c415ce0f5521ea06d5c2062adbeed1b # v3.28.17
        with:
          category: "/language:${{matrix.language}}"



================================================
File: .github/workflows/dependency-review.yml
================================================
# Dependency Review Action
#
# This Action will scan dependency manifest files that change as part of a Pull Request,
# surfacing known-vulnerable versions of the packages declared or updated in the PR.
# Once installed, if the workflow run is marked as required,
# PRs introducing known-vulnerable packages will be blocked from merging.
#
# Source repository: https://github.com/actions/dependency-review-action
name: 'Dependency Review'
on: [pull_request]

permissions:
  contents: read

jobs:
  dependency-review:
    runs-on: ubuntu-latest
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
        with:
          egress-policy: audit

      - name: 'Checkout Repository'
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
      - name: 'Dependency Review'
        uses: actions/dependency-review-action@38ecb5b593bf0eb19e335c03f97670f792489a8b # v4.7.0



================================================
File: .github/workflows/scorecard.yml
================================================
# This workflow uses actions that are not certified by GitHub. They are provided
# by a third-party and are governed by separate terms of service, privacy
# policy, and support documentation.

name: Scorecard supply-chain security
on:
  # For Branch-Protection check. Only the default branch is supported. See
  # https://github.com/ossf/scorecard/blob/main/docs/checks.md#branch-protection
  branch_protection_rule:
  # To guarantee Maintained check is occasionally updated. See
  # https://github.com/ossf/scorecard/blob/main/docs/checks.md#maintained
  schedule:
    - cron: '26 19 * * 2'
  push:
    branches: [ "main" ]

# Declare default permissions as read only.
permissions: read-all

jobs:
  analysis:
    name: Scorecard analysis
    runs-on: ubuntu-latest
    # `publish_results: true` only works when run from the default branch. conditional can be removed if disabled.
    if: github.event.repository.default_branch == github.ref_name || github.event_name == 'pull_request'
    permissions:
      # Needed to upload the results to code-scanning dashboard.
      security-events: write
      # Needed to publish results and get a badge (see publish_results below).
      id-token: write
      # Uncomment the permissions below if installing in a private repository.
      # contents: read
      # actions: read

    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
        with:
          egress-policy: audit

      - name: "Checkout code"
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          persist-credentials: false

      - name: "Run analysis"
        uses: ossf/scorecard-action@f49aabe0b5af0936a0987cfb85d86b75731b0186 # v2.4.1
        with:
          results_file: results.sarif
          results_format: sarif
          # (Optional) "write" PAT token. Uncomment the `repo_token` line below if:
          # - you want to enable the Branch-Protection check on a *public* repository, or
          # - you are installing Scorecard on a *private* repository
          # To create the PAT, follow the steps in https://github.com/ossf/scorecard-action?tab=readme-ov-file#authentication-with-fine-grained-pat-optional.
          # repo_token: ${{ secrets.SCORECARD_TOKEN }}

          # Public repositories:
          #   - Publish results to OpenSSF REST API for easy access by consumers
          #   - Allows the repository to include the Scorecard badge.
          #   - See https://github.com/ossf/scorecard-action#publishing-results.
          # For private repositories:
          #   - `publish_results` will always be set to `false`, regardless
          #     of the value entered here.
          publish_results: true

          # (Optional) Uncomment file_mode if you have a .gitattributes with files marked export-ignore
          # file_mode: git

      # Upload the results as artifacts (optional). Commenting out will disable uploads of run results in SARIF
      # format to the repository Actions tab.
      - name: "Upload artifact"
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: SARIF file
          path: results.sarif
          retention-days: 5

      # Upload the results to GitHub's code scanning dashboard (optional).
      # Commenting out will disable upload of results to your repo's Code Scanning dashboard
      - name: "Upload to code-scanning"
        uses: github/codeql-action/upload-sarif@60168efe1c415ce0f5521ea06d5c2062adbeed1b # v3.28.17
        with:
          sarif_file: results.sarif





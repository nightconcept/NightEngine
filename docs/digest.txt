Directory structure:
└── any2/
    ├── README.md
    ├── LICENSE
    ├── Night.sln
    ├── .editorconfig
    ├── .pre-commit-config.yaml
    ├── docs/
    │   ├── PRD.md
    │   ├── operational-guidelines.md
    │   ├── .DS_Store
    │   ├── epics/
    │   │   ├── epic1.md
    │   │   ├── epic2.md
    │   │   ├── epic3.md
    │   │   ├── epic4.md
    │   │   ├── epic5.md
    │   │   ├── epic6.md
    │   │   └── epic7.md
    │   └── love2d-api/
    │       ├── audio.md
    │       ├── data.md
    │       ├── event.md
    │       ├── filesystem.md
    │       ├── font.md
    │       ├── graphics.md
    │       ├── image.md
    │       ├── joystick.md
    │       ├── keyboard.md
    │       ├── love.md
    │       ├── math.md
    │       ├── mouse.md
    │       ├── physics.md
    │       ├── sound.md
    │       ├── system.md
    │       ├── thread.md
    │       ├── timer.md
    │       ├── touch.md
    │       ├── video.md
    │       └── window.md
    ├── lib/
    ├── scripts/
    │   └── update_sdl3.py
    ├── src/
    │   ├── Night.Engine/
    │   │   ├── FrameworkLoop.cs
    │   │   ├── Night.Engine.csproj
    │   │   ├── Types.cs
    │   │   ├── Modules/
    │   │   │   ├── Graphics.cs
    │   │   │   ├── Keyboard.cs
    │   │   │   ├── Mouse.cs
    │   │   │   ├── SDL.cs
    │   │   │   └── Window.cs
    │   │   ├── bin/
    │   │   └── obj/
    │   └── Night.SampleGame/
    │       ├── Night.SampleGame.csproj
    │       ├── Program.cs
    │       ├── bin/
    │       └── obj/
    ├── .cursor/
    ├── .github/
    │   ├── CODEOWNERS
    │   ├── copilot-instructions.md
    │   ├── dependabot.yml
    │   ├── deactivated/
    │   │   ├── build-sdl3.yml
    │   │   ├── ci.yml
    │   │   ├── codeql.yml
    │   │   ├── dependency-review.yml
    │   │   ├── release.yml
    │   │   └── scorecard.yml
    │   └── scripts/
    │       └── determine_next_version.py
    ├── .roo/
    └── .windsurf/

================================================
File: README.md
================================================
# Night Engine

A C# game engine built on top of SDL3.

This project aims to provide a simple, Love2D-inspired API for C# developers to create games and multimedia applications using the power of SDL3.

## Project Structure

- `/Night.Engine`: The core engine library.
- `/Night.SampleGame`: A sample game demonstrating engine features.
- `/docs`: Project documentation (PRD, tasks, etc.).
- `/scripts`: Utility scripts (e.g., for fetching SDL3).

## Getting Started

(Instructions to be added once the engine is further developed)
## macOS Development Notes

### VS Code and `mise` for .NET SDK Versioning

If you are using `mise` to manage your .NET SDK versions on macOS, you might encounter issues where VS Code (when launched via its `.app` bundle, e.g., from Finder, Spotlight, or Raycast) does not correctly pick up the `mise`-activated .NET SDK. This can lead to:
- Linter errors complaining about incorrect .NET versions or missing fundamental types.
- NuGet restore failures (e.g., `NETSDK1045` error) because VS Code's C# Dev Kit attempts to use a globally installed .NET SDK (like .NET 8) instead of the project-specified one (e.g., .NET 9).

This happens because GUI-launched applications on macOS do not typically inherit the full shell environment (like `PATH` modifications) that `mise` sets up in your terminal.

**Solution: Wrapper Script for Launching VS Code**

To ensure VS Code launches with the correct `mise`-managed environment, you can use a wrapper shell script. This script explicitly sets up the environment before launching VS Code.

1.  **Create the script** (e.g., save as `~/vscode-launcher.sh` or `~/bin/vscode-launcher.sh`):
    ```zsh
    #!/bin/zsh

    # Wrapper script to launch VS Code with the mise-managed environment.

    # Add mise shims directory to PATH
    MISE_SHIMS_PATH="$HOME/.local/share/mise/shims"
    export PATH="$MISE_SHIMS_PATH:$PATH"

    # Optional: Navigate to your specific project directory if desired
    # cd "/path/to/your/project"

    # Launch VS Code, passing through any arguments
    exec code "$@"
    ```

2.  **Make it executable:**
    ```bash
    chmod +x /path/to/your/vscode-launcher.sh
    ```

3.  **Configure your launcher** (e.g., Raycast, Alfred, or even a custom Dock icon) to execute this script instead of `Visual Studio Code.app` directly.

This ensures that VS Code and its extensions (like the C# Dev Kit) inherit the correct PATH and use the .NET SDK version specified by `mise` for your project.


================================================
File: LICENSE
================================================
MIT License

Copyright (c) 2025 Danny Solivan

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
File: Night.sln
================================================
﻿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.31903.59
MinimumVisualStudioVersion = 10.0.40219.1
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "src", "src", "{827E0CD3-B72D-47B6-A68D-7590B98EB39B}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Night.Engine", "src\Night.Engine\Night.Engine.csproj", "{259774D0-6C26-4CD6-8611-D184D8D04BF4}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Night.SampleGame", "src\Night.SampleGame\Night.SampleGame.csproj", "{665B8256-5042-4354-99DC-25D560A0DF8B}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|Any CPU = Release|Any CPU
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{259774D0-6C26-4CD6-8611-D184D8D04BF4}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{259774D0-6C26-4CD6-8611-D184D8D04BF4}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{259774D0-6C26-4CD6-8611-D184D8D04BF4}.Debug|x64.ActiveCfg = Debug|Any CPU
		{259774D0-6C26-4CD6-8611-D184D8D04BF4}.Debug|x64.Build.0 = Debug|Any CPU
		{259774D0-6C26-4CD6-8611-D184D8D04BF4}.Debug|x86.ActiveCfg = Debug|Any CPU
		{259774D0-6C26-4CD6-8611-D184D8D04BF4}.Debug|x86.Build.0 = Debug|Any CPU
		{259774D0-6C26-4CD6-8611-D184D8D04BF4}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{259774D0-6C26-4CD6-8611-D184D8D04BF4}.Release|Any CPU.Build.0 = Release|Any CPU
		{259774D0-6C26-4CD6-8611-D184D8D04BF4}.Release|x64.ActiveCfg = Release|Any CPU
		{259774D0-6C26-4CD6-8611-D184D8D04BF4}.Release|x64.Build.0 = Release|Any CPU
		{259774D0-6C26-4CD6-8611-D184D8D04BF4}.Release|x86.ActiveCfg = Release|Any CPU
		{259774D0-6C26-4CD6-8611-D184D8D04BF4}.Release|x86.Build.0 = Release|Any CPU
		{665B8256-5042-4354-99DC-25D560A0DF8B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{665B8256-5042-4354-99DC-25D560A0DF8B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{665B8256-5042-4354-99DC-25D560A0DF8B}.Debug|x64.ActiveCfg = Debug|Any CPU
		{665B8256-5042-4354-99DC-25D560A0DF8B}.Debug|x64.Build.0 = Debug|Any CPU
		{665B8256-5042-4354-99DC-25D560A0DF8B}.Debug|x86.ActiveCfg = Debug|Any CPU
		{665B8256-5042-4354-99DC-25D560A0DF8B}.Debug|x86.Build.0 = Debug|Any CPU
		{665B8256-5042-4354-99DC-25D560A0DF8B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{665B8256-5042-4354-99DC-25D560A0DF8B}.Release|Any CPU.Build.0 = Release|Any CPU
		{665B8256-5042-4354-99DC-25D560A0DF8B}.Release|x64.ActiveCfg = Release|Any CPU
		{665B8256-5042-4354-99DC-25D560A0DF8B}.Release|x64.Build.0 = Release|Any CPU
		{665B8256-5042-4354-99DC-25D560A0DF8B}.Release|x86.ActiveCfg = Release|Any CPU
		{665B8256-5042-4354-99DC-25D560A0DF8B}.Release|x86.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{259774D0-6C26-4CD6-8611-D184D8D04BF4} = {827E0CD3-B72D-47B6-A68D-7590B98EB39B}
		{665B8256-5042-4354-99DC-25D560A0DF8B} = {827E0CD3-B72D-47B6-A68D-7590B98EB39B}
	EndGlobalSection
EndGlobal



================================================
File: .editorconfig
================================================
# top-most EditorConfig file
root = true

# Unix-style newlines with a newline ending every file
[*]
end_of_line = lf
insert_final_newline = true
trim_trailing_whitespace = true

[*.{cs}]
indent_style = space
indent_size = 2
csharp_max_line_length = 100
dotnet_sort_system_directives_first = true
dotnet_separate_import_directive_groups = true
csharp_preferred_using_directive_placement = outside_namespace:suggestion

# Style - Naming Conventions
dotnet_diagnostic.IDE1006.severity = error # Naming rule violation (covers PascalCase, camelCase, _camelCase based on symbols)
dotnet_diagnostic.IDE0051.severity = warning # Remove unused private members
dotnet_diagnostic.IDE0052.severity = warning # Remove unread private members
dotnet_diagnostic.IDE0060.severity = warning # Remove unused parameter

# Style - Code Clarity and Consistency
dotnet_diagnostic.IDE0003.severity = suggestion # Add 'this.' or 'Me.' qualification
dotnet_diagnostic.IDE0009.severity = suggestion # Add 'this.' or 'Me.' qualification (for members)
dotnet_diagnostic.IDE0011.severity = suggestion # Add braces
dotnet_diagnostic.IDE0017.severity = suggestion # Simplify object initialization
dotnet_diagnostic.IDE0028.severity = suggestion # Simplify collection initialization
dotnet_diagnostic.IDE0036.severity = suggestion # Order modifiers
dotnet_diagnostic.IDE0040.severity = suggestion # Add accessibility modifiers
dotnet_diagnostic.IDE0041.severity = warning # Use 'is null' check
dotnet_diagnostic.IDE0044.severity = suggestion # Make field readonly
dotnet_diagnostic.IDE0055.severity = error # Format document (enforce dotnet format)
dotnet_diagnostic.IDE0058.severity = warning # Remove unnecessary expression value
dotnet_diagnostic.IDE0059.severity = warning # Remove unnecessary value assignment
dotnet_diagnostic.IDE0063.severity = suggestion # Use simple 'using' statement
dotnet_diagnostic.IDE0066.severity = suggestion # Use switch expression
dotnet_diagnostic.IDE0074.severity = suggestion # Use coalesce compound assignment
dotnet_diagnostic.IDE0090.severity = suggestion # Simplify 'new' expression

# Style - Expression-bodied members (preference for conciseness where appropriate)
dotnet_style_prefer_expression_bodied_constructors = false
dotnet_style_prefer_expression_bodied_methods = true:suggestion
dotnet_style_prefer_expression_bodied_operators = true:suggestion
dotnet_style_prefer_expression_bodied_properties = true:suggestion
dotnet_style_prefer_expression_bodied_indexers = true:suggestion
dotnet_style_prefer_expression_bodied_accessors = true:suggestion
dotnet_style_prefer_expression_bodied_lambdas = true:suggestion
dotnet_style_prefer_expression_bodied_local_functions = true:suggestion

# Quality - General
dotnet_diagnostic.CA1822.severity = warning # Mark members as static (if no instance data is accessed)
dotnet_diagnostic.CA2211.severity = warning # Non-constant fields should not be visible

# use 2-spaces for csproj
[*.{csproj,vbproj,vcxproj,vcxproj.filters,proj,nativeproj,locproj}]
indent_style = space
indent_size = 2



================================================
File: .pre-commit-config.yaml
================================================
# Top-level pre-commit config for C# project
repos:
  - repo: local
    hooks:
      - id: dotnet-format
        name: dotnet format
        entry: dotnet format Night.sln --verify-no-changes
        language: system
        types: [csharp]
        pass_filenames: false # Run on the whole solution if any C# file changes
        always_run: false
  - repo: https://github.com/gitleaks/gitleaks
    rev: v8.18.2 # Updated to a more recent version
    hooks:
      - id: gitleaks
  - repo: https://github.com/jumanjihouse/pre-commit-hooks
    rev: 3.0.0
    hooks:
      - id: shellcheck
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.6.0 # Updated to a more recent version
    hooks:
      - id: end-of-file-fixer
      - id: trailing-whitespace
      - id: check-yaml
      - id: check-json
      - id: check-merge-conflict
      - id: check-case-conflict
      - id: check-added-large-files



================================================
File: docs/PRD.md
================================================
# Night Engine - Product Requirements Document

## 1. Introduction

- **Project Idea:** Create a layered system for game and multimedia development in C#. This system consists of "Night.Framework," a low-level, Love2D-inspired API built directly on SDL3 (via SDL3-CS bindings), and "Night.Engine," a higher-level, more opinionated set of tools and systems that will be built on top of Night.Framework.
- **Problem/Need:** The primary goal is to provide a streamlined and efficient development workflow for C# developers. Night.Framework offers direct, SDL3-powered capabilities with a familiar API style, reducing context switching compared to using disparate tools or multiple languages directly. Night.Engine (to be developed later) will further simplify complex game development tasks by providing common engine systems.
- **Development Goal:** The main goal for the current development phase is to establish a robust Night.Framework, providing a foundational C# wrapper layer where a developer can leverage SDL3's capabilities primarily through C#. This involves achieving a comfortable level of C# integration with core SDL3 features, aiming for an API style reminiscent of Love2D, to simplify development. Future phases will focus on building out Night.Engine components.


## 2. Core Features

This section outlines the core modules and functionalities of **Night.Framework**, followed by planned features for **Night.Engine**.

**Night.Framework (Love2D-style API):**
- **Feature 0: Project Foundation & SDL3 Integration:**
    - **Description:** Establishes the C# project structure for Night.Framework and Night.Engine, a build process, and utilizes the SDL3-CS C# bindings for SDL3 integration. This ensures a working development and build environment. SDL3 native libraries are managed via pre-built binaries, potentially updated via a script.

- **Feature 1: Window Management (`Night.Window`):**
    - **Description:** Provides capabilities to create, configure, and manage the application window, using the `Night` namespace and an API style similar to Love2D's `love.window` module. This includes setting mode, title, and checking window state.

- **Feature 2: Input Handling (`Night.Input`, encompassing Keyboard and Mouse):**
    - **Description:** Allows the C# application to poll keyboard and mouse states, or receive input events, using the `Night` namespace and mirroring Love2D's `love.keyboard` and `love.mouse` modules. This includes checking key/button presses and getting mouse position.

- **Feature 3: 2D Graphics Rendering (`Night.Graphics`):**
    - **Description:** Enables loading images and drawing them as sprites, along with basic 2D graphics operations. This module uses the `Night` namespace, akin to Love2D's `love.graphics` module. It leverages SDL_Renderer for its operations. Key functionalities include loading images, drawing sprites with transformations, clearing the screen, and presenting the frame.

- **Feature 4: Game Loop Structure (`Night.Framework.Run`):**
    - **Description:** Provides a pre-defined game loop managed by Night.Framework. The C# developer implements specific callback functions (e.g., `Load`, `Update`, `Draw`) defined in the `Night.IGame` interface that the framework calls at appropriate times.

**Night.Engine** (Future Opinionated Systems - to be detailed in later PRD revisions):
- **Entity Component System (ECS):** A data-oriented framework for managing game objects and logic.
- **Scene Management:** Systems for organizing and managing game scenes.
- **Advanced Asset Management:** More sophisticated tools for handling game assets.
- **Physics Integration (Optional):** Wrappers or integration for a 2D/3D physics engine.
- **(Other high-level engine modules as defined)**


## 3. Technical Specifications
- **Primary Language(s):** C# 13 (using .NET 9).
- **Key Frameworks/Libraries:*
    - SDL3 (latest version, managed as pre-built binaries).
    - `flibitijibibo-sdl3-cs` (SDL3-CS): Approved C# bindings for SDL3, integrated as a git submodule or direct project reference.
    - No other external runtime libraries are planned for Night.Framework. Night.Engine may introduce dependencies later.

- **Database (if any):** None for Night.Framework or initial Night.Engine.

- **Key APIs/Integrations:**
    - Direct interaction with the SDL3 native library via the SDL3-CS C# bindings.

- **Rendering Backend:**
    - Night.Framework will utilize SDL_Renderer for 2D graphics operations. This is an internal implementation detail not directly exposed to the game developer using Night.Framework.
    - Future enhancements may explore migrating to SDL_GPU for potential performance benefits or advanced features.

- **Deployment Target:**
    - Night.Framework will be a C# class library (DLL).
    - Night.Engine (when developed) will be a separate C# class library (DLL) that depends on Night.Framework. For now, both Night.Framework and Night.Engine will be in a singular C# class library that is output as Night.Engine.
    - A separate C# "Sample Game" project will consume Night.Framework (and eventually Night.Engine) to demonstrate functionality.
    - **Target Platforms:** The long-term goal is to support Windows, macOS, Linux, iOS, and Android. Console support is a distant stretch goal.

- **High-Level Architectural Approach:**
    - **Night.Framework:** A C# library providing a static API, stylistically similar to Love2D, over the SDL3 native library (via SDL3-CS). It will manage interactions with SDL3-CS internally. The public API of Night.Framework will be designed for ease of use by C# game developers, primarily within the `Night` C# namespace.
    - **Night.Engine:** A C# library that will provide more opinionated game development constructs (e.g., ECS, scene management). It will use Night.Framework for its low-level operations and will not interact with SDL3 directly.

- **Critical Technical Decisions/Constraints:**
    - The public API of Night.Framework should closely mirror the structure and common function names of the Love2D API where practical and idiomatic for C#.
    - All interactions with SDL3 will be through the SDL3-CS bindings. Night.Engine will not use SDL3-CS directly.
    - A reliable mechanism for managing and loading SDL3 native libraries for target platforms is essential.
    - The primary focus for Night.Framework development is on simplicity, achieving the core Love2D-like developer experience for the defined features, and providing a solid foundation for Night.Engine.


## 4. Project Structure

```
/night-engine (root directory, formerly any2)
|-- .editorconfig
|-- .gitattributes
|-- .github/
|   |-- CODEOWNERS
|   |-- copilot-instructions.md
|   |-- dependabot.yml
|   |-- workflows/
|   |   |-- (active workflows, e.g., build, release)
|   |-- scripts/
|       |-- determine_next_version.py
|-- .gitignore
|-- .pre-commit-config.yaml
|-- LICENSE
|-- Night.sln
|-- README.md
|-- docs/
|   |-- PRD.md (this file)
|   |-- TASKS.md
|   |-- operational-guidelines.md
|   |-- epics/
|   |   |-- epic1.md
|   |   |-- ...
|   |-- love2d-api/
|       |-- audio.md
|       |-- graphics.md
|       |-- ...
|-- lib/
|   |-- SDL3-CS/ (git submodule or direct project files for SDL3 C# bindings)
|   |-- SDL3-Prebuilt/
|       |-- version.txt
|       |-- lib64/
|       |   |-- libSDL3.so.0
|       |-- macos/
|       |   |-- libSDL3.0.dylib
|       |-- win64/
|           |-- SDL3.dll
|-- scripts/
|   |-- update_sdl3.py
|-- src/
    |-- Night.Engine/
    |   |-- Night.Engine.csproj
    |   |-- Modules/
    |   |   |-- Window.cs
    |   |   |-- Graphics/
    |   |       |-- Graphics.cs
    |   |   |-- Keyboard.cs
    |   |   |-- Mouse.cs
    |   |   |-- Input.cs (if Keyboard and Mouse are combined or refactored)
    |   |   |-- ... (other framework modules)
    |   |-- FrameworkLoop.cs  (Manages Night.Framework.Run and game loop)
    |   |-- Types.cs          (Structs and interfaces)
    |   |-- Enums.cs          (Enums)
    |   |-- ... (Placeholder for future engine components: ECS, SceneManager, etc.)
    |-- Night.SampleGame/
        |-- Night.SampleGame.csproj
        |-- Program.cs        (Main entry point, calls Night.Framework.Run, provides IGame)
        |-- assets/
            |-- images/
            |-- sounds/
            |-- ...
```

- `/docs`: Project documentation (PRD, operational guidelines, tasks, API mapping, etc.).
- `/lib`: Contains external libraries.
    - `/lib/SDL3-CS`: Git submodule for the SDL3-CS bindings.
    - `/lib/SDL3-Prebuilt`: Pre-compiled SDL3 native binaries for various platforms, managed by `scripts/update_sdl3.py`.
- `/scripts`: Utility scripts for the project (e.g., `update_sdl3.py` for fetching SDL3 binaries).
- `/src`: Contains all C# source code.
    - `/src/Night.Engine`: C# class library project for the low-level Love2D-style API and opinionated engine. This project references SDL3-CS.
        - `Night.Engine.csproj`: MSBuild project file.
        - `/Modules/`: Directory containing individual C# files or folders for each Love2D-like module (e.g., `Window.cs`, `Graphics.cs`, `Keyboard.cs`, `Mouse.cs`). These will primarily contain static classes within the `Night` namespace.
        - `FrameworkLoop.cs`: Contains the main game loop logic (`Night.Framework.Run()`) and related infrastructure.
        - `Enums.cs`: Defines enums used by Night.Framework and consumer applications.
        - `Types.cs`: Defines core data types and interfaces (e.g., `Night.Color`, `Night.KeyCode`, `Night.Sprite`, `Night.IGame`) used by Night.Framework and consumer applications.
    - `/src/Night.SampleGame`: C# console application project demonstrating the use of Night.Framework (and eventually Night.Engine).
        - `Night.SampleGame.csproj`: MSBuild project file. References `Night.Framework`.
        - `Game.cs`: Implements `Night.IGame` with game-specific logic (`Load`, `Update`, `Draw`).
        - `Program.cs`: Main entry point for the sample game application.
        - `/assets`: Game assets like images or sound files needed for the sample game.
- `Night.sln`: The Visual Studio solution file, grouping `Night.Framework`, `Night.Engine`, and `Night.SampleGame` projects.
- `README.md`: The main readme for the project.
- `.github/`: GitHub-specific files like workflows and issue templates.
- `.editorconfig`, `.pre-commit-config.yaml`: Code style and pre-commit hook configurations.

## 5. File Descriptions

- **`Night.sln`**: Visual Studio Solution file grouping `Night.Engine`, and `Night.SampleGame` projects. Defines project paths, configurations, and dependencies.
- **`src/Night.Engine/Night.Engine.csproj`**: MSBuild project file for the Night.Framework and Night.Enginelibrary. Defines target framework (.NET 9), C# language version, references (notably SDL3-CS), and how native runtimes for SDL3 are handled/expected.
- **`src/Night.SampleGame/Night.SampleGame.csproj`**: MSBuild project file for the sample game application. References `Night.Framework`.


## 6. Future Considerations

**Out of Scope for Initial Night.Framework Development (beyond core Window, Input, Graphics, Game Loop):**

- **Full Love2D API Parity:** Only a subset of Love2D modules and features will be implemented initially in Night.Framework. Modules like `love.audio`, `love.filesystem`, `love.font`, `love.joystick`, `love.thread`, etc., are out of scope for the initial set of framework modules. Some may be added to Night.Framework later, or equivalents might be part of Night.Engine.

- **Advanced Rendering in Night.Framework:** Custom shaders, 3D graphics, complex lighting, particle systems beyond what SDL_Renderer offers for 2D sprites.
- **Audio** System, Font Rendering, Advanced Input (Joysticks, Touch), Physics Engine, Networking Capabilities in **Night.Framework:** These are not targeted for the initial Night.Framework release.
- **Comprehensive Error Handling:** Error handling will be functional but may be expanded later.
- **Performance Optimization:** Initial focus is on functional correctness and API design for Night.Framework.
- **Game Packaging/Distribution Tools, Editor/GUI Tools:** Not included.

**Potential Future Enhancements (Post-initial Night.Framework, potentially as part of Night.Engine or additions to Night.Framework):**

- **Night.Engine Core:**
    - **Entity Component System (ECS) Architecture**.
    - **Scene Management & Scene Graph.**
    - **Advanced Game State Management.**

- **Expanded Night.Framework Modules:**
    - **Audio Module (`Night.Audio`):** Integrate SDL_mixer (or equivalent SDL3 audio) for sound and music.
    - **Font Rendering (`Night.Font`):** Add support for loading fonts and rendering text (e.g., via SDL_ttf).
    - **Expanded Input (`Night.Joystick`, `Night.Touch`):** Support for game controllers and touch interfaces.
    - **More Graphics Primitives & Features:** Drawing shapes, basic shader integration via SDL_Renderer functions, and potentially a more advanced camera system.
    - **Filesystem Abstraction (`Night.Filesystem`):** Cross-platform API for file I/O.
    - **Timing** Module **(`Night.Timer`):** Advanced control over timing and FPS management.

- **Tooling & Developer Experience:**
    - **Dear ImGui Integration:** For debug UIs and simple in-game editors.
    - **Quake-Style Debug Console**.
    - **Lua Scripting Interface (long-term consideration)**.

- **General:**
    - **Improved Error Handling & Debugging Tools**.
    - **Performance Profiling and Optimization.**
    - **Expanded Platform Support Verification (Android, iOS).**
    - **Community Building: Tutorials, more examples, comprehensive documentation**.



================================================
File: docs/operational-guidelines.md
================================================
# Operational Guidelines

The "Night" engine project will adhere to the **Google C# Style Guide**. Key aspects of this guide, supplemented by project-specific interpretations, are outlined below. All developers are expected to familiarize themselves with the full guide.

- **Formatting & Style:**
  - **Indentation:** 2 spaces, no tabs.
  - **Column Limit:** 100 characters.
  - **Whitespace, Braces, Line Wrapping:** Adhere to the detailed rules in the Google C# Style Guide. This includes rules like no line break before an opening brace, and braces used even when optional.
  - **Tooling:**
    - `dotnet format` will be used to help enforce formatting rules.
    - An `.editorconfig` file will be added to the project root, configured to align with the Google C# Style Guide's formatting and style rules (e.g., indentation, column limit, using directives order).
- **Linting:**
  - **Tooling:** Utilize Roslyn Analyzers provided with the .NET SDK.
  - The `.editorconfig` file will be configured to enable and set the severity of analyzer rules to align with the principles of the Google C# Style Guide. This includes rules related to naming, organization, and other code quality aspects.
- **Naming Conventions:**
  - **General Rules Summary:**
    - Names of classes, methods, enumerations, public fields, public properties, namespaces: `PascalCase`.
    - Names of local variables, parameters: `camelCase`.
    - Names of private, protected, internal, and protected internal fields and properties: `_camelCase` (e.g., `_privateField`).
    - Naming convention is unaffected by modifiers such as `const`, `static`, `readonly`, etc..
    - For casing, a “word” is anything written without internal spaces, including acronyms (e.g., `MyRpc` not `MyRPC`).
    - Names of interfaces start with `I` (e.g., `IInterface`).
    - Filenames and directory names are `PascalCase` (e.g., `MyFile.cs`).
  - **Project Specific (API Design):** When naming public API elements for "Night" intended to mirror Love2D functions (e.g., `love.window.setTitle`), use the `PascalCase` version adhering to the above rules (e.g., `Night.Window.SetTitle(...)`).
- **Code Organization:**
  - **Modifier Order:** `public protected internal private new abstract virtual override sealed static readonly extern unsafe volatile async`.
  - **Namespace `using` Declarations:** Place at the top of the file, before any namespace declarations. Order alphabetically, with `System` imports always first.
  - **Class Member Ordering:** Follow the prescribed order: Nested types, static/const/readonly fields, instance fields/properties, constructors/finalizers, methods. Within each group, elements are ordered by access: Public, Internal, Protected internal, Protected, Private.
- **Key Principles (Project-Specific additions and emphasis):**
  - **API Design (Night Engine):** Strive for an API design that is idiomatic to C# while closely mirroring the spirit, structure, and ease of use of the Love2D API for the features being implemented.
  - **Clarity over Premature Optimization:** For the prototype, prioritize clear, understandable, and maintainable code.
  - **Scope Adherence:** Focus strictly on implementing the agreed-upon features (0-4) for this prototype.
- **Testing (if applicable for prototype):**
  - **Primary Integration Test:** The `Night.SampleGame` project will serve as the main method for testing the integration and functionality of the `Night.Framework` features.
  - **Unit Tests (Optional):** Consider adding basic unit tests for any complex internal helper functions or critical non-P/Invoke logic within `Night.Framework`.
  - **Manual Verification:** Manual testing of the sample game against the defined user actions and outcomes for each feature in the PRD will be essential.



================================================
File: docs/.DS_Store
================================================
[Non-text file]


================================================
File: docs/epics/epic1.md
================================================
**Epic 1: Project Setup & SDL3 Integration**

**Goal:** Establish the development environment, project structure as defined in the PRD, and ensure SDL3 native libraries are correctly fetched, linked, and usable by the C# projects.

- [x] **Task 1.0:** Align Project Structure with PRD Section 4 (Revised) (Status: Review)
    - [x] Review current project structure against `docs/PRD.md` Section 4 diagram.
    - [x] Move `Night.Engine/SDL3` submodule to `lib/SDL3-CS`.
    - [x] Remove `Night.Engine/runtimes` directory.
    - [x] Verify no `scripts` directory exists at root (remove if found and not in PRD).
    - [x] Create `lib/TASKS.md`.
    - **Verification:** Project structure matches `docs/PRD.md` Section 4 diagram. `.gitmodules` is updated.
- [x] **Task 1.1:** Initialize Git Repository & Solution Structure
    - [x] Initialize Git repository with a `.gitignore` file suitable for a .NET project.
    - [x] Create the `Night.sln` solution file.
    - [x] Create the main folder structure: `/docs`, `/scripts`, `/Night.Engine`, `/Night.SampleGame` as per PRD Section 4.
    - [x] Add initial `PRD.md` and a placeholder `TASKS.md` to `/docs`.
    - [x] Add a basic `README.md` to the project root.
    - **Verification:** Repository is cloneable, solution opens in IDE, folder structure matches PRD.

- [x] **Task 1.2.1:** Refactor `Platform` Build System and Workflow (Status: Review)
    - [x] Rename `FosterPlatform` to `Night.Platform` in [`src/Night.Platform/CMakeLists.txt`](src/Night.Platform/CMakeLists.txt:0) and update associated variables (e.g., `FOSTER_LIB_NAME` to `NIGHT_LIB_NAME`).
    - [x] Rename `foster_platform.h` to `night_platform.h` and `foster_platform.c` to `night_platform.c`. Update include guards and internal references.
    - [x] Update [`src/Night.Platform/README.md`](src/Night.Platform/README.md:0) to reflect the new naming.
    - [x] Update [` .github/workflows/build-libs.yml`](.github/workflows/build-libs.yml:0) to use `NIGHT_OVERRIDE_TARGET` and reflect any other necessary changes due to renaming.
    - **Verification:** The `Platform` project builds successfully with the new names. The GitHub Actions workflow runs successfully, producing artifacts like `Night.Platform.dll`.

- [x] **Task 1.3:** Set up C# Projects (`Night.Engine` & `Night.SampleGame`) (Status: Review)
    - [x] Create `Night.Engine.csproj` as a .NET 9 C# class library.
    - [x] Configure it to use C# 13.
    - [x] Ensure it's set up to correctly include/load native binaries from the `/runtimes` folder for multiple platforms.
    - [x] Create `Night.SampleGame.csproj` as a .NET 9 C# console application.
    - [x] Configure it to use C# 13.
    - [x] Add a project reference to `Night.Engine`.
    - [x] Add basic placeholder C# files (`API.cs`, `Engine.cs` in `Night.Engine`; `Program.cs`, `Game.cs` in `Night.SampleGame`).
    - **Verification:** Both projects build successfully. `Night.SampleGame` can reference types from `Night.Engine`.

- [x] **Task 1.4:** Initial SDL3 P/Invoke Test (Status: Review)
    - [x] In `Night.Engine` or `Night.SampleGame`, add P/Invoke declarations for simple functions from `src/Night.Platform/` (e.g., for `SDL_Init`, `SDL_Quit`, `SDL_GetVersion` equivalents via `Night.Platform.dll`). (Implemented directly against SDL3.dll in `Program.cs`)
    - [x] Call these P/Invoke functions from `Night.SampleGame`'s `Program.cs`. (Implemented in `Program.cs`)
    - **Verification:** The P/Invoke call executes without errors (e.g., `DllNotFoundException`), and if applicable, returns expected data (like SDL version). SDL can be initialized and quit. (Checked 2025-05-24: `SDL3.dll` copying mechanism via `Night.Engine.csproj` for `win-x64` is correctly configured.)

- [x] **Task 1.4.1:** Setup Coding Standards Enforcement (Status: Review)
    - [x] Create and configure `.editorconfig` at the project root to align with the Google C# Style Guide (indentation, column limit, `using` directive order, placeholder for Roslyn Analyzers).
    - [x] Updated `.pre-commit-config.yaml` for C# project with `dotnet format` and other standard hooks.
    - [x] Ensure Roslyn Analyzers are active and *fully* configured via `.editorconfig` for style and quality checks.
    - **Verification:** Code formatting tools (`dotnet format`) apply styles consistent with `.editorconfig`. IDE shows warnings/errors based on analyzer settings. `.pre-commit` hooks run successfully.

- **Task 1.5:** Integrate `lib/SDL3-CS` Bindings into `Night.Engine` (Status: Review)
    - **Description:** Modify `Night.Engine` to use the C# bindings from `lib/SDL3-CS` for SDL3 interop, and update `Night.SampleGame` to use these new capabilities. This replaces any direct P/Invoke to `SDL3.dll` or reliance on `Night.Platform` for SDL3 functions.
    - **Sub-tasks:**
        - [x] Add a project reference from `src/Night.Engine/Night.Engine.csproj` to `lib/SDL3-CS/SDL3/SDL3.Core.csproj` (or `SDL3.Legacy.csproj` if .NET 8+ is not guaranteed for all targets, though PRD specifies .NET 9).
        - [x] Update `src/Night.Engine/API.cs` (or a new `NativeMethods.cs` / `SDL3Integration.cs` file) to expose necessary SDL3 functions (e.g., `Init`, `Quit`, `GetVersion`) using the `SDL3-CS` bindings.
        - [x] Remove any direct P/Invoke declarations for SDL3 functions from `src/Night.SampleGame/Program.cs` or other files if they were using `Night.Platform.dll` or `SDL3.dll` directly for these.
        - [x] Update `src/Night.SampleGame/Program.cs` to call the SDL3 functions exposed by `Night.Engine` (which now use `SDL3-CS`).
    - **Verification:** `Night.Engine` and `Night.SampleGame` build successfully. `Night.SampleGame` can initialize and quit SDL, and retrieve version information using the `SDL3-CS` bindings via `Night.Engine`. No direct P/Invokes to `SDL3.dll` (for functions now covered by `Night.Engine`) remain in `Night.SampleGame`.

- **Task 1.6:** Remove `Night.Platform` (Status: In-Progress)
    - **Description:** Remove the `src/Night.Platform` directory and all references to it, as its functionality (primarily SDL3 building and basic interop) is now superseded by `lib/SDL3-CS` and pre-built SDL3 binaries.
    - **Sub-tasks:**
        - [ ] Delete the `src/Night.Platform` directory.
        - [ ] Update or remove ` .github/workflows/build-libs.yml` to eliminate `Night.Platform` build steps.
        - [ ] Remove any references to `Night.Platform` or its output libraries (e.g., `NightPlatform.dll`, `libNightPlatform.so`) from `.csproj` files, `Night.sln`, or other build/configuration files.
        - [ ] Verify that `Night.Engine` and `Night.SampleGame` still build and run correctly using `lib/SDL3-CS` for all SDL3 interactions.
    - **Verification:** The `src/Night.Platform` directory is gone. The project builds and runs without errors. The GitHub Actions workflow, if modified, completes successfully without trying to build `Night.Platform`.



================================================
File: docs/epics/epic2.md
================================================
# Epic 2: Core Engine API - Foundations (Leveraging SDL3-CS)

[ ] **Task 2.1:** Define Core `Night` API Data Structures

- [ ] Create C# enums, structs, or classes for the data types exposed by the `Night` API (e.g., `Night.Color`, `Night.Rectangle`, `Night.Key`, `Night.WindowFlags`, a basic `Night.Sprite` class). These will be part of `Night.Engine`'s public interface.
- [ ] For each `Night` data structure, determine if it will directly wrap or map to/from corresponding C# structs/enums provided by SDL3-CS (e.g., SDL3-CS might provide `SDL_Rect`, `SDL_Color`, `SDL_Keycode`, etc.) or if it's a purely `Night`-level concept.

[ ] **Task 2.2:** Integrate and Verify SDL3-CS Bindings

- [ ] Add the SDL3-CS library to the `Night.Engine` project. This might involve:
    - Adding it as a NuGet package if it's published as one.
    - Including its source code or project as a submodule or directly in your solution if preferred/necessary.
- [ ] Review the specific SDL3-CS generated files (e.g., `SDL3.Core.cs` or `SDL3.Legacy.cs` based on your .NET target) to understand the available functions and data types.

[ ] **Task 2.3:** Stub out `Night` Public API Surface (`NightAPI.cs`, `Engine.cs`)

- [x] In `API.cs`, create the static classes `Night.Window`, `Night.Keyboard`, `Night.Mouse`, and `Night.Graphics`.
- [x] Add public method signatures (as stubs, initially throwing `NotImplementedException` or logging) for the API functions outlined in PRD Features 1, 2, and 3.
    - Example: `public static class Night.Window { public static void SetMode(int width, int height, WindowFlags flags) { throw new NotImplementedException(); /* Future: call SDL.SDL_CreateWindow via SDL3-CS */ } }`
- [x] In `Engine.cs`, create the `Night.Engine` class with a public `Run` method (stubbed).
- [x] Define placeholders for how the `Run` method will invoke the user's `Load()`, `Update()`, and `Draw()` methods.
- **Verification:** The stubbed public `Night` API is callable from `Night.SampleGame`. The structure aligns with the PRD. It's clear where SDL3-CS calls will be made in future implementation steps.



================================================
File: docs/epics/epic3.md
================================================
**Epic 3: Window Management Implementation**

**Goal:** Fully implement the `Night.Window` module's public API (as stubbed in Epic 2) for creating, configuring, and managing the application window, using the SDL3-CS bindings.

- [x] **Task 3.1:** Implement `Night.Window.SetMode(int width, int height, WindowFlags flags)` (Status: Done)
    - [x] Use SDL3-CS functions to create an SDL window (e.g., `SDL.SDL_CreateWindow()`).
        - [x] Ensure the window is created with the specified `width` and `height`.
        - [x] Map the `Night.WindowFlags` (e.g., for fullscreen, resizable, borderless) to the corresponding SDL window flags or subsequent SDL function calls (e.g., `SDL.SDL_SetWindowFullscreen()`, `SDL.SDL_SetWindowResizable()`).
    - [x] If a default renderer is conceptually tied to the window in your design (common for 2D), create an SDL renderer (e.g., `SDL.SDL_CreateRenderer()`) associated with the window.
        - [x] Store the SDL window handle (and renderer handle, if applicable) internally within a private static part of `Night.Window`.
    - [x] Handle any necessary SDL initialization for video subsystems (`SDL.SDL_InitSubSystem(SDL.SDL_INIT_VIDEO)`) if not already handled globally.
    - [x] **Verification:** Calling `Night.Window.SetMode()` from `Night.SampleGame` successfully creates and displays a window with the specified dimensions and properties (e.g., fullscreen, resizable). No SDL errors are reported.

- [x] **Task 3.2:** Implement `Night.Window.SetTitle(string title)` (Status: Review)
    - [x] Use the appropriate SDL3-CS function to set the window's title (e.g., `SDL.SDL_SetWindowTitle()`), using the stored window handle.
    - **Verification:** Calling `Night.Window.SetTitle()` from `Night.SampleGame` changes the title displayed in the window's title bar.

- [x] **Task 3.3:** Implement `Night.Window.IsOpen()` (Status: Review)
    - [x] This method's primary role is to control the game loop. For now, its state will likely be tied to whether a `Quit` event has been received (which will be handled more fully in Epic 6: Game Loop).
    - [x] Create an internal static boolean flag (e.g., `_isWindowOpen` or `_isRunning`, default to `false` until `SetMode` is called, then `true`). `IsOpen()` will return this flag's value. The game loop (Epic 6) will set this to `false` on a quit event.
    - **Verification:** The `Night.Window.IsOpen()` method can be called and returns `true` after a window is created, and its state can be conceptually altered (though full quit logic is later).

- [x] **Task 3.4:** Implement Basic Error Handling for Window Operations (Status: Review)
    - [x] For all SDL3-CS function calls made within `Night.Window` methods, check their return values for errors (e.g., null pointers for window/renderer handles, negative values for error codes).
    - [x] If an SDL error occurs, retrieve the error message (e.g., using `SDL.SDL_GetError()`).
    - [x] Log errors using a simple mechanism for the prototype (e.g., `Console.WriteLine($"Error in {methodName}: {SDL.SDL_GetError()}");`).
    - [x] Decide on an error strategy for the prototype (e.g., throw an exception, return a boolean success/failure from `Night` API methods).
    - **Verification:** Invalid operations (e.g., setting title on a non-existent window if possible, or SDL internal errors) are caught and reported via console logs. The application behaves predictably (e.g., doesn't crash silently if window creation fails).

---

**Not Epic 4: Game Loop Implementation** (Status: In-Progress)

**Goal:** Implement the core game loop structure as defined in Feature 4 of the PRD, enabling the execution of a game using the `Night.Engine.Run` method.

- [x] **Task 4.1:** Implement `Night.Engine.Run<TGame>`
    - [x] Create an instance of `TGame`.
    - [x] Call `game.Load()`.
    - [x] Implement the main game loop (e.g., `while (Night.Window.IsOpen())`).
        - [x] Process system events (placeholder for now, full event handling in later tasks).
        - [x] Call `game.Update(deltaTime)` (deltaTime calculation to be basic for now).
        - [x] Call `game.Draw()`.
        - [x] Call `Night.Graphics.Present()` (assuming this will be available from Graphics module).
    - [x] Implement basic cleanup when the loop exits.
    - [x] Remove the `NotImplementedException`.
    - **Verification:** Calling `Night.Engine.Run&lt;SampleGame.Game&gt;()` from `Night.SampleGame` initializes the game, runs a basic loop, and calls `Load`, `Update`, `Draw` methods on the `SampleGame.Game` instance. Console output indicates these methods are being called.
- [x] **Task 4.2:** Resolve SDL3 native library loading for cross-platform execution (Status: In-Progress)
    - [x] Ensure `SDL3.dylib` (macOS), `SDL3.dll` (Windows), and `libSDL3.so.0` (Linux) are correctly located or copied to the output directory for `Night.SampleGame` during build.
    - [x] Verify that `mise run game` executes successfully on macOS.
    - [x] Document the solution for ensuring cross-platform native library availability.
    - **Verification:** The `DllNotFoundException` for SDL3 is resolved, and the game starts without this error on the primary development platform (macOS).



================================================
File: docs/epics/epic4.md
================================================

**Epic 4: Input Handling Implementation**

**Goal:** Implement the `Night.Keyboard` and `Night.Mouse` modules for polling keyboard and mouse states, using the SDL3-CS bindings, to allow the game to respond to user input.

- [x] **Task 4.1:** Implement `Night.Keyboard.IsDown(KeyCode key)` (Status: Completed)
    - [x] Use SDL3-CS functions to get the current keyboard state (e.g., `SDL.SDL_GetKeyboardState(out int numkeys)` which returns a pointer to an array of key states).
    - [x] Define the `Night.KeyCode` enum if not already fully specified in Epic 2, ensuring it can be mapped to SDL's key representation (e.g., `SDL_Scancode` values). This mapping might involve looking up values in SDL3-CS's own enums (like `SDL_Scancode`).
    - [x] Implement the logic to check the state of the specified `Night.KeyCode` by looking up its corresponding SDL scancode in the state array returned by SDL.
    - **Verification:** Calling `Night.Keyboard.IsDown()` with various `Night.KeyCode` values correctly returns `true` when the respective keys are held down and `false` otherwise, as tested in `Night.SampleGame`.

- [x] **Task 4.2:** Implement `Night.Mouse.IsDown(MouseButton button)`
    - [x] Use SDL3-CS functions to get the current mouse button state (e.g., `SDL.SDL_GetMouseState(out float x, out float y)` which typically also returns the button mask).
    - [x] Define the `Night.MouseButton` enum (e.g., `Left`, `Middle`, `Right`, `X1`, `X2`) if not already fully specified in Epic 2.
    - [x] Map `Night.MouseButton` enum values to the SDL button masks (e.g., `SDL.SDL_BUTTON_LMASK`, `SDL.SDL_BUTTON_RMASK`).
    - [x] Implement the logic to check if the specified `Night.MouseButton` is currently pressed by checking the bitmask returned by the SDL mouse state function.
    - [x] **Verification:** Calling `Night.Mouse.IsDown()` with various `Night.MouseButton` values correctly returns `true` when the respective buttons are held down and `false` otherwise, as tested in `Night.SampleGame`.

- [x] **Task 4.3:** Implement `Night.Mouse.GetPosition()` (Status: Completed)
    - [x] Use an SDL3-CS function to get the current mouse cursor coordinates relative to the focused window (e.g., `SDL.SDL_GetMouseState(out float x, out float y)` usually provides coordinates relative to the current window, but verify this behavior with SDL3).
    - [x] Ensure the returned coordinates are cast or converted to `(int x, int y)` as per the `Night` API.
    - **Verification:** Calling `Night.Mouse.GetPosition()` returns the correct (x, y) integer coordinates of the mouse cursor within the game window boundaries.

- [x] **Task 4.4:** Define and Map `Night.KeyCode` and `Night.MouseButton` Enums (Status: Review)
    - [x] Research and define comprehensive `Night.KeyCode` and `Night.MouseButton` enums that align with common keyboard layouts and mouse buttons, and correspond to SDL3's `SDL_Scancode` and mouse button definitions provided by SDL3-CS.
    - [x] Create any necessary internal mapping functions or structures if a direct cast is not possible or if `Night` enums need to be more abstract than SDL's.
    - **Verification:** `Night.KeyCode` and `Night.MouseButton` enums are clearly defined and accurately map to the underlying SDL input system values.

- [x] **Task 4.5:** Basic Error Handling and State Management for Input (Status: Review)
    - [x] Ensure that input functions behave gracefully if called before SDL subsystems are fully initialized (e.g., return default/false values, log a warning). (Note: The main `Night.Framework.Run` should handle initialization order).
    - [x] Review SDL documentation for any specific error conditions or edge cases for the input functions being used.
    - **Verification:** Input functions do not cause crashes if queried at an inappropriate time (though this should be rare with a proper game loop) and provide default 'safe' return values.



================================================
File: docs/epics/epic5.md
================================================
**Epic 5: 2D Graphics & Rendering Implementation**

**Goal:** Implement the core functionalities of the `Night.Graphics` module, enabling the loading of images as sprites and rendering them to the window. This includes screen clearing and handling the presentation of the rendered frame, all utilizing SDL3-CS bindings.

- [ ] **Task 5.1:** Implement `Night.Graphics.NewImage(string filePath)`
    
    - [ ] Use SDL3-CS functions to load an image from a file path into an SDL Texture (e.g., `SDL.SDL_LoadTexture()` or an equivalent function provided by SDL3/SDL3-CS for common image formats like PNG, BMP). This will require an active SDL Renderer.
    - [ ] Refine the `Night.Sprite` class (defined conceptually in Epic 2) to store the SDL Texture handle, as well as its width and height (which can be queried from the texture, e.g., using `SDL.SDL_QueryTexture()`).
    - [ ] Implement error handling for file loading (e.g., file not found, unsupported image format, SDL errors) and log appropriately. Return `null` or throw an exception if loading fails.
    - **Verification:** Calling `Night.Graphics.NewImage()` with a path to a valid image file (e.g., a PNG) returns a `Night.Sprite` object. This object contains a non-null texture handle and correct width/height attributes. Attempting to load an invalid file results in a clear error message and no crash.
- [ ] **Task 5.2:** Implement `Night.Graphics.Draw(Sprite sprite, float x, float y, float rotation = 0, float scaleX = 1, float scaleY = 1, float offsetX = 0, float offsetY = 0)`
    
    - [ ] Use SDL3-CS functions to render the `SDL_Texture` associated with the `Night.Sprite` object (e.g., `SDL.SDL_RenderTexture()` or `SDL.SDL_RenderTextureRotated()`, or similar SDL3 equivalents that support rotation and scaling).
    - [ ] Define the source rectangle (to draw the whole texture) and destination rectangle (`SDL_FRect` for float precision) based on the sprite's dimensions and the `x, y` parameters.
    - [ ] Apply `rotation` (in degrees), `scaleX`, `scaleY`. The `offsetX` and `offsetY` parameters should define the origin point for these transformations (e.g., if (0,0), top-left; if (sprite.Width/2, sprite.Height/2), center).
    - [ ] Ensure the correct SDL Renderer (obtained during window creation) is used for drawing.
    - **Verification:** Calling `Night.Graphics.Draw()` renders the specified `Night.Sprite` at the correct screen position, with the specified rotation and scale applied accurately. The origin of transformation (`offsetX`, `offsetY`) works as expected.
- [ ] **Task 5.3:** Implement `Night.Graphics.Clear(Color color)`
    
    - [ ] Map the `Night.Color` struct (R, G, B, A byte values) to the format required by SDL.
    - [ ] Use SDL3-CS functions to set the renderer's current drawing color (e.g., `SDL.SDL_SetRenderDrawColor()`).
    - [ ] Use SDL3-CS functions to clear the entire rendering target with the set color (e.g., `SDL.SDL_RenderClear()`).
    - **Verification:** Calling `Night.Graphics.Clear()` fills the game window with the specified `Night.Color`.
- [ ] **Task 5.4:** Conceptualize `Night.Graphics.Present()` (Actual call in Game Loop)
    
    - [ ] The `Night.Graphics.Present()` method, if called directly by the user, will likely be a conceptual placeholder in this module. The actual call to SDL's frame presentation function (e.g., `SDL.SDL_RenderPresent()`) will be managed by the `Night.Engine`'s main loop (Epic 6) after all `Draw()` calls are complete for a frame.
    - [ ] For now, this method in `Night.Graphics` can be empty or log a debug message indicating it's a placeholder for the engine's render presentation step.
    - **Verification:** The method `Night.Graphics.Present()` exists and can be called without error. (Full visual verification of frame presentation is part of Epic 6).
- [ ] **Task 5.5:** Renderer Initialization and Management
    
    - [ ] Confirm that the SDL Renderer instance is properly created (typically alongside the SDL Window in Epic 3, e.g., via `SDL.SDL_CreateRenderer()`) and stored internally where `Night.Graphics` methods can access it.
    - [ ] Ensure renderer flags are appropriately set during creation (e.g., for hardware acceleration, vsync if desired by default for the prototype).
    - [ ] Implement logic for destroying the SDL Renderer when the window is closed or the application quits (e.g., `SDL.SDL_DestroyRenderer()`).
    - **Verification:** Graphics operations use a valid, initialized SDL Renderer. The renderer is cleanly destroyed on application exit.
- [ ] **Task 5.6:** Basic Error Handling for Graphics Operations
    
    - [ ] For all relevant SDL3-CS graphics function calls, check return values for errors.
    - [ ] Retrieve and log specific SDL error messages (e.g., using `SDL.SDL_GetError()`) via `Console.WriteLine` or a similar simple logging mechanism for the prototype.
    - **Verification:** Errors during graphics operations (e.g., texture loading failure, issues during rendering calls) are reported with meaningful messages. The application does not crash silently due to graphics errors.



================================================
File: docs/epics/epic6.md
================================================
**Epic 6: Game Loop Implementation**

**Goal:** Implement the `Night.Engine` class to manage the main game loop. This includes initializing and shutting down SDL, polling for events (especially quit events), calling the user-defined `Load`, `Update`, and `Draw` methods in the correct sequence, managing frame timing (delta time), and handling screen presentation.

- [ ] **Task 6.1:** Implement Core `Night.Engine.Run(IGameLogic gameLogic)` Structure
    
    - [ ] Define an interface (e.g., `Night.IGameLogic`) that user game classes will implement, specifying methods like `Load()`, `Update(double deltaTime)`, `Draw()`, and optional input event handlers like `KeyPressed(KeyCode key, bool isRepeat)` etc., if this event-based approach is chosen for Feature 4.
    - [ ] Implement the main `Night.Engine.Run(IGameLogic gameLogic)` method.
    - [ ] **Initialization:**
        - [ ] Inside `Run`, before the loop, call `SDL.SDL_Init(SDL.SDL_INIT_VIDEO | ...other_subsystems_if_needed...)` using SDL3-CS. Log errors if initialization fails.
        - [ ] Call the provided `gameLogic.Load()` method once after successful SDL initialization.
    - [ ] **Main Loop:**
        - [ ] Implement the primary game loop (e.g., `while (Night.Window.IsOpen()) { ... }`). The `Night.Window.IsOpen()` flag (from Epic 3) will be controlled by quit events.
    - [ ] **Shutdown:**
        - [ ] After the loop terminates, call appropriate SDL cleanup functions (e.g., destroy window, destroy renderer if not handled elsewhere, `SDL.SDL_QuitSubSystem(...)`, `SDL.SDL_Quit()`).
    - **Verification:** Calling `Night.Engine.Run()` with a simple `IGameLogic` implementation initializes SDL, calls `Load()`, enters a loop, and then quits SDL. The `Night.SampleGame` can be launched using this.
- [ ] **Task 6.2:** Implement Event Polling within the Game Loop
    
    - [ ] Inside the main loop, use SDL3-CS functions to poll for SDL events (e.g., `while (SDL.SDL_PollEvent(out SDL_Event ev) != 0) { ... }`).
    - [ ] Handle `SDL_EVENT_QUIT`: If this event is received, set the internal flag that `Night.Window.IsOpen()` checks to `false` to terminate the game loop.
    - [ ] (Optional for initial prototype, can be basic) If pursuing event-based input handlers from Feature 4:
        - [ ] Based on `ev.type`, dispatch to relevant `gameLogic` methods (e.g., `gameLogic.KeyPressed(ev.key.keysym.sym, ...)`). This requires mapping SDL event data to `Night` API parameters.
    - **Verification:** The game loop correctly polls for events. The application closes cleanly when the window's close button is clicked (which generates an `SDL_EVENT_QUIT`). If basic event handlers are implemented, they are triggered.
- [ ] **Task 6.3:** Implement Delta Time Calculation and Pass to `Update`
    
    - [ ] Before the main loop, get initial timing values using SDL3-CS timing functions (e.g., `SDL.SDL_GetPerformanceCounter()` and `SDL.SDL_GetPerformanceFrequency()` for high-resolution timing, or `SDL.SDL_GetTicks()` for millisecond-based timing).
    - [ ] At the beginning of each loop iteration (or end), calculate the time elapsed since the last frame (`deltaTime`) in seconds (e.g., as a `double` or `float`).
    - [ ] Call `gameLogic.Update(deltaTime)` method, passing the calculated delta time.
    - **Verification:** The `gameLogic.Update()` method is called each frame and receives a `deltaTime` value that reasonably reflects the actual time elapsed per frame. Frame rate can be roughly monitored (e.g., by logging FPS) for stability.
- [ ] **Task 6.4:** Integrate `gameLogic.Draw()` and Screen Presentation
    
    - [ ] Inside the main loop, after `gameLogic.Update(deltaTime)`, call `gameLogic.Draw()`.
    - [ ] Immediately after `gameLogic.Draw()` completes, call the SDL function to present the renderer's back buffer to the window (e.g., `SDL.SDL_RenderPresent(rendererHandle)` using the renderer handle established in Epic 3/5).
    - **Verification:** The `gameLogic.Draw()` method is called each frame. Graphics drawn within this method (using `Night.Graphics` calls) are visible on the screen and update frame by frame.
- [ ] **Task 6.5:** Basic Game Loop Error Handling and Robustness
    
    - [ ] Wrap calls to user-provided `gameLogic` methods (`Load`, `Update`, `Draw`, event handlers) in `try-catch` blocks.
    - [ ] If an exception occurs in user code, log the exception (e.g., `Console.WriteLine`) and decide on a strategy:
        - For prototype: an unhandled exception in user code might gracefully terminate the engine loop and ensure SDL is shut down.
    - [ ] Ensure SDL initialization and shutdown are robust (e.g., `SDL_Quit` is always called even if `Load` throws an error).
    - **Verification:** Unhandled exceptions within the `gameLogic` methods are caught by the `Night.Engine`, an error is logged, and the engine attempts to shut down SDL and exit cleanly rather than crashing without context.



================================================
File: docs/epics/epic7.md
================================================

**Epic 7: Sample Game & Integration Testing**

**Goal:** Develop a simple platformer game using the "Night Engine." This sample game will serve as a comprehensive integration test, verifying that all core engine features (Window, Input, Graphics, Game Loop) function correctly and cohesively as defined in the PRD.

- [ ] **Task 7.1:** Design Basic Platformer Game Mechanics for `Night.SampleGame`
    
    - [ ] Define the player character: appearance (e.g., a simple colored rectangle or a basic sprite), size.
    - [ ] Define player actions: move left, move right, jump.
    - [ ] Define basic level elements: static platforms (rectangles) for the player to stand on and jump between.
    - [ ] Define a simple objective or success state for the prototype (e.g., navigate to a specific point, or simply demonstrate stable movement and interaction).
    - **Verification:** A minimal design document or sketch outlining the platformer's mechanics, player abilities, and level structure is created.
- [ ] **Task 7.2:** Implement Player Character in `Night.SampleGame`
    
    - [ ] Create a `Player` class within the `Night.SampleGame` project.
    - [ ] **Loading:** In a `Player.Load()` method (or equivalent called from `Game.Load()`), if using a sprite, load it using `Night.Graphics.NewImage()`. Initialize player position, size, and movement properties (e.g., speed, jump height, gravity).
    - [ ] **Updating:** In a `Player.Update(double deltaTime)` method:
        - [ ] Handle horizontal movement input using `Night.Keyboard.IsDown(Night.KeyCode.Left)` and `Night.Keyboard.IsDown(Night.KeyCode.Right)`.
        - [ ] Implement jump logic (e.g., on `Night.Keyboard.IsDown(Night.KeyCode.Space)`), applying an upward velocity.
        - [ ] Apply basic gravity to the player's vertical velocity.
        - [ ] Update player position based on velocity and `deltaTime`.
    - [ ] **Drawing:** In a `Player.Draw()` method, render the player (rectangle or sprite) at its current position using `Night.Graphics.Draw()`.
    - **Verification:** The player character is displayed on the screen. It responds to left/right arrow key presses by moving horizontally. Pressing the jump key makes the player move upwards and then fall due to gravity.
- [ ] **Task 7.3:** Implement Basic Level (Platforms) in `Night.SampleGame`
    
    - [ ] Define platform data (e.g., an array or list of `Night.Rectangle` structs for position and size).
    - [ ] In `Game.Load()` or a `Level.Load()` method, initialize these platforms.
    - [ ] In `Game.Update()` or `Player.Update()`, implement simple Axis-Aligned Bounding Box (AABB) collision detection between the player and the platforms.
        - [ ] Resolve collisions by preventing the player from passing through platforms (e.g., stop downward movement when landing on top of a platform, block horizontal movement into the side of a platform).
    - [ ] In `Game.Draw()` or a `Level.Draw()` method, render the platforms (e.g., as filled rectangles using a conceptual `Night.Graphics.DrawRectangle()` if added, or by drawing placeholder sprites for each). _Self-correction: The PRD doesn't specify `DrawRectangle`. For the prototype, platforms can be represented by loaded sprites or this might highlight a small graphics primitive need for the sample._
    - **Verification:** Platforms are rendered on the screen. The player character can land on top of platforms and is appropriately stopped by them. The player does not fall through platforms.
- [ ] **Task 7.4:** Implement Main Game Logic in `Game.cs` (integrating `IGameLogic`)
    
    - [ ] Ensure `Night.SampleGame.Game` class properly implements the `Night.IGameLogic` interface (from Epic 6).
    - [ ] **`Game.Load()`:** Initialize the player object, platform data/level objects, and load any other necessary assets.
    - [ ] **`Game.Update(double deltaTime)`:** Call the `Player.Update(deltaTime)` method. Update any other game state logic (e.g., checking simple win/lose conditions if designed).
    - [ ] **`Game.Draw()`:**
        - [ ] Call `Night.Graphics.Clear(backgroundColor)` at the beginning.
        - [ ] Call draw methods for platforms and the player, ensuring correct layering if relevant.
    - **Verification:** The `Night.SampleGame` runs via `Night.Engine.Run(new Game())`. All game elements (player, platforms) are initialized, updated, and drawn correctly each frame, demonstrating the integrated use of `Night.Window`, `Night.Input`, `Night.Graphics`, and the `Night.Engine` game loop.
- [ ] **Task 7.5:** End-to-End Feature Verification & Bug Fixing
    
    - [ ] Play through the `Night.SampleGame` platformer, systematically testing all implemented `Night` engine features:
        - Window creation and title (`Night.Window`).
        - Keyboard input for player control (`Night.Keyboard`).
        - Mouse input for position checking, if used for any debug (`Night.Mouse`).
        - Sprite loading and rendering for player/platforms (`Night.Graphics`).
        - Screen clearing (`Night.Graphics`).
        - Game loop operation, delta time, and event handling (`Night.Engine`).
    - [ ] Compare observed behavior against the feature descriptions in the PRD.
    - [ ] Document any bugs, unexpected behaviors, or deviations from the PRD.
    - [ ] Iterate on bug fixes within the `Night.Engine` or `Night.SampleGame` code until the prototype functions as intended for the defined features.
    - **Verification:** The sample platformer game is playable and all core `Night` engine features (PRD Features 1-4) are demonstrably working as expected. Any significant bugs identified during testing have been addressed.
    


================================================
File: docs/love2d-api/audio.md
================================================
# `love.audio` Module API Mapping

This document maps the functions available in the `love.audio` module of Love2D to their proposed equivalents in the Night Engine. This entire module is **Out of Scope** for the initial prototype.

| Love2D Function (`love.audio.`) | Night Engine API (`Night.Audio.`) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|---------------------------------|-----------------------------------|---------------------------|--------------------------|------|
| `love.audio.getActiveSourceCount()` | `Night.Audio.GetActiveSourceCount()` | `public static int GetActiveSourceCount()` | Out of Scope | [ ] |
| `love.audio.getDistanceModel()` | `Night.Audio.GetDistanceModel()`  | `public static Night.DistanceModel GetDistanceModel()` <br> `DistanceModel` enum. | Out of Scope | [ ] |
| `love.audio.getDopplerScale()`  | `Night.Audio.GetDopplerScale()`   | `public static double GetDopplerScale()` | Out of Scope | [ ] |
| `love.audio.getEffect(name)`    | `Night.Audio.GetEffect(string name)` | `public static Night.AudioEffect? GetEffect(string name)` <br> `AudioEffect` would be a base class for effects. | Out of Scope | [ ] |
| `love.audio.getOrientation()`   | `Night.Audio.GetListenerOrientation()` | `public static (float fx, float fy, float fz, float ux, float uy, float uz) GetListenerOrientation()` | Out of Scope | [ ] |
| `love.audio.getPosition()`      | `Night.Audio.GetListenerPosition()` | `public static (float x, float y, float z) GetListenerPosition()` | Out of Scope | [ ] |
| `love.audio.getRecordingDevices()` | `Night.Audio.GetRecordingDevices()` | `public static Night.RecordingDevice[] GetRecordingDevices()` | Out of Scope | [ ] |
| `love.audio.getSourceCount()`   | `Night.Audio.GetTotalSourceCount()` | `public static int GetTotalSourceCount()` | Out of Scope | [ ] |
| `love.audio.getVelocity()`      | `Night.Audio.GetListenerVelocity()` | `public static (float x, float y, float z) GetListenerVelocity()` | Out of Scope | [ ] |
| `love.audio.getVolume()`        | `Night.Audio.GetMasterVolume()`   | `public static float GetMasterVolume()` | Out of Scope | [ ] |
| `love.audio.isEffectsSupported()` | `Night.Audio.IsEffectsSupported()` | `public static bool IsEffectsSupported()` | Out of Scope | [ ] |
| `love.audio.newSource(filename, type)` or `love.audio.newSource(decoder, type)` | `Night.Audio.NewSource(string filePath, Night.SourceType type = Static)` or `Night.Audio.NewSource(Night.Decoder decoder, Night.SourceType type = Stream)` | `public static Night.Source NewSource(...)` <br> `SourceType` enum: `Static`, `Stream`. `Decoder` for custom audio formats. | Out of Scope | [ ] |
| `love.audio.pause(source)` or `love.audio.pause()` | `Night.Audio.Pause(Night.Source? source = null)` | `public static void Pause(Night.Source? source = null)` <br> Pauses specific source or all. | Out of Scope | [ ] |
| `love.audio.play(source)`       | `Night.Audio.Play(Night.Source source)` | `public static void Play(Night.Source source)` | Out of Scope | [ ] |
| `love.audio.resume(source)` or `love.audio.resume()` | `Night.Audio.Resume(Night.Source? source = null)` | `public static void Resume(Night.Source? source = null)` | Out of Scope | [ ] |
| `love.audio.setDistanceModel(model)` | `Night.Audio.SetDistanceModel(Night.DistanceModel model)` | `public static void SetDistanceModel(Night.DistanceModel model)` | Out of Scope | [ ] |
| `love.audio.setDopplerScale(scale)` | `Night.Audio.SetDopplerScale(double scale)` | `public static void SetDopplerScale(double scale)` | Out of Scope | [ ] |
| `love.audio.setEffect(name, settings)` | `Night.Audio.SetEffect(string name, Night.AudioEffectSettings settings)` | `public static bool SetEffect(string name, Night.AudioEffectSettings settings)` | Out of Scope | [ ] |
| `love.audio.setMixWithSystem(mix)` | `Night.Audio.SetMixWithSystem(bool mix)` | `public static void SetMixWithSystem(bool mix)` | Out of Scope | [ ] |
| `love.audio.setOrientation(fx, fy, fz, ux, uy, uz)` | `Night.Audio.SetListenerOrientation(...)` | `public static void SetListenerOrientation(float forwardX, ...)` | Out of Scope | [ ] |
| `love.audio.setPosition(x, y, z)` | `Night.Audio.SetListenerPosition(float x, float y, float z)` | `public static void SetListenerPosition(float x, float y, float z)` | Out of Scope | [ ] |
| `love.audio.setRecordingDevice(name)` | `Night.Audio.SetRecordingDevice(string name)` | `public static void SetRecordingDevice(string name)` | Out of Scope | [ ] |
| `love.audio.setVelocity(x, y, z)` | `Night.Audio.SetListenerVelocity(float x, float y, float z)` | `public static void SetListenerVelocity(float x, float y, float z)` | Out of Scope | [ ] |
| `love.audio.setVolume(volume)`  | `Night.Audio.SetMasterVolume(float volume)` | `public static void SetMasterVolume(float volume)` | Out of Scope | [ ] |
| `love.audio.stop(source)` or `love.audio.stop()` | `Night.Audio.Stop(Night.Source? source = null)` | `public static void Stop(Night.Source? source = null)` | Out of Scope | [ ] |

**Night Engine Specific Types:**
*   `Night.Source`: Represents an audio source (sound effect or music). Would have methods like `Play()`, `Pause()`, `Stop()`, `SetVolume()`, `Seek()`, `IsPlaying()`, etc.
*   `Night.SourceType`: Enum (`Static`, `Stream`).
*   `Night.Decoder`: Represents a custom audio decoder.
*   `Night.DistanceModel`: Enum for 3D audio distance attenuation (e.g., `None`, `Inverse`, `Linear`).
*   `Night.AudioEffect`: Base class for audio effects (e.g., reverb, echo).
*   `Night.AudioEffectSettings`: Base class for effect-specific settings.
*   `Night.RecordingDevice`: Represents an audio recording device.



================================================
File: docs/love2d-api/data.md
================================================
# `love.data` Module API Mapping

This document maps the functions available in the `love.data` module of Love2D to their proposed equivalents in the Night Engine. This entire module is **Out of Scope** for the initial prototype. .NET provides extensive built-in support for these operations in namespaces like `System.IO.Compression`, `System.Security.Cryptography`, and `System.Text`.

| Love2D Function (`love.data.`) | Night Engine API (`Night.Data` or `System` namespaces) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|--------------------------------|--------------------------------------------------------|---------------------------|--------------------------|------|
| `love.data.compress(container, format, rawstring, level)` | `Night.Data.Compress(Night.DataContainerType container, Night.CompressionFormat format, byte[] data, int? level = null)` | `public static byte[] Compress(...)` <br> Uses `System.IO.Compression`. | Out of Scope | [ ] |
| `love.data.decompress(container, format, compressedstring)` | `Night.Data.Decompress(Night.DataContainerType container, Night.CompressionFormat format, byte[] compressedData)` | `public static byte[] Decompress(...)` | Out of Scope | [ ] |
| `love.data.decode(container, format, encodedstring)` | `Night.Data.Decode(Night.DataContainerType container, Night.EncodingFormat format, string encodedString)` | `public static byte[] Decode(...)` <br> e.g., Base64, Hex. Uses `System.Convert`. | Out of Scope | [ ] |
| `love.data.encode(container, format, rawstring, linelength)` | `Night.Data.Encode(Night.DataContainerType container, Night.EncodingFormat format, byte[] data, int? lineLength = null)` | `public static string Encode(...)` | Out of Scope | [ ] |
| `love.data.getPackedSize(format)` | `Night.Data.GetPackedSize(string packFormat)` | `public static int GetPackedSize(string packFormat)` <br> For binary packing. | Out of Scope | [ ] |
| `love.data.hash(hashfunction, string_or_Data)` | `Night.Data.Hash(Night.HashFunction function, byte[] data)` or `Night.Data.Hash(Night.HashFunction function, string data)` | `public static string Hash(...)` <br> Uses `System.Security.Cryptography`. | Out of Scope | [ ] |
| `love.data.newDataView(data, offset, size)` | `Night.Data.NewDataView(byte[] data, int offset = 0, int? size = null)` | `public static Night.DataView NewDataView(...)` <br> Similar to `System.Memory<byte>` or `ArraySegment<byte>`. | Out of Scope | [ ] |
| `love.data.pack(format, values...)` | `Night.Data.Pack(string packFormat, params object[] values)` | `public static byte[] Pack(...)` <br> Binary packing. | Out of Scope | [ ] |
| `love.data.unpack(format, datastring)` | `Night.Data.Unpack(string packFormat, byte[] packedData)` | `public static object[] Unpack(...)` | Out of Scope | [ ] |

**Night Engine Specific Types (if module were implemented):**
*   `Night.DataContainerType`: Enum (e.g., `String`, `Data`). (Love2D distinction, less relevant for C# byte arrays).
*   `Night.CompressionFormat`: Enum (e.g., `Gzip`, `Zlib`, `Lz4`).
*   `Night.EncodingFormat`: Enum (e.g., `Base64`, `Hex`).
*   `Night.HashFunction`: Enum (e.g., `Md5`, `Sha1`, `Sha256`).
*   `Night.DataView`: Wrapper for a segment of byte array, similar to `System.Memory<byte>`.



================================================
File: docs/love2d-api/event.md
================================================
# `love.event` Module API Mapping

This document maps the functions available in the `love.event` module of Love2D to their proposed equivalents in the Night Engine. In Night Engine, event handling is primarily managed by the engine invoking specific callback methods on the user's game class (e.g., `MyGame.KeyPressed`). Direct manipulation of an event queue by the user is **Out of Scope** for the initial prototype.

| Love2D Function (`love.event.`) | Night Engine API (`Night.Event` or Engine Internals) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|---------------------------------|------------------------------------------------------|---------------------------|--------------------------|------|
| `love.event.clear()`            | `Night.Event.ClearQueue()` (Engine internal or not exposed) | `internal static void ClearQueue()` <br> Clears pending events. Engine might do this per frame. | Out of Scope | [ ] |
| `love.event.poll()`             | `Night.Event.Poll()` (Engine internal) | `internal static Night.EventData? Poll()` <br> Returns next event if any. Engine uses this in its loop. | Out of Scope | [ ] |
| `love.event.pump()`             | `Night.Event.PumpEvents()` (Engine internal) | `internal static void PumpEvents()` <br> Processes OS events into LÖVE events. Engine does this. | Out of Scope | [ ] |
| `love.event.push(e, ...)`       | `Night.Event.PushCustomEvent(string eventName, params object[] args)` | `public static void PushCustomEvent(string eventName, params object[] args)` <br> Allows user to push custom events. Would require a `MyGame.CustomEvent(name, args)` callback. | Out of Scope | [ ] |
| `love.event.quit(exitstatus)`   | `Night.Engine.RequestQuit(int exitStatus = 0)` | `public static void RequestQuit(int exitStatus = 0)` <br> Pushes a quit event. | In Scope (as `Night.Engine.RequestQuit`) | [ ] |
| `love.event.wait()`             | `Night.Event.Wait()` (Engine internal or not exposed) | `internal static Night.EventData Wait()` <br> Waits for next event. Not typical for game loops. | Out of Scope | [ ] |

**Night Engine Specific Types (if module were implemented for custom events):**
*   `Night.EventData`: A base class or struct for event information, potentially with derived types for specific events if not handled by direct callbacks.
*   Custom event callbacks in `MyGame` like `MyGame.OnCustomEvent(string name, object[] args)`.



================================================
File: docs/love2d-api/filesystem.md
================================================
# `love.filesystem` Module API Mapping

This document maps the functions available in the `love.filesystem` module of Love2D to their proposed equivalents in the Night Engine. Most functions in this module are **Out of Scope** for the initial prototype.

| Love2D Function (`love.filesystem.`) | Night Engine API (`Night.Filesystem.`) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|--------------------------------------|----------------------------------------|---------------------------|--------------------------|------|
| `love.filesystem.append(name, data, size)` | `Night.Filesystem.Append(string path, byte[] data, int? size = null)` or `Night.Filesystem.AppendText(string path, string content)` | `public static bool Append(string path, byte[] data, int? size = null)` <br> `public static bool AppendText(string path, string content)` | Out of Scope | [ ] |
| `love.filesystem.areSymlinksEnabled()` | `Night.Filesystem.AreSymlinksEnabled()` | `public static bool AreSymlinksEnabled()` | Out of Scope | [ ] |
| `love.filesystem.createDirectory(name)` | `Night.Filesystem.CreateDirectory(string path)` | `public static bool CreateDirectory(string path)` | Out of Scope | [ ] |
| `love.filesystem.getAppdataDirectory()` | `Night.Filesystem.GetAppDataDirectory()` | `public static string GetAppDataDirectory()` | Out of Scope | [ ] |
| `love.filesystem.getDirectoryItems(name)` | `Night.Filesystem.GetDirectoryItems(string path)` | `public static string[] GetDirectoryItems(string path)` | Out of Scope | [ ] |
| `love.filesystem.getExecutablePath()` | `Night.Filesystem.GetExecutablePath()` | `public static string GetExecutablePath()` | Out of Scope | [ ] |
| `love.filesystem.getIdentity()`     | `Night.Filesystem.GetIdentity()`   | `public static string GetIdentity()` <br> Gets the save directory identity. | Out of Scope | [ ] |
| `love.filesystem.getLastModified(name)` | `Night.Filesystem.GetLastModifiedTime(string path)` | `public static DateTime GetLastModifiedTime(string path)` (or long timestamp) | Out of Scope | [ ] |
| `love.filesystem.getRealDirectory(name)` | `Night.Filesystem.GetRealDirectory(string path)` | `public static string GetRealDirectory(string path)` <br> Resolves symlinks. | Out of Scope | [ ] |
| `love.filesystem.getSaveDirectory()` | `Night.Filesystem.GetSaveDirectory()` | `public static string GetSaveDirectory()` | Out of Scope | [ ] |
| `love.filesystem.getSize(name)`     | `Night.Filesystem.GetFileSize(string path)` | `public static long GetFileSize(string path)` | Out of Scope | [ ] |
| `love.filesystem.getSource()`       | `Night.Filesystem.GetSourcePath()` | `public static string GetSourcePath()` <br> Path to the game's source (.love file or directory). | Out of Scope | [ ] |
| `love.filesystem.getSourceBaseDirectory()` | `Night.Filesystem.GetSourceBaseDirectory()` | `public static string GetSourceBaseDirectory()` | Out of Scope | [ ] |
| `love.filesystem.getUserDirectory()` | `Night.Filesystem.GetUserDirectory()` | `public static string GetUserDirectory()` | Out of Scope | [ ] |
| `love.filesystem.getWorkingDirectory()` | `Night.Filesystem.GetWorkingDirectory()` | `public static string GetWorkingDirectory()` | Out of Scope | [ ] |
| `love.filesystem.isFused()`         | `Night.Filesystem.IsFused()`       | `public static bool IsFused()` <br> True if game is a .love file and merged with interpreter. | Out of Scope | [ ] |
| `love.filesystem.isDirectory(name)` | `Night.Filesystem.IsDirectory(string path)` | `public static bool IsDirectory(string path)` | Out of Scope | [ ] |
| `love.filesystem.isFile(name)`      | `Night.Filesystem.IsFile(string path)` | `public static bool IsFile(string path)` | Out of Scope | [ ] |
| `love.filesystem.isSymlink(name)`   | `Night.Filesystem.IsSymlink(string path)` | `public static bool IsSymlink(string path)` | Out of Scope | [ ] |
| `love.filesystem.lines(name)`       | `Night.Filesystem.ReadLines(string path)` | `public static IEnumerable<string> ReadLines(string path)` | Out of Scope | [ ] |
| `love.filesystem.load(name)`        | `Night.Filesystem.LoadLuaScript(string path)` | `public static Action LoadLuaScript(string path)` <br> Loads and runs a Lua file. Night Engine might not support this directly. | Out of Scope | [ ] |
| `love.filesystem.mount(archive, mountpoint, appendToPath)` | `Night.Filesystem.Mount(string archivePath, string mountPoint, bool appendToSearchPath = false)` | `public static bool Mount(...)` | Out of Scope | [ ] |
| `love.filesystem.newFile(filename, mode)` | `Night.Filesystem.NewFileStream(string path, Night.FileMode mode = Read)` | `public static Night.FileStream NewFileStream(...)` <br> `FileMode` enum: `Read`, `Write`, `Append`. `FileStream` would be a custom stream wrapper. | Out of Scope | [ ] |
| `love.filesystem.newFileData(contents, name, decoder)` | `Night.Filesystem.NewFileData(byte[] content, string name, Night.FileDecoder decoder = Raw)` | `public static Night.FileData NewFileData(...)` <br> `FileDecoder` enum: `Raw`, `Base64`. `FileData` is an in-memory file. | Out of Scope | [ ] |
| `love.filesystem.read(name, size)`  | `Night.Filesystem.ReadBytes(string path, int? count = null)` or `Night.Filesystem.ReadText(string path)` | `public static byte[]? ReadBytes(string path, int? count = null)` <br> `public static string? ReadText(string path)` | Out of Scope | [ ] |
| `love.filesystem.remove(name)`      | `Night.Filesystem.Remove(string path)` | `public static bool Remove(string path)` <br> Removes file or empty directory. | Out of Scope | [ ] |
| `love.filesystem.setIdentity(name, appendToPath)` | `Night.Filesystem.SetIdentity(string identity, bool appendToPath = false)` | `public static void SetIdentity(...)` | Out of Scope | [ ] |
| `love.filesystem.setSymlinksEnabled(enable)` | `Night.Filesystem.SetSymlinksEnabled(bool enable)` | `public static void SetSymlinksEnabled(bool enable)` | Out of Scope | [ ] |
| `love.filesystem.setSource(path)`   | `Night.Filesystem.SetSource(string path)` | `public static void SetSource(string path)` | Out of Scope | [ ] |
| `love.filesystem.unmount(archive)`  | `Night.Filesystem.Unmount(string archivePath)` | `public static bool Unmount(string archivePath)` | Out of Scope | [ ] |
| `love.filesystem.write(name, data, size)` | `Night.Filesystem.WriteBytes(string path, byte[] data, int? size = null)` or `Night.Filesystem.WriteText(string path, string content)` | `public static bool WriteBytes(...)` <br> `public static bool WriteText(...)` | Out of Scope | [ ] |

**Night Engine Specific Types:**
*   `Night.FileMode`: Enum (`Read`, `Write`, `Append`).
*   `Night.FileStream`: Custom stream wrapper for file operations.
*   `Night.FileData`: Represents an in-memory file.
*   `Night.FileDecoder`: Enum (`Raw`, `Base64`).



================================================
File: docs/love2d-api/font.md
================================================
# `love.font` Module API Mapping

This document maps the functions available in the `love.font` module of Love2D to their proposed equivalents in the Night Engine. This entire module is **Out of Scope** for the initial prototype. The primary way to get a font object in Night Engine would be `Night.Graphics.NewFont()`.

| Love2D Function (`love.font.`) | Night Engine API (`Night.Font` methods or `Night.Graphics`) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|--------------------------------|-------------------------------------------------------------|---------------------------|--------------------------|------|
| `love.font.newRasterizer(filename, size)` or `love.font.newRasterizer(filedata, size)` or `love.font.newRasterizer(size)` | `Night.Graphics.NewFontRasterizer(string filePath, int size)` etc. | `public static Night.FontRasterizer NewFontRasterizer(...)` <br> Creates a font rasterizer. `Night.Font` would likely encapsulate this. | Out of Scope | [ ] |
| `love.font.newGlyphData(rasterizer, glyph)` | `(Night.FontRasterizer).NewGlyphData(char glyph)` or `(Night.FontRasterizer).NewGlyphData(uint glyph)` | `public Night.GlyphData NewGlyphData(char glyph)` (method on `FontRasterizer` or `Font`) | Out of Scope | [ ] |

**Related functionality in Night Engine (on `Night.Font` objects):**
*   Getting font height: `myFont.GetHeight()`
*   Getting ascent/descent: `myFont.GetAscent()`, `myFont.GetDescent()`
*   Getting baseline: `myFont.GetBaseline()`
*   Getting line height: `myFont.GetLineHeight()`
*   Getting text width: `myFont.GetWidth(string text)`
*   Wrapping text: `myFont.Wrap(string text, float wrapLimit)`
*   Setting fallback fonts: `myFont.SetFallback(Night.Font fallback1, ...)`

**Night Engine Specific Types:**
*   `Night.Font`: Represents a loaded font. Created via `Night.Graphics.NewFont()`. Would have methods for metrics and properties.
*   `Night.FontRasterizer`: Internal or advanced type for rasterizing glyphs.
*   `Night.GlyphData`: Represents rasterized data for a single glyph.



================================================
File: docs/love2d-api/graphics.md
================================================
# `love.graphics` Module API Mapping

This document maps the functions available in the `love.graphics` module of Love2D to their proposed equivalents in the Night Engine.

| Love2D Function (`love.graphics.`) | Night Engine API (`Night.Graphics.`) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|------------------------------------|--------------------------------------|---------------------------|--------------------------|------|
| `love.graphics.arc(mode, arcType, x, y, radius, angle1, angle2, segments)` | `Night.Graphics.DrawArc(Night.DrawMode mode, Night.ArcType arcType, float x, float y, float radius, float angle1, float angle2, int? segments = null)` | `public static void DrawArc(Night.DrawMode mode, Night.ArcType arcType, float x, float y, float radius, float angle1, float angle2, int? segments = null)` <br> `DrawMode` enum: `Fill`, `Line`. `ArcType` enum: `Open`, `Closed`, `Pie`. Segments auto-calculated if null. | Out of Scope | [ ] |
| `love.graphics.circle(mode, x, y, radius, segments)` | `Night.Graphics.DrawCircle(Night.DrawMode mode, float x, float y, float radius, int? segments = null)` | `public static void DrawCircle(Night.DrawMode mode, float x, float y, float radius, int? segments = null)` | Out of Scope | [ ] |
| `love.graphics.clear(r, g, b, a)` or `love.graphics.clear(color)` | `Night.Graphics.Clear(Night.Color color)` or `Night.Graphics.Clear(byte r, byte g, byte b, byte a = 255)` | `public static void Clear(Night.Color color)` <br> `public static void Clear(byte r, byte g, byte b, byte a = 255)` | In Scope | [ ] |
| `love.graphics.discard(discardColor, discardStencil)` | `Night.Graphics.Discard(bool discardColor = true, bool discardStencil = true)` | `public static void Discard(bool discardColor = true, bool discardStencil = true)` <br> Discards render target contents. | Out of Scope | [ ] |
| `love.graphics.draw(drawable, x, y, r, sx, sy, ox, oy, kx, ky)` | `Night.Graphics.Draw(Night.IDrawable drawable, float x, float y, float rotation = 0, float scaleX = 1, float scaleY = 1, float offsetX = 0, float offsetY = 0, float shearX = 0, float shearY = 0)` | `public static void Draw(Night.IDrawable drawable, float x, float y, float rotation = 0, float scaleX = 1, float scaleY = 1, float offsetX = 0, float offsetY = 0, float shearX = 0, float shearY = 0)` <br> `IDrawable` could be `Sprite`, `Text`, `Shape`, etc. | In Scope (for Sprites) | [ ] |
| `love.graphics.draw(texture, quad, x, y, r, sx, sy, ox, oy, kx, ky)` | `Night.Graphics.Draw(Night.Texture texture, Night.Quad quad, float x, float y, float rotation = 0, float scaleX = 1, float scaleY = 1, float offsetX = 0, float offsetY = 0, float shearX = 0, float shearY = 0)` | `public static void Draw(Night.Texture texture, Night.Quad quad, ...)` <br> For drawing parts of a texture. | In Scope (for Sprites with Quads) | [ ] |
| `love.graphics.ellipse(mode, x, y, radiusx, radiusy, segments)` | `Night.Graphics.DrawEllipse(Night.DrawMode mode, float x, float y, float radiusX, float radiusY, int? segments = null)` | `public static void DrawEllipse(Night.DrawMode mode, float x, float y, float radiusX, float radiusY, int? segments = null)` | Out of Scope | [ ] |
| `love.graphics.getBackgroundColor()` | `Night.Graphics.GetBackgroundColor()` | `public static Night.Color GetBackgroundColor()` | In Scope | [ ] |
| `love.graphics.getBlendMode()`     | `Night.Graphics.GetBlendMode()`    | `public static (Night.BlendMode mode, Night.BlendAlphaMode alphaMode) GetBlendMode()` | Out of Scope | [ ] |
| `love.graphics.getCanvas()`        | `Night.Graphics.GetRenderTarget()` | `public static Night.IRenderTarget GetRenderTarget()` <br> Returns current render target (Canvas or screen). | Out of Scope | [ ] |
| `love.graphics.getCanvasFormats()` | `Night.Graphics.GetSupportedRenderTargetFormats()` | `public static Night.RenderTargetFormat[] GetSupportedRenderTargetFormats()` | Out of Scope | [ ] |
| `love.graphics.getColor()`         | `Night.Graphics.GetColor()`        | `public static Night.Color GetColor()` | In Scope | [ ] |
| `love.graphics.getColorMask()`     | `Night.Graphics.GetColorMask()`    | `public static (bool r, bool g, bool b, bool a) GetColorMask()` | Out of Scope | [ ] |
| `love.graphics.getDefaultFilter()` | `Night.Graphics.GetDefaultFilter()` | `public static Night.FilterMode GetDefaultFilter()` <br> `FilterMode` enum: `Linear`, `Nearest`. | In Scope | [ ] |
| `love.graphics.getDepthMode()`     | `Night.Graphics.GetDepthMode()`    | `public static (Night.CompareMode? mode, bool write) GetDepthMode()` | Out of Scope | [ ] |
| `love.graphics.getDimensions()`    | `Night.Graphics.GetDimensions()`   | `public static (int width, int height) GetDimensions()` <br> Gets dimensions of current render target (screen or canvas). | In Scope | [ ] |
| `love.graphics.getFont()`          | `Night.Graphics.GetFont()`         | `public static Night.Font GetFont()` | Out of Scope | [ ] |
| `love.graphics.getHeight()`        | `Night.Graphics.GetHeight()`       | `public static int GetHeight()` <br> Height of current render target. | In Scope | [ ] |
| `love.graphics.getLineWidth()`     | `Night.Graphics.GetLineWidth()`    | `public static float GetLineWidth()` | Out of Scope | [ ] |
| `love.graphics.getLineStyle()`     | `Night.Graphics.GetLineStyle()`    | `public static Night.LineStyle GetLineStyle()` <br> `LineStyle` enum: `Smooth`, `Rough`. | Out of Scope | [ ] |
| `love.graphics.getLineJoin()`      | `Night.Graphics.GetLineJoin()`     | `public static Night.LineJoin GetLineJoin()` <br> `LineJoin` enum: `None`, `Miter`, `Bevel`. | Out of Scope | [ ] |
| `love.graphics.getPointSize()`     | `Night.Graphics.GetPointSize()`    | `public static float GetPointSize()` | Out of Scope | [ ] |
| `love.graphics.getRendererInfo()`  | `Night.Graphics.GetRendererInfo()` | `public static Night.RendererInfo GetRendererInfo()` <br> `RendererInfo` class: `Name`, `Version`, `Vendor`, `Device`. | In Scope | [ ] |
| `love.graphics.getScissor()`       | `Night.Graphics.GetScissor()`      | `public static Night.Rectangle? GetScissor()` | Out of Scope | [ ] |
| `love.graphics.getShader()`        | `Night.Graphics.GetShader()`       | `public static Night.Shader GetShader()` | Out of Scope | [ ] |
| `love.graphics.getStats()`         | `Night.Graphics.GetStats()`        | `public static Night.GraphicsStats GetStats()` <br> `GraphicsStats` class: `DrawCalls`, `CanvasSwitches`, `ShaderSwitches`, etc. | In Scope (Basic stats) | [ ] |
| `love.graphics.getStencilTest()`   | `Night.Graphics.GetStencilTest()`  | `public static (Night.CompareMode? mode, int value) GetStencilTest()` | Out of Scope | [ ] |
| `love.graphics.getWidth()`         | `Night.Graphics.GetWidth()`        | `public static int GetWidth()` <br> Width of current render target. | In Scope | [ ] |
| `love.graphics.intersectScissor(x, y, width, height)` | `Night.Graphics.IntersectScissor(int x, int y, int width, int height)` | `public static void IntersectScissor(int x, int y, int width, int height)` | Out of Scope | [ ] |
| `love.graphics.isWireframe()`      | `Night.Graphics.IsWireframe()`     | `public static bool IsWireframe()` | Out of Scope | [ ] |
| `love.graphics.line(x1, y1, x2, y2, ...)` or `love.graphics.line(points)` | `Night.Graphics.DrawLine(params float[] points)` or `Night.Graphics.DrawLine(Night.PointF[] points)` | `public static void DrawLine(params float[] points)` <br> `public static void DrawLine(Night.PointF[] points)` | Out of Scope | [ ] |
| `love.graphics.newCanvas(width, height, format, msaa)` | `Night.Graphics.NewRenderTarget(int width, int height, Night.RenderTargetFormat format = Default, int msaa = 0)` | `public static Night.IRenderTarget NewRenderTarget(...)` | Out of Scope | [ ] |
| `love.graphics.newFont(filename, size)` or `love.graphics.newFont(size)` | `Night.Graphics.NewFont(string filePath, int size)` or `Night.Graphics.NewFont(int size)` | `public static Night.Font NewFont(...)` <br> Uses default font if no path. | Out of Scope | [ ] |
| `love.graphics.newImage(filename)` | `Night.Graphics.NewImage(string filePath)` | `public static Night.Sprite NewImage(string filePath)` <br> PRD refers to `Sprite` as return type. | In Scope | [ ] |
| `love.graphics.newImageFont(filename, glyphs, extraspacing)` | `Night.Graphics.NewImageFont(string filePath, string glyphs, int extraSpacing = 0)` | `public static Night.Font NewImageFont(...)` | Out of Scope | [ ] |
| `love.graphics.newQuad(x, y, width, height, sw, sh)` | `Night.Graphics.NewQuad(float x, float y, float width, float height, float sourceWidth, float sourceHeight)` | `public static Night.Quad NewQuad(...)` | In Scope | [ ] |
| `love.graphics.newShader(pixelcode, vertexcode)` | `Night.Graphics.NewShader(string pixelShaderCode, string vertexShaderCode = null)` | `public static Night.Shader NewShader(...)` | Out of Scope | [ ] |
| `love.graphics.newSpriteBatch(texture, size, usagehint)` | `Night.Graphics.NewSpriteBatch(Night.Texture texture, int size, Night.UsageHint hint = Dynamic)` | `public static Night.SpriteBatch NewSpriteBatch(...)` | Out of Scope | [ ] |
| `love.graphics.newText(font, textparts)` | `Night.Graphics.NewText(Night.Font font, params (string text, Night.Color? color)[] textParts)` | `public static Night.Text NewText(...)` | Out of Scope | [ ] |
| `love.graphics.newVideo(filename, options)` | `Night.Graphics.NewVideo(string filePath, Night.VideoOptions? options = null)` | `public static Night.Video NewVideo(...)` | Out of Scope | [ ] |
| `love.graphics.origin()`           | `Night.Graphics.ResetTransform()`  | `public static void ResetTransform()` <br> Resets current transformation to identity. | In Scope | [ ] |
| `love.graphics.points(coords, colors)` | `Night.Graphics.DrawPoints(Night.PointF[] positions, Night.Color[]? colors = null)` | `public static void DrawPoints(...)` | Out of Scope | [ ] |
| `love.graphics.polygon(mode, vertices)` | `Night.Graphics.DrawPolygon(Night.DrawMode mode, params Night.PointF[] vertices)` | `public static void DrawPolygon(...)` | Out of Scope | [ ] |
| `love.graphics.pop()`              | `Night.Graphics.PopTransform()`    | `public static void PopTransform()` | In Scope | [ ] |
| `love.graphics.present()`          | `Night.Graphics.Present()`         | `public static void Present()` <br> Called by engine after `MyGame.Draw()`. | In Scope | [ ] |
| `love.graphics.print(text, x, y, r, sx, sy, ox, oy, kx, ky)` | `Night.Graphics.Print(string text, float x, float y, float rotation = 0, ...)` | `public static void Print(string text, float x, float y, ...)` <br> Uses current font. | Out of Scope | [ ] |
| `love.graphics.printf(text, x, y, limit, align, r, sx, sy, ox, oy, kx, ky)` | `Night.Graphics.PrintF(string text, float x, float y, float wrapLimit, Night.TextAlign align = Left, ...)` | `public static void PrintF(...)` | Out of Scope | [ ] |
| `love.graphics.push(stacktype)`    | `Night.Graphics.PushTransform(Night.StackType type = All)` | `public static void PushTransform(Night.StackType type = Night.StackType.All)` <br> `StackType` enum: `All`, `Transform`. | In Scope | [ ] |
| `love.graphics.rectangle(mode, x, y, width, height, rx, ry, segments)` | `Night.Graphics.DrawRectangle(Night.DrawMode mode, float x, float y, float width, float height, float cornerRadiusX = 0, float cornerRadiusY = 0, int? segments = null)` | `public static void DrawRectangle(...)` | Out of Scope | [ ] |
| `love.graphics.reset()`            | `Night.Graphics.ResetState()`      | `public static void ResetState()` <br> Resets all graphics state (color, blend mode, etc.) | In Scope | [ ] |
| `love.graphics.rotate(angle)`      | `Night.Graphics.Rotate(float angleInRadians)` | `public static void Rotate(float angleInRadians)` | In Scope | [ ] |
| `love.graphics.scale(sx, sy)`      | `Night.Graphics.Scale(float scaleX, float scaleY)` | `public static void Scale(float scaleX, float scaleY)` | In Scope | [ ] |
| `love.graphics.shear(kx, ky)`      | `Night.Graphics.Shear(float shearX, float shearY)` | `public static void Shear(float shearX, float shearY)` | In Scope | [ ] |
| `love.graphics.setBackgroundColor(r, g, b, a)` or `love.graphics.setBackgroundColor(color)` | `Night.Graphics.SetBackgroundColor(Night.Color color)` or `Night.Graphics.SetBackgroundColor(byte r, byte g, byte b, byte a = 255)` | `public static void SetBackgroundColor(...)` | In Scope | [ ] |
| `love.graphics.setBlendMode(mode, alphamode)` | `Night.Graphics.SetBlendMode(Night.BlendMode mode, Night.BlendAlphaMode alphaMode = Multiply)` | `public static void SetBlendMode(...)` | Out of Scope | [ ] |
| `love.graphics.setCanvas(canvas)` or `love.graphics.setCanvas()` | `Night.Graphics.SetRenderTarget(Night.IRenderTarget? target = null)` | `public static void SetRenderTarget(Night.IRenderTarget? target = null)` <br> `null` sets to screen. | Out of Scope | [ ] |
| `love.graphics.setColor(r, g, b, a)` or `love.graphics.setColor(color)` | `Night.Graphics.SetColor(Night.Color color)` or `Night.Graphics.SetColor(byte r, byte g, byte b, byte a = 255)` | `public static void SetColor(...)` | In Scope | [ ] |
| `love.graphics.setColorMask(r, g, b, a)` | `Night.Graphics.SetColorMask(bool r, bool g, bool b, bool a)` | `public static void SetColorMask(bool r, bool g, bool b, bool a)` | Out of Scope | [ ] |
| `love.graphics.setDefaultFilter(min, mag, anisotropy)` | `Night.Graphics.SetDefaultFilter(Night.FilterMode min, Night.FilterMode? mag = null, float anisotropy = 1.0f)` | `public static void SetDefaultFilter(...)` <br> `mag` defaults to `min` if null. | In Scope | [ ] |
| `love.graphics.setDepthMode(mode, write)` | `Night.Graphics.SetDepthMode(Night.CompareMode? mode, bool write)` | `public static void SetDepthMode(Night.CompareMode? mode, bool write)` | Out of Scope | [ ] |
| `love.graphics.setFont(font)`      | `Night.Graphics.SetFont(Night.Font font)` | `public static void SetFont(Night.Font font)` | Out of Scope | [ ] |
| `love.graphics.setLineWidth(width)` | `Night.Graphics.SetLineWidth(float width)` | `public static void SetLineWidth(float width)` | Out of Scope | [ ] |
| `love.graphics.setLineStyle(style)` | `Night.Graphics.SetLineStyle(Night.LineStyle style)` | `public static void SetLineStyle(Night.LineStyle style)` | Out of Scope | [ ] |
| `love.graphics.setLineJoin(join)`  | `Night.Graphics.SetLineJoin(Night.LineJoin join)` | `public static void SetLineJoin(Night.LineJoin join)` | Out of Scope | [ ] |
| `love.graphics.setPointSize(size)` | `Night.Graphics.SetPointSize(float size)` | `public static void SetPointSize(float size)` | Out of Scope | [ ] |
| `love.graphics.setScissor(x, y, width, height)` or `love.graphics.setScissor()` | `Night.Graphics.SetScissor(int? x, int? y, int? width, int? height)` or `Night.Graphics.SetScissor(Night.Rectangle? rect)` | `public static void SetScissor(Night.Rectangle? rect)` <br> `null` disables scissor. | Out of Scope | [ ] |
| `love.graphics.setShader(shader)` or `love.graphics.setShader()` | `Night.Graphics.SetShader(Night.Shader? shader = null)` | `public static void SetShader(Night.Shader? shader = null)` | Out of Scope | [ ] |
| `love.graphics.setStencilTest(comparemode, comparevalue)` or `love.graphics.setStencilTest()` | `Night.Graphics.SetStencilTest(Night.CompareMode? mode = null, int value = 0)` | `public static void SetStencilTest(Night.CompareMode? mode = null, int value = 0)` | Out of Scope | [ ] |
| `love.graphics.setWireframe(enable)` | `Night.Graphics.SetWireframe(bool enable)` | `public static void SetWireframe(bool enable)` | Out of Scope | [ ] |
| `love.graphics.stencil(stencilfunction, action, value, keepvalues)` | `Night.Graphics.Stencil(Action stencilFunction, Night.StencilAction action = Replace, int value = 1, bool keepValues = false)` | `public static void Stencil(...)` <br> Complex. | Out of Scope | [ ] |
| `love.graphics.translate(dx, dy)`  | `Night.Graphics.Translate(float deltaX, float deltaY)` | `public static void Translate(float deltaX, float deltaY)` | In Scope | [ ] |
| `love.graphics.transformPoint(worldX, worldY)` | `Night.Graphics.TransformPoint(float worldX, float worldY)` | `public static (float screenX, float screenY) TransformPoint(float worldX, float worldY)` | In Scope | [ ] |
| `love.graphics.inverseTransformPoint(screenX, screenY)` | `Night.Graphics.InverseTransformPoint(float screenX, float screenY)` | `public static (float worldX, float worldY) InverseTransformPoint(float screenX, float screenY)` | In Scope | [ ] |

**Night Engine Specific Types:**
*   `Night.DrawMode`: Enum (`Fill`, `Line`).
*   `Night.ArcType`: Enum (`Open`, `Closed`, `Pie`).
*   `Night.IDrawable`: Interface for drawable objects (Sprite, Text, etc.).
*   `Night.Texture`: Represents a texture (likely part of `Night.Image` or `Night.Sprite`).
*   `Night.Quad`: Represents a portion of a texture.
*   `Night.Color`: Struct/class for color (RGBA).
*   `Night.BlendMode`: Enum for blending (e.g., `Alpha`, `Add`, `Subtract`, `Multiply`).
*   `Night.BlendAlphaMode`: Enum for alpha blending (e.g., `Multiply`, `PreMultiplied`).
*   `Night.IRenderTarget`: Interface for render targets (Canvas or screen).
*   `Night.RenderTargetFormat`: Enum for pixel formats of render targets.
*   `Night.FilterMode`: Enum (`Linear`, `Nearest`).
*   `Night.CompareMode`: Enum for depth/stencil tests (e.g., `Less`, `Equal`, `Greater`, `Always`).
*   `Night.Font`: Represents a font.
*   `Night.LineStyle`: Enum (`Smooth`, `Rough`).
*   `Night.LineJoin`: Enum (`None`, `Miter`, `Bevel`).
*   `Night.RendererInfo`: Class with properties like `Name`, `Version`, `Vendor`, `Device`.
*   `Night.Rectangle`: Struct/class for a rectangle (X, Y, Width, Height).
*   `Night.Shader`: Represents a shader program.
*   `Night.GraphicsStats`: Class for graphics statistics.
*   `Night.PointF`: Struct for a 2D point with float coordinates.
*   `Night.Sprite`: Represents an image that can be drawn. (Corresponds to Love2D Image)
*   `Night.SpriteBatch`: For optimized drawing of many sprites from the same texture.
*   `Night.Text`: Represents renderable text.
*   `Night.Video`: Represents a video that can be drawn.
*   `Night.VideoOptions`: Options for video loading.
*   `Night.StackType`: Enum (`All`, `Transform`).
*   `Night.TextAlign`: Enum (`Left`, `Center`, `Right`, `Justify`).
*   `Night.StencilAction`: Enum for stencil operations (e.g., `Keep`, `Replace`, `Increment`).
*   `Night.UsageHint`: Enum for SpriteBatch (`Static`, `Dynamic`, `Stream`).



================================================
File: docs/love2d-api/image.md
================================================
# `love.image` Module API Mapping

This document maps the functions available in the `love.image` module of Love2D to their proposed equivalents in the Night Engine. The functionality of this module is often integrated into `Night.Sprite` or `Night.Texture` objects, or handled during image loading. Most direct `love.image` functions are **Out of Scope** for the initial prototype as standalone static methods.

| Love2D Function (`love.image.`) | Night Engine API (`Night.Image` or `Texture`/`Sprite` methods) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|---------------------------------|----------------------------------------------------------------|---------------------------|--------------------------|------|
| `love.image.newImageData(width, height, format, data)` | `Night.Image.NewImageData(int width, int height, Night.PixelFormat format = RGBA8, byte[]? data = null)` | `public static Night.ImageData NewImageData(...)` <br> Creates raw image data. `Night.ImageData` would be a class/struct. | Out of Scope | [ ] |
| `love.image.isCompressed(filename)` or `love.image.isCompressed(filedata)` | `Night.Image.IsCompressed(string filePath)` or `Night.Image.IsCompressed(Night.FileData fileData)` | `public static bool IsCompressed(...)` <br> Checks if an image file is a compressed format LÖVE can load. | Out of Scope | [ ] |
| `love.image.newCompressedData(filename)` | `Night.Image.NewCompressedData(string filePath)` | `public static Night.CompressedImageData NewCompressedData(string filePath)` <br> Loads a compressed image file (e.g. DDS, KTX) into a special data object. | Out of Scope | [ ] |

**Related functionality in Night Engine (on `Sprite` or `Texture` or `ImageData` objects):**
*   Getting dimensions: `mySprite.GetWidth()`, `mySprite.GetHeight()`
*   Getting format: `myImageData.GetFormat()`
*   Manipulating pixel data: `myImageData.GetPixel(x,y)`, `myImageData.SetPixel(x,y,color)` (Likely Out of Scope for prototype)
*   Encoding/Decoding: Functionality to save an `ImageData` to a file (e.g., `myImageData.Encode("png", "filename.png")`) is Out of Scope.

**Night Engine Specific Types:**
*   `Night.ImageData`: Represents raw, uncompressed image data. Could have methods like `GetWidth()`, `GetHeight()`, `GetPixel()`, `SetPixel()`.
*   `Night.PixelFormat`: Enum for pixel formats (e.g., `RGBA8`, `RGB8`, `Luminance8`).
*   `Night.FileData`: Represents file data in memory (from `Night.Filesystem`).
*   `Night.CompressedImageData`: Represents compressed image data.
*   `Night.Sprite`: The primary object for loaded images, returned by `Night.Graphics.NewImage()`. It would internally manage texture data.



================================================
File: docs/love2d-api/joystick.md
================================================
# `love.joystick` Module API Mapping

This document maps the functions available in the `love.joystick` module of Love2D to their proposed equivalents in the Night Engine. This entire module is **Out of Scope** for the initial prototype. Joystick event callbacks are noted in the `love` module mapping.

| Love2D Function (`love.joystick.`) | Night Engine API (`Night.Joystick` or `Joystick` instance methods) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|------------------------------------|--------------------------------------------------------------------|---------------------------|--------------------------|------|
| `love.joystick.getJoysticks()`     | `Night.Joystick.GetJoysticks()`    | `public static Night.Joystick[] GetJoysticks()` <br> Returns all connected joysticks. | Out of Scope | [ ] |
| `love.joystick.getJoystickCount()` | `Night.Joystick.GetJoystickCount()` | `public static int GetJoystickCount()` | Out of Scope | [ ] |
| `love.joystick.loadGamepadMappings(filename)` or `love.joystick.loadGamepadMappings(string)` | `Night.Joystick.LoadGamepadMappings(string pathOrString)` | `public static bool LoadGamepadMappings(string pathOrString)` | Out of Scope | [ ] |
| `love.joystick.saveGamepadMappings(joystick)` | `(Night.Joystick).SaveGamepadMappings()` | `public string SaveGamepadMappings()` (Method on `Joystick` instance) | Out of Scope | [ ] |
| `love.joystick.setGamepadMapping(guid, buttonOrAxis, inputtype, inputindex, hatdirection)` | `Night.Joystick.SetGamepadMapping(string guid, ...)` | Complex mapping function. | Out of Scope | [ ] |

**Functionality on `Night.Joystick` instances (if implemented):**
*   `joystick.isConnected()`
*   `joystick.getName()`
*   `joystick.getID()` (instance ID)
*   `joystick.getGUID()`
*   `joystick.getAxisCount()`
*   `joystick.getButtonCount()`
*   `joystick.getHatCount()`
*   `joystick.getAxis(axisindex)`
*   `joystick.getAxes()`
*   `joystick.isDown(buttonindex, ...)`
*   `joystick.getHat(hatindex)`
*   `joystick.isGamepad()`
*   `joystick.getGamepadAxis(axis)`
*   `joystick.isGamepadDown(button)`
*   `joystick.setVibration(left, right, duration)`
*   `joystick.hasVibration()`

**Night Engine Specific Types:**
*   `Night.Joystick`: Represents a joystick/gamepad device.
*   `Night.GamepadAxis`: Enum for standard gamepad axes (e.g., `LeftX`, `LeftY`, `RightX`, `RightY`, `TriggerLeft`, `TriggerRight`).
*   `Night.GamepadButton`: Enum for standard gamepad buttons (e.g., `A`, `B`, `X`, `Y`, `Start`, `Select`, `DPadUp`).
*   `Night.HatDirection`: Enum for hat switch directions (e.g., `Centered`, `Up`, `Down`, `Left`, `Right`, `UpLeft`).



================================================
File: docs/love2d-api/keyboard.md
================================================
# `love.keyboard` Module API Mapping

This document maps the functions available in the `love.keyboard` module of Love2D to their proposed equivalents in the Night Engine.

| Love2D Function (`love.keyboard.`) | Night Engine API (`Night.Keyboard.`) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|------------------------------------|--------------------------------------|---------------------------|--------------------------|------|
| `love.keyboard.isDown(key)`        | `Night.Keyboard.IsDown(Night.KeyCode key)` | `public static bool IsDown(Night.KeyCode key)` <br> Checks if specific keys are held down. `Night.KeyCode` enum will map to SDL scancodes. | In Scope | [ ] |
| `love.keyboard.isScancodeDown(scancode)` | `Night.Keyboard.IsScancodeDown(Night.Scancode scancode)` | `public static bool IsScancodeDown(Night.Scancode scancode)` <br> `Night.Scancode` would be an enum closely matching SDL scancodes. May be internal or less used if `KeyCode` is preferred. | In Scope (Lower priority than `IsDown`) | [ ] |
| `love.keyboard.getKeyFromScancode(scancode)` | `Night.Keyboard.GetKeyFromScancode(Night.Scancode scancode)` | `public static Night.KeyCode GetKeyFromScancode(Night.Scancode scancode)` | In Scope (Helper for input mapping) | [ ] |
| `love.keyboard.getScancodeFromKey(key)` | `Night.Keyboard.GetScancodeFromKey(Night.KeyCode key)` | `public static Night.Scancode GetScancodeFromKey(Night.KeyCode key)` | In Scope (Helper for input mapping) | [ ] |
| `love.keyboard.setKeyRepeat(enable)` | `Night.Keyboard.SetKeyRepeatEnabled(bool enabled)` | `public static void SetKeyRepeatEnabled(bool enabled)` <br> Enables or disables key repeat for `love.keypressed`. SDL handles this by default; this might control if `isRepeat` is true in `MyGame.KeyPressed`. | In Scope (Verify SDL behavior) | [ ] |
| `love.keyboard.hasKeyRepeat()`     | `Night.Keyboard.HasKeyRepeat()`    | `public static bool HasKeyRepeat()` <br> Checks if key repeat is enabled. | In Scope (Verify SDL behavior) | [ ] |
| `love.keyboard.setTextInput(enable, x, y, w, h)` | `Night.Keyboard.SetTextInputRect(bool enable, Night.Rectangle? rect = null)` | `public static void SetTextInputRect(bool enable, Night.Rectangle? rect = null)` <br> For on-screen keyboards on touch devices. `rect` defines text input area. | Out of Scope | [ ] |
| `love.keyboard.hasScreenKeyboard()` | `Night.Keyboard.HasScreenKeyboard()` | `public static bool HasScreenKeyboard()` | Out of Scope | [ ] |

**Night Engine Specific Types:**
*   `Night.KeyCode`: Enum representing keyboard keys (e.g., `A`, `Space`, `Return`). This will be mapped to SDL scancodes.
*   `Night.Scancode`: Enum representing platform-independent physical key codes (e.g., `SDL_SCANCODE_A`).
*   `Night.Rectangle`: Struct/class for a rectangle (X, Y, Width, Height).



================================================
File: docs/love2d-api/love.md
================================================
# `love` Module API Mapping

This document maps the functions available in the base `love` module of Love2D to their proposed equivalents in the Night Engine.

| Love2D Function (`love.`) | Night Engine API (`Night.`) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|---------------------------|-----------------------------|---------------------------|--------------------------|------|
| `love.getVersion()`       | `Night.Engine.GetVersion()` | `public static string GetVersion()` <br> Returns a string like "Major.Minor.Revision Codename". | In Scope | [ ] |
| `love.setDeprecationOutput(boolean enabled)` | `Night.Engine.SetDeprecationOutput(bool enabled)` | `public static void SetDeprecationOutput(bool enabled)` <br> Controls whether Love2D's deprecation warnings are output. May or may not be relevant for Night. | Out of Scope (Low Priority) | [ ] |
| `love.run()`              | `Night.Engine.Run<T>()` or `Night.Engine.Run(IGame gameInstance)` | `public static void Run<T>() where T : IGame, new()` <br> `public static void Run(IGame gameInstance)` <br> This is the main entry point that starts the game loop. The user provides a game class/instance. | In Scope | [x] |
| `love.load(arg)`          | `MyGame.Load(string[] args)` | Implemented by the user in their game class: `void Load(string[] args);` <br> Called once at the beginning. `arg` in Love2D contains command-line arguments. | In Scope | [x] |
| `love.update(dt)`         | `MyGame.Update(double deltaTime)` | Implemented by the user: `void Update(double deltaTime);` <br> Called every frame. | In Scope | [x] |
| `love.draw()`             | `MyGame.Draw()`             | Implemented by the user: `void Draw();` <br> Called every frame after update. | In Scope | [x] |
| `love.quit()`             | `MyGame.Quit()` or `Night.Engine.Quit()` | User implementation: `bool Quit();` (return true to allow quit) <br> Engine initiated: `Night.Engine.RequestQuit()` or similar. Love2D `love.quit` can also be an event. | In Scope (Basic window close event handling) | [ ] |
| `love.focus(f)`           | `MyGame.FocusChanged(bool hasFocus)` | User implementation: `void FocusChanged(bool hasFocus);` | In Scope | [ ] |
| `love.mousefocus(f)`      | `MyGame.MouseFocusChanged(bool hasFocus)` | User implementation: `void MouseFocusChanged(bool hasFocus);` | Out of Scope (Covered by general focus) | [ ] |
| `love.visible(v)`         | `MyGame.VisibilityChanged(bool isVisible)` | User implementation: `void VisibilityChanged(bool isVisible);` | In Scope | [ ] |
| `love.keypressed(key, scancode, isrepeat)` | `MyGame.KeyPressed(Night.KeyCode key, string scancode, bool isRepeat)` | User implementation: `void KeyPressed(Night.KeyCode key, /* SDL_Scancode scancode, */ bool isRepeat);` <br> `scancode` might be abstracted away or be an internal SDL detail. | In Scope | [ ] |
| `love.keyreleased(key, scancode)` | `MyGame.KeyReleased(Night.KeyCode key, string scancode)` | User implementation: `void KeyReleased(Night.KeyCode key /*, SDL_Scancode scancode */);` | In Scope | [ ] |
| `love.textinput(text)`    | `MyGame.TextInput(string text)` | User implementation: `void TextInput(string text);` | In Scope (but low priority for prototype) | [ ] |
| `love.mousepressed(x, y, button, istouch, presses)` | `MyGame.MousePressed(int x, int y, Night.MouseButton button, bool isTouch, int presses)` | User implementation: `void MousePressed(int x, int y, Night.MouseButton button, int presses);` <br> `isTouch` might be handled separately if touch events are distinct. | In Scope | [ ] |
| `love.mousereleased(x, y, button, istouch)` | `MyGame.MouseReleased(int x, int y, Night.MouseButton button, bool isTouch)` | User implementation: `void MouseReleased(int x, int y, Night.MouseButton button);` | In Scope | [ ] |
| `love.mousemoved(x, y, dx, dy, istouch)` | `MyGame.MouseMoved(int x, int y, int deltaX, int deltaY, bool isTouch)` | User implementation: `void MouseMoved(int x, int y, int deltaX, int deltaY);` | In Scope | [ ] |
| `love.wheelmoved(x, y)`   | `MyGame.MouseWheelMoved(int deltaX, int deltaY)` | User implementation: `void MouseWheelMoved(int deltaX, int deltaY);` | In Scope (Basic support) | [ ] |
| `love.joystickpressed(joystick, button)` | `MyGame.JoystickPressed(Night.Joystick joystick, int button)` | User implementation: `void JoystickPressed(Night.Joystick joystick, int button);` | Out of Scope | [ ] |
| `love.joystickreleased(joystick, button)` | `MyGame.JoystickReleased(Night.Joystick joystick, int button)` | User implementation: `void JoystickReleased(Night.Joystick joystick, int button);` | Out of Scope | [ ] |
| `love.joystickaxis(joystick, axis, value)` | `MyGame.JoystickAxisMoved(Night.Joystick joystick, int axis, float value)` | User implementation: `void JoystickAxisMoved(Night.Joystick joystick, int axis, float value);` | Out of Scope | [ ] |
| `love.joystickhat(joystick, hat, direction)` | `MyGame.JoystickHatMoved(Night.Joystick joystick, int hat, Night.HatDirection direction)` | User implementation: `void JoystickHatMoved(Night.Joystick joystick, int hat, Night.HatDirection direction);` | Out of Scope | [ ] |
| `love.joystickadded(joystick)` | `MyGame.JoystickAdded(Night.Joystick joystick)` | User implementation: `void JoystickAdded(Night.Joystick joystick);` | Out of Scope | [ ] |
| `love.joystickremoved(joystick)` | `MyGame.JoystickRemoved(Night.Joystick joystick)` | User implementation: `void JoystickRemoved(Night.Joystick joystick);` | Out of Scope | [ ] |
| `love.touchpressed(id, x, y, dx, dy, pressure)` | `MyGame.TouchPressed(long id, float x, float y, float deltaX, float deltaY, float pressure)` | User implementation: `void TouchPressed(long id, float x, float y, float deltaX, float deltaY, float pressure);` | Out of Scope | [ ] |
| `love.touchreleased(id, x, y, dx, dy, pressure)` | `MyGame.TouchReleased(long id, float x, float y, float deltaX, float deltaY, float pressure)` | User implementation: `void TouchReleased(long id, float x, float y, float deltaX, float deltaY, float pressure);` | Out of Scope | [ ] |
| `love.touchmoved(id, x, y, dx, dy, pressure)` | `MyGame.TouchMoved(long id, float x, float y, float deltaX, float deltaY, float pressure)` | User implementation: `void TouchMoved(long id, float x, float y, float deltaX, float deltaY, float pressure);` | Out of Scope | [ ] |
| `love.lowmemory()`        | `MyGame.LowMemory()`        | User implementation: `void LowMemory();` | Out of Scope | [ ] |
| `love.threaderror(thread, errorstr)` | `MyGame.ThreadError(Night.Thread thread, string error)` | User implementation: `void ThreadError(Night.Thread thread, string error);` | Out of Scope | [ ] |
| `love.directorydropped(path)` | `MyGame.DirectoryDropped(string path)` | User implementation: `void DirectoryDropped(string path);` | Out of Scope | [ ] |
| `love.filedropped(file)`  | `MyGame.FileDropped(Night.File file)` | User implementation: `void FileDropped(Night.File file);` <br> `Night.File` would be a wrapper for file data. | Out of Scope | [ ] |
| `love.resize(w, h)`       | `MyGame.WindowResized(int width, int height)` | User implementation: `void WindowResized(int width, int height);` | In Scope | [ ] |

*Note: Many `love` module functions are event callbacks. In Night Engine, these will be methods the user implements in their game class, which are then called by `Night.Engine`.*



================================================
File: docs/love2d-api/math.md
================================================
# `love.math` Module API Mapping

This document maps the functions available in the `love.math` module of Love2D to their proposed equivalents in the Night Engine. Most of this functionality can be achieved using `System.Math` and `System.Random` in C#. A dedicated `Night.Math` module is **Out of Scope** for the initial prototype, but specific advanced functions might be added later.

| Love2D Function (`love.math.`) | Night Engine API (`Night.Math` or `System`) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|--------------------------------|---------------------------------------------|---------------------------|--------------------------|------|
| `love.math.triangulate(polygon)` | `Night.Math.Triangulate(Night.PointF[] polygon)` | `public static int[] Triangulate(Night.PointF[] polygon)` <br> Returns indices for triangles. | Out of Scope | [ ] |
| `love.math.isConvex(polygon)`  | `Night.Math.IsConvex(Night.PointF[] polygon)` | `public static bool IsConvex(Night.PointF[] polygon)` | Out of Scope | [ ] |
| `love.math.getAngle(x1, y1, x2, y2)` | `Night.Math.GetAngle(float x1, float y1, float x2, float y2)` | `public static double GetAngle(float x1, float y1, float x2, float y2)` <br> Similar to `Math.Atan2(y2 - y1, x2 - x1)`. | Out of Scope (Use `System.Math`) | [ ] |
| `love.math.noise(x, y, z, w)`  | `Night.Math.Noise(double x, double? y = null, double? z = null, double? w = null)` | `public static double Noise(...)` <br> Simplex noise. | Out of Scope | [ ] |
| `love.math.random()`             | `(new System.Random()).NextDouble()` or `Night.Math.Random()` | `public static double Random()` <br> Returns [0, 1). | Out of Scope (Use `System.Random`) | [ ] |
| `love.math.random(max)`          | `(new System.Random()).Next(max + 1)` or `Night.Math.Random(int max)` | `public static int Random(int max)` <br> Returns [0, max]. Or `Next(1, max + 1)` for [1, max]. Love2D is [1,max] for integer. | Out of Scope (Use `System.Random`) | [ ] |
| `love.math.random(min, max)`     | `(new System.Random()).Next(min, max + 1)` or `Night.Math.Random(int min, int max)` | `public static int Random(int min, int max)` <br> Returns [min, max]. | Out of Scope (Use `System.Random`) | [ ] |
| `love.math.randomNormal(stddev, mean)` | `Night.Math.RandomNormal(double stdDev = 1.0, double mean = 0.0)` | `public static double RandomNormal(...)` <br> Normally distributed random number. | Out of Scope | [ ] |
| `love.math.setRandomSeed(seed)`  | `Night.Math.SetRandomSeed(int seed)` or `new System.Random(seed)` | `public static void SetRandomSeed(int seed)` <br> For a global `Night.Math` random generator. | Out of Scope (Use `System.Random` instance) | [ ] |
| `love.math.getRandomSeed()`      | `Night.Math.GetRandomSeed()`      | `public static (int seed, int? highSeed) GetRandomSeed()` | Out of Scope | [ ] |
| `love.math.getRandomState()`     | `Night.Math.GetRandomState()`     | `public static string GetRandomState()` | Out of Scope | [ ] |
| `love.math.setRandomState(state)`| `Night.Math.SetRandomState(string state)` | `public static void SetRandomState(string state)` | Out of Scope | [ ] |
| `love.math.newBezierCurve(points)` | `Night.Math.NewBezierCurve(Night.PointF[] controlPoints)` | `public static Night.BezierCurve NewBezierCurve(...)` | Out of Scope | [ ] |
| `love.math.newRandomGenerator()` | `Night.Math.NewRandomGenerator()` | `public static System.Random NewRandomGenerator()` or a custom `Night.RandomGenerator` class. | Out of Scope | [ ] |
| `love.math.gammaToLinear(c)`     | `Night.Math.GammaToLinear(double colorComponent)` | `public static double GammaToLinear(double colorComponent)` | Out of Scope | [ ] |
| `love.math.linearToGamma(c)`     | `Night.Math.LinearToGamma(double colorComponent)` | `public static double LinearToGamma(double colorComponent)` | Out of Scope | [ ] |

**Night Engine Specific Types (if module were implemented):**
*   `Night.PointF`: Struct for a 2D point with float coordinates.
*   `Night.BezierCurve`: Class representing a Bezier curve, with methods like `Evaluate(t)`, `GetDerivative(t)`.
*   `Night.RandomGenerator`: A class that might encapsulate `System.Random` or a custom PRNG, potentially with Love2D-compatible state management.



================================================
File: docs/love2d-api/mouse.md
================================================
# `love.mouse` Module API Mapping

This document maps the functions available in the `love.mouse` module of Love2D to their proposed equivalents in the Night Engine.

| Love2D Function (`love.mouse.`) | Night Engine API (`Night.Mouse.`) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|---------------------------------|-----------------------------------|---------------------------|--------------------------|------|
| `love.mouse.getX()`             | `Night.Mouse.GetX()`              | `public static int GetX()` | In Scope | [ ] |
| `love.mouse.getY()`             | `Night.Mouse.GetY()`              | `public static int GetY()` | In Scope | [ ] |
| `love.mouse.getPosition()`      | `Night.Mouse.GetPosition()`       | `public static (int x, int y) GetPosition()` | In Scope | [ ] |
| `love.mouse.isDown(button)`     | `Night.Mouse.IsDown(Night.MouseButton button)` | `public static bool IsDown(Night.MouseButton button)` <br> `Night.MouseButton` enum: `Left`, `Right`, `Middle`, `X1`, `X2`, etc. | In Scope | [ ] |
| `love.mouse.isVisible()`        | `Night.Mouse.IsVisible()`         | `public static bool IsVisible()` | In Scope | [ ] |
| `love.mouse.setX(x)`            | `Night.Mouse.SetX(int x)`         | `public static void SetX(int x)` <br> Warps mouse cursor. | In Scope (Low priority) | [ ] |
| `love.mouse.setY(y)`            | `Night.Mouse.SetY(int y)`         | `public static void SetY(int y)` <br> Warps mouse cursor. | In Scope (Low priority) | [ ] |
| `love.mouse.setPosition(x,y)`   | `Night.Mouse.SetPosition(int x, int y)` | `public static void SetPosition(int x, int y)` <br> Warps mouse cursor. | In Scope (Low priority) | [ ] |
| `love.mouse.setVisible(visible)`| `Night.Mouse.SetVisible(bool visible)` | `public static void SetVisible(bool visible)` | In Scope | [ ] |
| `love.mouse.setGrabbed(grab)`   | `Night.Mouse.SetGrabbed(bool grabbed)` | `public static void SetGrabbed(bool grabbed)` <br> Confines cursor to window. | In Scope (Low priority) | [ ] |
| `love.mouse.isGrabbed()`        | `Night.Mouse.IsGrabbed()`         | `public static bool IsGrabbed()` | In Scope (Low priority) | [ ] |
| `love.mouse.getRelativeMode()`  | `Night.Mouse.GetRelativeMode()`   | `public static bool GetRelativeMode()` | In Scope (Low priority, for FPS-style input) | [ ] |
| `love.mouse.setRelativeMode(enable)` | `Night.Mouse.SetRelativeMode(bool enable)` | `public static void SetRelativeMode(bool enable)` | In Scope (Low priority) | [ ] |
| `love.mouse.getCursor()`        | `Night.Mouse.GetCursor()`         | `public static Night.Cursor GetCursor()` <br> `Night.Cursor` would be a custom cursor object. | Out of Scope | [ ] |
| `love.mouse.setCursor(cursor)`  | `Night.Mouse.SetCursor(Night.Cursor? cursor = null)` | `public static void SetCursor(Night.Cursor? cursor = null)` <br> `null` for default system cursor. | Out of Scope | [ ] |
| `love.mouse.newCursor(imagedata, hotx, hoty)` | `Night.Mouse.NewCursor(Night.ImageData imageData, int hotSpotX, int hotSpotY)` | `public static Night.Cursor NewCursor(...)` | Out of Scope | [ ] |
| `love.mouse.getSystemCursor(ctype)` | `Night.Mouse.GetSystemCursor(Night.SystemCursorType type)` | `public static Night.Cursor GetSystemCursor(Night.SystemCursorType type)` <br> `SystemCursorType` enum: `Arrow`, `IBeam`, `Crosshair`, etc. | Out of Scope | [ ] |

**Night Engine Specific Types:**
*   `Night.MouseButton`: Enum representing mouse buttons (e.g., `Left`, `Right`, `Middle`, `X1`, `X2`).
*   `Night.Cursor`: Represents a mouse cursor (custom or system).
*   `Night.ImageData`: Wrapper for image data, likely from `Night.Image` module.
*   `Night.SystemCursorType`: Enum for standard system cursors.



================================================
File: docs/love2d-api/physics.md
================================================
# `love.physics` Module API Mapping

This document maps the functions available in the `love.physics` module of Love2D to their proposed equivalents in the Night Engine. This entire module is **Out of Scope** for the initial prototype.

| Love2D Function (`love.physics.`) | Night Engine API (`Night.Physics.`) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|-----------------------------------|-------------------------------------|---------------------------|--------------------------|------|
| `love.physics.newWorld(xg, yg, sleep)` | `Night.Physics.NewWorld(float gravityX = 0, float gravityY = 0, bool allowSleep = true)` | `public static Night.World NewWorld(...)` | Out of Scope | [ ] |
| `love.physics.newBody(world, x, y, type)` | `(Night.World).NewBody(float x, float y, Night.BodyType type)` | `public Night.Body NewBody(...)` (Method on `World` instance) | Out of Scope | [ ] |
| `love.physics.newFixture(body, shape, density)` | `(Night.Body).NewFixture(Night.Shape shape, float density = 1.0f)` | `public Night.Fixture NewFixture(...)` (Method on `Body` instance) | Out of Scope | [ ] |
| `love.physics.newCircleShape(x, y, radius)` | `Night.Physics.NewCircleShape(float offsetX, float offsetY, float radius)` or `Night.Physics.NewCircleShape(float radius)` | `public static Night.CircleShape NewCircleShape(...)` | Out of Scope | [ ] |
| `love.physics.newRectangleShape(x, y, w, h, angle)` | `Night.Physics.NewRectangleShape(float offsetX, float offsetY, float width, float height, float angle = 0)` or `Night.Physics.NewRectangleShape(float width, float height)` | `public static Night.RectangleShape NewRectangleShape(...)` | Out of Scope | [ ] |
| `love.physics.newPolygonShape(...)` | `Night.Physics.NewPolygonShape(params Night.PointF[] vertices)` | `public static Night.PolygonShape NewPolygonShape(...)` | Out of Scope | [ ] |
| `love.physics.newEdgeShape(x1, y1, x2, y2)` | `Night.Physics.NewEdgeShape(float x1, float y1, float x2, float y2)` | `public static Night.EdgeShape NewEdgeShape(...)` | Out of Scope | [ ] |
| `love.physics.newChainShape(loop, ...)` | `Night.Physics.NewChainShape(bool loop, params Night.PointF[] vertices)` | `public static Night.ChainShape NewChainShape(...)` | Out of Scope | [ ] |
| `love.physics.newDistanceJoint(body1, body2, x1, y1, x2, y2, collideConnected)` | `Night.Physics.NewDistanceJoint(...)` | `public static Night.DistanceJoint NewDistanceJoint(...)` | Out of Scope | [ ] |
| `love.physics.newMouseJoint(body, x, y)` | `Night.Physics.NewMouseJoint(...)` | `public static Night.MouseJoint NewMouseJoint(...)` | Out of Scope | [ ] |
| `love.physics.newRevoluteJoint(...)` | `Night.Physics.NewRevoluteJoint(...)` | `public static Night.RevoluteJoint NewRevoluteJoint(...)` | Out of Scope | [ ] |
| `love.physics.newPrismaticJoint(...)` | `Night.Physics.NewPrismaticJoint(...)` | `public static Night.PrismaticJoint NewPrismaticJoint(...)` | Out of Scope | [ ] |
| `love.physics.newPulleyJoint(...)` | `Night.Physics.NewPulleyJoint(...)` | `public static Night.PulleyJoint NewPulleyJoint(...)` | Out of Scope | [ ] |
| `love.physics.newGearJoint(...)`   | `Night.Physics.NewGearJoint(...)`   | `public static Night.GearJoint NewGearJoint(...)` | Out of Scope | [ ] |
| `love.physics.newFrictionJoint(...)` | `Night.Physics.NewFrictionJoint(...)` | `public static Night.FrictionJoint NewFrictionJoint(...)` | Out of Scope | [ ] |
| `love.physics.newWeldJoint(...)`   | `Night.Physics.NewWeldJoint(...)`   | `public static Night.WeldJoint NewWeldJoint(...)` | Out of Scope | [ ] |
| `love.physics.newRopeJoint(...)`   | `Night.Physics.NewRopeJoint(...)`   | `public static Night.RopeJoint NewRopeJoint(...)` | Out of Scope | [ ] |
| `love.physics.newWheelJoint(...)`  | `Night.Physics.NewWheelJoint(...)`  | `public static Night.WheelJoint NewWheelJoint(...)` | Out of Scope | [ ] |
| `love.physics.newMotorJoint(...)`  | `Night.Physics.NewMotorJoint(...)`  | `public static Night.MotorJoint NewMotorJoint(...)` | Out of Scope | [ ] |
| `love.physics.getDistance(fixtureA, fixtureB)` | `Night.Physics.GetDistance(Night.Fixture fixtureA, Night.Fixture fixtureB)` | `public static (float distance, float xA, float yA, float xB, float yB) GetDistance(...)` | Out of Scope | [ ] |
| `love.physics.getMeter()`          | `Night.Physics.GetPixelsPerMeter()` | `public static float GetPixelsPerMeter()` (Love2D default is 30) | Out of Scope | [ ] |
| `love.physics.setMeter(scale)`     | `Night.Physics.SetPixelsPerMeter(float scale)` | `public static void SetPixelsPerMeter(float scale)` | Out of Scope | [ ] |
| `love.physics.setCallbacks(beginContact, endContact, preSolve, postSolve)` | `(Night.World).SetContactCallbacks(...)` | Methods on `World` instance. | Out of Scope | [ ] |
| `love.physics.getCallbacks()`      | `(Night.World).GetContactCallbacks()` | Methods on `World` instance. | Out of Scope | [ ] |

**Night Engine Specific Types (if module were implemented):**
*   `Night.World`: Represents the physics simulation world. Methods: `Update(dt)`, `DrawDebug()`, `RayCast()`, `QueryAABB()`.
*   `Night.Body`: Represents a rigid body. Methods: `ApplyForce()`, `GetPosition()`, `SetAngle()`, etc.
*   `Night.BodyType`: Enum (`Static`, `Kinematic`, `Dynamic`).
*   `Night.Fixture`: Attaches a shape to a body, defines material properties.
*   `Night.Shape`: Base class for collision shapes.
*   `Night.CircleShape`, `Night.RectangleShape`, `Night.PolygonShape`, `Night.EdgeShape`, `Night.ChainShape`: Specific shape types.
*   Various `Night.Joint` types: `DistanceJoint`, `MouseJoint`, etc.
*   `Night.PointF`: Struct for 2D float points.



================================================
File: docs/love2d-api/sound.md
================================================
# `love.sound` Module API Mapping

This document maps the functions available in the `love.sound` module of Love2D to their proposed equivalents in the Night Engine. This module is primarily for decoding sound data, which would be handled internally by `Night.Audio.NewSource` or `Night.Source` objects if the audio module were implemented. This entire module is **Out of Scope** for the initial prototype.

| Love2D Function (`love.sound.`) | Night Engine API (`Night.Sound` or `Night.Audio` internals) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|---------------------------------|-------------------------------------------------------------|---------------------------|--------------------------|------|
| `love.sound.newDecoder(filedata, bufferSize)` | `Night.Audio.NewDecoder(Night.FileData fileData, int bufferSize = 4096)` | `public static Night.Decoder NewDecoder(...)` <br> Creates a sound decoder. | Out of Scope | [ ] |
| `love.sound.newSoundData(samples, sampleRate, bitDepth, channels)` | `Night.Audio.NewSoundData(int samples, int sampleRate, int bitDepth, int channels)` or `Night.Audio.NewSoundData(byte[] rawPcmData, ...)` | `public static Night.SoundData NewSoundData(...)` <br> Creates raw sound data. | Out of Scope | [ ] |

**Functionality on `Night.Decoder` instances (if implemented):**
*   `decoder.GetBitDepth()`
*   `decoder.GetChannelCount()`
*   `decoder.GetDuration()`
*   `decoder.GetSampleRate()`
*   `decoder.Decode()` (returns a chunk of SoundData)
*   `decoder.Seek(offset)`

**Functionality on `Night.SoundData` instances (if implemented):**
*   `soundData.GetBitDepth()`
*   `soundData.GetChannelCount()`
*   `soundData.GetDuration()`
*   `soundData.GetSampleCount()`
*   `soundData.GetSampleRate()`
*   `soundData.GetSample(index)`
*   `soundData.SetSample(index, value)`
*   `soundData.Clone()`

**Night Engine Specific Types (if module were implemented):**
*   `Night.Decoder`: Represents an object that can decode audio from a stream or file data.
*   `Night.SoundData`: Represents raw PCM audio data in memory.
*   `Night.FileData`: Represents file data in memory (from `Night.Filesystem`).



================================================
File: docs/love2d-api/system.md
================================================
# `love.system` Module API Mapping

This document maps the functions available in the `love.system` module of Love2D to their proposed equivalents in the Night Engine. Most functions in this module are **Out of Scope** for the initial prototype. Standard .NET `System.Environment` or `System.Runtime.InteropServices.RuntimeInformation` can provide some of this.

| Love2D Function (`love.system.`) | Night Engine API (`Night.System` or `System` namespace) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|----------------------------------|---------------------------------------------------------|---------------------------|--------------------------|------|
| `love.system.getOS()`            | `Night.System.GetOSName()` or `System.Runtime.InteropServices.RuntimeInformation.OSDescription` | `public static string GetOSName()` | Out of Scope | [ ] |
| `love.system.getProcessorCount()`| `System.Environment.ProcessorCount` | `public static int GetProcessorCount()` (via `System.Environment`) | Out of Scope | [ ] |
| `love.system.getPowerInfo()`     | `Night.System.GetPowerInfo()`     | `public static Night.PowerInfo GetPowerInfo()` <br> `PowerInfo` class: `State` (enum), `SecondsLeft` (nullable int), `Percent` (nullable int). | Out of Scope | [ ] |
| `love.system.getClipboardText()` | `Night.System.GetClipboardText()` | `public static string GetClipboardText()` <br> Would need platform-specific implementation or a library. | Out of Scope | [ ] |
| `love.system.setClipboardText(text)` | `Night.System.SetClipboardText(string text)` | `public static void SetClipboardText(string text)` | Out of Scope | [ ] |
| `love.system.openURL(url)`       | `Night.System.OpenURL(string url)` or `System.Diagnostics.Process.Start()` | `public static bool OpenURL(string url)` <br> `Process.Start(new ProcessStartInfo(url) { UseShellExecute = true });` | Out of Scope | [ ] |
| `love.system.vibrate(seconds)`   | `Night.System.Vibrate(double seconds)` | `public static void Vibrate(double seconds)` <br> For mobile devices. | Out of Scope | [ ] |
| `love.system.getPreferredLocales()` | `Night.System.GetPreferredLocales()` | `public static string[] GetPreferredLocales()` <br> From `System.Globalization.CultureInfo.CurrentUICulture` etc. | Out of Scope | [ ] |

**Night Engine Specific Types (if module were implemented):**
*   `Night.PowerInfo`: Class/Struct with properties `State` (enum: `NoBattery`, `Charging`, `Charged`, `Draining`), `SecondsLeft` (nullable int), `Percent` (nullable int).



================================================
File: docs/love2d-api/thread.md
================================================
# `love.thread` Module API Mapping

This document maps the functions available in the `love.thread` module of Love2D to their proposed equivalents in the Night Engine. This entire module is **Out of Scope** for the initial prototype, as .NET provides comprehensive threading capabilities via `System.Threading`.

| Love2D Function (`love.thread.`) | Night Engine API (`Night.Thread` or `System.Threading`) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|----------------------------------|---------------------------------------------------------|---------------------------|--------------------------|------|
| `love.thread.newThread(filename)` or `love.thread.newThread(codestring)` | `Night.Thread.NewThread(string luaScriptPathOrCode)` or `new System.Threading.Thread(...)` | `public static Night.Thread NewThread(string luaScriptPathOrCode)` <br> Love2D threads run Lua code. Night Engine would use C# delegates/lambdas with `System.Threading.Thread` or `Task`. | Out of Scope | [ ] |
| `love.thread.getChannel(name)`   | `Night.Thread.GetChannel<T>(string name)` | `public static Night.Channel<T> GetChannel<T>(string name)` <br> Channels are for inter-thread communication. | Out of Scope | [ ] |
| `love.thread.newChannel()`       | `Night.Thread.NewChannel<T>()`    | `public static Night.Channel<T> NewChannel<T>()` | Out of Scope | [ ] |

**Functionality on `Night.Thread` instances (if implemented, wrapping `System.Threading.Thread`):**
*   `thread.Start()`
*   `thread.Wait()`
*   `thread.IsRunning()`
*   `thread.GetError()`

**Functionality on `Night.Channel<T>` instances (if implemented, similar to `System.Threading.Channels.Channel<T>`):**
*   `channel.Push(T value)`
*   `channel.Pop()` (non-blocking, returns nullable T)
*   `channel.Demand()` (blocking, returns T)
*   `channel.Peek()`
*   `channel.GetCount()`
*   `channel.HasRead(id)`
*   `channel.Clear()`
*   `channel.PerformAtomic(Func<bool> operation)`

**Night Engine Specific Types (if module were implemented):**
*   `Night.Thread`: A wrapper around `System.Threading.Thread` or `Task`, potentially with easier error handling or specific Love2D-like behaviors if Lua interop were a goal.
*   `Night.Channel<T>`: A thread-safe communication channel, similar to `System.Threading.Channels.Channel<T>`.



================================================
File: docs/love2d-api/timer.md
================================================
# `love.timer` Module API Mapping

This document maps the functions available in the `love.timer` module of Love2D to their proposed equivalents in the Night Engine. Most functions in this module are **Out of Scope** for the initial prototype.

| Love2D Function (`love.timer.`) | Night Engine API (`Night.Timer.`) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|---------------------------------|-----------------------------------|---------------------------|--------------------------|------|
| `love.timer.getDelta()`         | `Night.Timer.GetDeltaTime()`      | `public static double GetDeltaTime()` <br> Time since last frame. This is already provided to `MyGame.Update(deltaTime)`. This function would provide it on demand. | Out of Scope (Covered by `Update`'s `deltaTime`) | [ ] |
| `love.timer.getFPS()`           | `Night.Timer.GetFPS()`            | `public static int GetFPS()` <br> Current frames per second. | In Scope (Useful for debugging/display) | [ ] |
| `love.timer.getAverageDelta()`  | `Night.Timer.GetAverageDeltaTime()` | `public static double GetAverageDeltaTime()` <br> Average delta time over the last second. | Out of Scope | [ ] |
| `love.timer.getTime()`          | `Night.Timer.GetTime()`           | `public static double GetTime()` <br> Time since the game started, in seconds. | In Scope (Useful utility) | [ ] |
| `love.timer.sleep(s)`           | `Night.Timer.Sleep(double seconds)` | `public static void Sleep(double seconds)` <br> Pauses execution. | Out of Scope (Generally not recommended in game loops) | [ ] |
| `love.timer.step()`             | `Night.Timer.Step()`              | `public static double Step()` <br> Measures time between calls. Used internally by Love2D's default `love.run`. Night Engine will have its own internal timing. | Out of Scope (Engine internal) | [ ] |



================================================
File: docs/love2d-api/touch.md
================================================
# `love.touch` Module API Mapping

This document maps the functions available in the `love.touch` module of Love2D to their proposed equivalents in the Night Engine. This entire module is **Out of Scope** for the initial prototype. Touch event callbacks are noted in the `love` module mapping.

| Love2D Function (`love.touch.`) | Night Engine API (`Night.Touch.`) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|---------------------------------|-----------------------------------|---------------------------|--------------------------|------|
| `love.touch.getPosition(id)`    | `Night.Touch.GetPosition(long touchId)` | `public static (float x, float y) GetPosition(long touchId)` | Out of Scope | [ ] |
| `love.touch.getPressure(id)`    | `Night.Touch.GetPressure(long touchId)` | `public static float GetPressure(long touchId)` | Out of Scope | [ ] |
| `love.touch.getTouches()`       | `Night.Touch.GetActiveTouches()`  | `public static long[] GetActiveTouches()` <br> Returns IDs of currently active touches. | Out of Scope | [ ] |

**Night Engine Specific Types (if module were implemented):**
*   Touch events in `MyGame` would pass a `Night.TouchEventArgs` object containing `Id`, `X`, `Y`, `DeltaX`, `DeltaY`, `Pressure`.



================================================
File: docs/love2d-api/video.md
================================================
# `love.video` Module API Mapping

This document maps the functions available in the `love.video` module of Love2D to their proposed equivalents in the Night Engine. This entire module is **Out of Scope** for the initial prototype. The primary way to get a video object in Night Engine would be `Night.Graphics.NewVideo()`.

| Love2D Function (`love.video.`) | Night Engine API (`Night.Video` methods or `Night.Graphics`) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|---------------------------------|--------------------------------------------------------------|---------------------------|--------------------------|------|
| `love.video.newVideoStream(filename)` | `Night.Graphics.NewVideo(string filePath, Night.VideoOptions? options = null)` | `public static Night.Video NewVideo(...)` <br> This is the main entry point. `VideoStream` in Love2D is just `Video`. | Out of Scope | [ ] |

**Functionality on `Night.Video` instances (if implemented):**
*   `video.Play()`
*   `video.Pause()`
*   `video.Seek(offset)`
*   `video.Tell()` (get current playback time)
*   `video.GetSource()` (audio source associated with video)
*   `video.IsPlaying()`
*   `video.SetSync(audioSource)`
*   `video.GetWidth()`, `video.GetHeight()` (as an `IDrawable`)
*   `video.GetFilename()`
*   `video.GetFilter()`
*   `video.SetFilter(min, mag)`

**Night Engine Specific Types (if module were implemented):**
*   `Night.Video`: Represents a video object. It would be an `IDrawable` and might internally manage a `Night.Source` for audio. Created via `Night.Graphics.NewVideo()`.
*   `Night.VideoOptions`: Class for video loading options (e.g., `EnableAudio`).
*   `Night.Source`: Audio source from `Night.Audio` module.
*   `Night.FilterMode`: Enum (`Linear`, `Nearest`).



================================================
File: docs/love2d-api/window.md
================================================
# `love.window` Module API Mapping

This document maps the functions available in the `love.window` module of Love2D to their proposed equivalents in the Night Engine.

| Love2D Function (`love.window.`) | Night Engine API (`Night.Window.`) | Notes / C# Signature Idea | Status (Prototype Scope) | Done |
|----------------------------------|------------------------------------|---------------------------|--------------------------|------|
| `love.window.close()`            | `Night.Window.Close()`             | `public static void Close()` <br> Requests to close the window. The `MyGame.Quit()` callback will be invoked. | In Scope | [x] |
| `love.window.displaySleepEnabled()` | `Night.Window.IsDisplaySleepEnabled()` | `public static bool IsDisplaySleepEnabled()` | Out of Scope | [ ] |
| `love.window.fromPixels(px_x, px_y)` | `Night.Window.FromPixels(double pixelX, double pixelY)` | `public static (double x, double y) FromPixels(double pixelX, double pixelY)` <br> Converts pixel coordinates to density-independent units. | In Scope (if high DPI is handled) | [ ] |
| `love.window.getDesktopDimensions(displayindex)` | `Night.Window.GetDesktopDimensions(int displayIndex = 0)` | `public static (int width, int height) GetDesktopDimensions(int displayIndex = 0)` | In Scope (for default display) | [ ] |
| `love.window.getDimensions()`      | `Night.Window.GetDimensions()`     | `public static (int width, int height) GetDimensions()` | In Scope | [ ] |
| `love.window.getDisplayCount()`    | `Night.Window.GetDisplayCount()`   | `public static int GetDisplayCount()` | In Scope (for default display awareness) | [ ] |
| `love.window.getDisplayName(displayindex)` | `Night.Window.GetDisplayName(int displayIndex = 0)` | `public static string GetDisplayName(int displayIndex = 0)` | Out of Scope | [ ] |
| `love.window.getFullscreen()`      | `Night.Window.IsFullscreen()`      | `public static bool IsFullscreen()` <br> Returns true if fullscreen. Also need `Night.Window.GetFullscreenMode()` for type. | In Scope | [ ] |
| `love.window.getFullscreenModes(displayindex)` | `Night.Window.GetFullscreenModes(int displayIndex = 0)` | `public static Night.FullscreenMode[] GetFullscreenModes(int displayIndex = 0)` <br> `FullscreenMode` struct/class: `int Width, int Height, int RefreshRate`. | In Scope (for setting fullscreen) | [ ] |
| `love.window.getIcon()`            | `Night.Window.GetIcon()`           | `public static Night.ImageData GetIcon()` <br> `Night.ImageData` would be a wrapper. | Out of Scope | [ ] |
| `love.window.getMode()`            | `Night.Window.GetMode()`           | `public static (int width, int height, Night.WindowFlags flags) GetMode()` <br> `WindowFlags` would be a struct/class. | In Scope | [ ] |
| `love.window.getPixelDimensions()` | `Night.Window.GetPixelDimensions()` | `public static (int pixelWidth, int pixelHeight) GetPixelDimensions()` | In Scope (if high DPI is handled) | [ ] |
| `love.window.getPixelScale()`      | `Night.Window.GetPixelScale()`     | `public static double GetPixelScale()` | In Scope (if high DPI is handled) | [ ] |
| `love.window.getPosition()`        | `Night.Window.GetPosition()`       | `public static (int x, int y, int displayIndex) GetPosition()` | In Scope | [ ] |
| `love.window.getTitle()`           | `Night.Window.GetTitle()`          | `public static string GetTitle()` | In Scope | [ ] |
| `love.window.hasFocus()`           | `Night.Window.HasFocus()`          | `public static bool HasFocus()` | In Scope | [ ] |
| `love.window.hasMouseFocus()`      | `Night.Window.HasMouseFocus()`     | `public static bool HasMouseFocus()` | In Scope | [ ] |
| `love.window.isMaximized()`        | `Night.Window.IsMaximized()`       | `public static bool IsMaximized()` | In Scope | [ ] |
| `love.window.isMinimized()`        | `Night.Window.IsMinimized()`       | `public static bool IsMinimized()` | In Scope | [ ] |
| `love.window.isOpen()`             | `Night.Window.IsOpen()`            | `public static bool IsOpen()` <br> Checks if the window is open and the game should continue running. | In Scope | [x] |
| `love.window.isVisible()`          | `Night.Window.IsVisible()`         | `public static bool IsVisible()` | In Scope | [ ] |
| `love.window.maximize()`           | `Night.Window.Maximize()`          | `public static void Maximize()` | In Scope | [ ] |
| `love.window.minimize()`           | `Night.Window.Minimize()`          | `public static void Minimize()` | In Scope | [ ] |
| `love.window.requestAttention(continuous)` | `Night.Window.RequestAttention(bool continuous = false)` | `public static void RequestAttention(bool continuous = false)` | Out of Scope | [ ] |
| `love.window.restore()`            | `Night.Window.Restore()`           | `public static void Restore()` <br> Restores after minimize/maximize. | In Scope | [ ] |
| `love.window.setDisplaySleepEnabled(enable)` | `Night.Window.SetDisplaySleepEnabled(bool enable)` | `public static void SetDisplaySleepEnabled(bool enable)` | Out of Scope | [ ] |
| `love.window.setFullscreen(fullscreen, fstype)` | `Night.Window.SetFullscreen(bool fullscreen, Night.FullscreenType type = Night.FullscreenType.Desktop)` | `public static bool SetFullscreen(bool fullscreen, Night.FullscreenType type = Night.FullscreenType.Desktop)` <br> `FullscreenType` enum: `Desktop`, `Exclusive`. Returns success. | In Scope | [ ] |
| `love.window.setIcon(imagedata)`   | `Night.Window.SetIcon(Night.ImageData iconData)` | `public static bool SetIcon(Night.ImageData iconData)` | Out of Scope | [ ] |
| `love.window.setMode(width, height, flags)` | `Night.Window.SetMode(int width, int height, Night.WindowFlags? flags = null)` | `public static bool SetMode(int width, int height, Night.WindowFlags? flags = null)` <br> `flags` could include: `Fullscreen`, `Resizable`, `Borderless`, `VSync`, `MinMSAA`, `DepthBits`, `StencilBits`. Returns success. | In Scope | [x] |
| `love.window.setPosition(x, y, displayindex)` | `Night.Window.SetPosition(int x, int y, int displayIndex = -1)` | `public static void SetPosition(int x, int y, int displayIndex = -1)` <br> `displayIndex = -1` could mean current or primary. | In Scope | [ ] |
| `love.window.setTitle(title)`      | `Night.Window.SetTitle(string title)` | `public static void SetTitle(string title)` | In Scope | [x] |
| `love.window.toPixels(x, y)`       | `Night.Window.ToPixels(double x, double y)` | `public static (double pixelX, double pixelY) ToPixels(double x, double y)` <br> Converts density-independent units to pixel coordinates. | In Scope (if high DPI is handled) | [ ] |
| `love.window.updateMode(width, height, flags)` | `Night.Window.UpdateMode(int width, int height, Night.WindowFlags? flags = null)` | `public static bool UpdateMode(int width, int height, Night.WindowFlags? flags = null)` <br> Similar to `SetMode` but for an existing window. | In Scope | [ ] |
| `love.window.showMessageBox(title, message, type, attachtowindow)` | `Night.Window.ShowMessageBox(string title, string message, Night.MessageBoxType type = Night.MessageBoxType.Info, bool attachToWindow = true)` | `public static void ShowMessageBox(string title, string message, Night.MessageBoxType type = Night.MessageBoxType.Info, bool attachToWindow = true)` <br> `MessageBoxType` enum: `Info`, `Warning`, `Error`. | Out of Scope (Low priority) | [ ] |

**Night Engine Specific Types:**
*   `Night.WindowFlags`: A struct or class that might contain boolean properties like `Fullscreen`, `Resizable`, `Borderless`, `VSync`, and potentially integer values for `MinMSAA`, `DepthBits`, `StencilBits`.
*   `Night.FullscreenType`: Enum (`Desktop`, `Exclusive`).
*   `Night.FullscreenMode`: Struct/class (`int Width, int Height, int RefreshRate`).
*   `Night.ImageData`: Wrapper for image data, likely from `Night.Image` module.
*   `Night.MessageBoxType`: Enum (`Info`, `Warning`, `Error`).




================================================
File: scripts/update_sdl3.py
================================================
import requests
import zipfile
import os
import shutil
import json
import tempfile

OWNER = "nightconcept"
REPO = "build-sdl3"
ASSET_NAME = "sdl3-bundle.zip"
PREBUILT_DIR = os.path.join(os.path.dirname(__file__), "..", "lib", "SDL3-Prebuilt")
VERSION_FILE = os.path.join(PREBUILT_DIR, "version.txt")

# Ensure PREBUILT_DIR subdirectories exist
os.makedirs(os.path.join(PREBUILT_DIR, "lib64"), exist_ok=True)
os.makedirs(os.path.join(PREBUILT_DIR, "macos"), exist_ok=True)
os.makedirs(os.path.join(PREBUILT_DIR, "win64"), exist_ok=True)

def get_latest_release_info():
    """Fetches the latest release information from GitHub."""
    api_url = f"https://api.github.com/repos/{OWNER}/{REPO}/releases/latest"
    print(f"Fetching latest release info from {api_url}...")
    response = requests.get(api_url)
    response.raise_for_status()  # Raise an exception for HTTP errors
    release_data = response.json()
    return release_data

def find_asset_url(release_data, asset_name):
    """Finds the download URL for a specific asset in the release data."""
    for asset in release_data.get("assets", []):
        if asset["name"] == asset_name:
            return asset["browser_download_url"], release_data["tag_name"]
    return None, None

def download_file(url, dest_path):
    """Downloads a file from a URL to a destination path."""
    print(f"Downloading {url} to {dest_path}...")
    response = requests.get(url, stream=True)
    response.raise_for_status()
    with open(dest_path, "wb") as f:
        for chunk in response.iter_content(chunk_size=8192):
            f.write(chunk)
    print("Download complete.")

def extract_zip(zip_path, extract_to_path):
    """Extracts a zip file to a specified directory."""
    print(f"Extracting {zip_path} to {extract_to_path}...")
    with zipfile.ZipFile(zip_path, "r") as zip_ref:
        zip_ref.extractall(extract_to_path)
    print("Extraction complete.")

def update_prebuilt_files(extract_path):
    """Copies relevant files from the extracted bundle to the prebuilt directory."""
    print(f"Updating files in {PREBUILT_DIR}...")

    # Define source and destination mappings
    # Based on user feedback and image, the zip extracts platform folders directly.
    # Source structure (from zip, within extract_path):
    #   linux-x64/libSDL3.so.0  (Note: may also contain other files, we only need .so.0)
    #   macos/libSDL3.0.dylib
    #   win64/SDL3.dll
    #   android/... (ignored)
    #   ios/... (ignored)
    #
    # Destination structure (in PREBUILT_DIR):
    #   lib64/libSDL3.so.0
    #   macos/libSDL3.0.dylib
    #   win64/SDL3.dll

    # The `extract_path` is the root where 'linux-x64', 'macos', 'win64' folders are.

    mappings = {
        os.path.join(extract_path, "linux-x64", "libSDL3.so.0"): os.path.join(PREBUILT_DIR, "lib64", "libSDL3.so.0"),
        os.path.join(extract_path, "macos", "libSDL3.0.dylib"): os.path.join(PREBUILT_DIR, "macos", "libSDL3.0.dylib"),
        os.path.join(extract_path, "win64", "SDL3.dll"): os.path.join(PREBUILT_DIR, "win64", "SDL3.dll"),
    }

    for src, dest in mappings.items():
        if os.path.exists(src):
            # Ensure destination directory exists
            os.makedirs(os.path.dirname(dest), exist_ok=True)
            shutil.copy2(src, dest)
            print(f"Copied {src} to {dest}")
        else:
            print(f"Warning: Source file {src} not found in extracted bundle.")

    print("File update complete.")

def update_version_file(version_tag):
    """Updates the version.txt file with the new version tag."""
    print(f"Updating {VERSION_FILE} to version {version_tag}...")
    with open(VERSION_FILE, "w") as f:
        f.write(version_tag.lstrip('v')) # Remove 'v' prefix if present
    print("Version file updated.")

def main():
    try:
        release_data = get_latest_release_info()
        asset_url, version_tag = find_asset_url(release_data, ASSET_NAME)

        if not asset_url:
            print(f"Error: Could not find asset '{ASSET_NAME}' in the latest release.")
            return

        print(f"Found asset: {asset_url} (Version: {version_tag})")

        with tempfile.TemporaryDirectory() as tmpdir:
            zip_path = os.path.join(tmpdir, ASSET_NAME)

            download_file(asset_url, zip_path)

            extract_target_path = os.path.join(tmpdir, "extracted_sdl3")
            os.makedirs(extract_target_path, exist_ok=True)
            extract_zip(zip_path, extract_target_path)

            update_prebuilt_files(extract_target_path)
            update_version_file(version_tag)

        print("SDL3 update process completed successfully.")

    except requests.exceptions.RequestException as e:
        print(f"Error during network request: {e}")
    except zipfile.BadZipFile:
        print("Error: Downloaded file is not a valid zip file or is corrupted.")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")

if __name__ == "__main__":
    main()



================================================
File: src/Night.Engine/FrameworkLoop.cs
================================================
using System;
using System.Runtime.InteropServices;

using Night.Types;

using static SDL3.SDL;

// Namespace for the public Framework API, consistent with Night.Window, Night.Graphics etc.
namespace Night
{
  /// <summary>
  /// Manages the main game loop and coordination of game states.
  /// Provides the main entry point to run a game.
  /// </summary>
  public static class Framework
  {
    /// <summary>
    /// A flag indicating whether the core SDL systems, particularly for input,
    /// have been successfully initialized.
    /// </summary>
    public static bool IsInputInitialized { get; private set; } = false;

    /// <summary>
    /// Runs the game instance.
    /// The game loop will internally call Load, Update, and Draw methods
    /// on the provided game type.
    /// </summary>
    /// <typeparam name="TGame">The type of the game to run.
    /// Must implement <see cref="Night.Types.IGame"/> and have a parameterless constructor.</typeparam>
    public static void Run<TGame>() where TGame : IGame, new()
    {
      // It's good practice to ensure SDL is initialized before using its functions.
      // Night.Window.SetMode handles SDL_InitSubSystem(SDL_INIT_VIDEO).
      // If other subsystems are needed by the engine globally, they should be initialized.
      // SDL_Init(SDL_InitFlags.SDL_INIT_EVENTS) might be useful here if not handled by Window.
      // However, SDL_PollEvent will work if the video subsystem (which often initializes events) is up.

      var sdlVersionPacked = SDL_GetVersion();
      Console.WriteLine($"Night Engine: v0.0.1"); // Placeholder version
      Console.WriteLine($"SDL: v{sdlVersionPacked / 1000000}.{(sdlVersionPacked / 1000) % 1000}.{sdlVersionPacked % 1000}");
      Console.WriteLine($"Platform: {RuntimeInformation.OSDescription} ({RuntimeInformation.OSArchitecture})");
      Console.WriteLine($"Framework: {RuntimeInformation.FrameworkDescription}");

      // Engine.Run expects Night.Window.SetMode to have been called by the application (e.g., in Program.cs)
      // *before* Engine.Run is invoked.

      TGame game = new TGame();
      game.Load();

      ulong perfFrequency = SDL_GetPerformanceFrequency();
      ulong lastCounter = SDL_GetPerformanceCounter();

      // Ensure the window is open before starting the loop.
      // Night.Window.SetMode should have been called by the user application before Engine.Run.
      if (!Window.IsOpen())
      {
        Console.WriteLine("Night.Engine.Run: Window is not open. Ensure Night.Window.SetMode() was called successfully before Run().");
        // Potentially call SDL_Quit() here if Engine.Run was responsible for a global SDL_Init.
        return;
      }

      // At this point, Window.IsOpen() is true, implying SetMode was successful
      // and SDL_INIT_VIDEO (which includes SDL_INIT_EVENTS) has been initialized.
      IsInputInitialized = true;

      while (Window.IsOpen())
      {
        // Event Processing
        // SDL_PollEvent returns SDLBool, which is true if an event was pending, false otherwise.
        while (SDL_PollEvent(out SDL_Event e))
        {
          // e.type is SDL_EventType, which is an enum with underlying type uint.
          // Using an if statement to avoid C# compiler issues with uint-backed enums in switch.
          // Explicitly cast both sides to uint for comparison.
          if ((uint)e.type == (uint)SDL_EventType.SDL_EVENT_QUIT)
          {
            Window.Close();
          }
          // Other event handling (keyboard, mouse) will be added in later tasks/epics.
          // else if (e.type == SDL_EventType.SDL_EVENT_KEY_DOWN) { /* ... */ }
        }

        // If Window.Close() was called due to an event, IsOpen() will now be false,
        // and the outer loop should terminate.
        if (!Window.IsOpen())
        {
          break;
        }

        // Calculate DeltaTime
        ulong currentCounter = SDL_GetPerformanceCounter();
        double deltaTime = (double)(currentCounter - lastCounter) / perfFrequency;
        lastCounter = currentCounter;

        // Clamp deltaTime to avoid large jumps if debugging or system lags
        // A common practice, though the max value can be debated (e.g., 1/15th of a second)
        if (deltaTime > 0.0666) // Approx 15 FPS
        {
          deltaTime = 0.0666;
        }


        game.Update(deltaTime);
        game.Draw();

        try
        {
          // Graphics.Present might not be implemented yet, but the call should be here.
          Graphics.Present();
        }
        catch (NotImplementedException)
        {
          // Silently ignore if Graphics.Present is not yet implemented.
          // Or log once: Console.WriteLine("Night.Graphics.Present() is not yet implemented.");
        }
        catch (Exception ex)
        {
          Console.WriteLine($"Error during Graphics.Present(): {ex.Message}");
          // Potentially break loop or handle more gracefully
        }

        // A small delay can be added here if vsync is not enabled or to reduce CPU usage,
        // but typically vsync (via renderer flags in SetMode) is preferred.
        // SDL_Delay(1); // e.g., 1ms delay
      }

      // TODO: Call game.Unload() if it's added to IGame.
      // TODO: Ensure proper SDL cleanup (SDL_Quit()), perhaps in a dedicated Engine.Shutdown()
      // or if Engine.Run is the outermost layer that also did SDL_Init().
      // For now, if Window.SetMode did SDL_InitSubSystem, a corresponding QuitSubSystem might be needed.
      // SDL_Quit(); // This would be too broad if other parts of app still use SDL.
    }
  }
}



================================================
File: src/Night.Engine/Night.Engine.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <LangVersion>13.0</LangVersion>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\lib\SDL3-CS\SDL3\SDL3.Core.csproj" />
  </ItemGroup>

</Project>



================================================
File: src/Night.Engine/Types.cs
================================================
// Copyright (c) 2025 Night Engine Contributors
// Distributed under the MIT license. See LICENSE for details.

// Night Engine Data Structures

namespace Night.Types
{
  /// <summary>
  /// Represents keyboard keys. Values correspond to SDL_Scancode.
  /// </summary>
  /// <remarks>
  /// See SDL_scancode.h for the full list of SDL_Scancode values.
  /// This enum maps directly to SDL_Scancode values.
  /// </remarks>
  public enum KeyCode
  {
    Unknown = 0, // SDL_SCANCODE_UNKNOWN

    // Letters
    A = 4,  // SDL_SCANCODE_A
    B = 5,  // SDL_SCANCODE_B
    C = 6,  // SDL_SCANCODE_C
    D = 7,  // SDL_SCANCODE_D
    E = 8,  // SDL_SCANCODE_E
    F = 9,  // SDL_SCANCODE_F
    G = 10, // SDL_SCANCODE_G
    H = 11, // SDL_SCANCODE_H
    I = 12, // SDL_SCANCODE_I
    J = 13, // SDL_SCANCODE_J
    K = 14, // SDL_SCANCODE_K
    L = 15, // SDL_SCANCODE_L
    M = 16, // SDL_SCANCODE_M
    N = 17, // SDL_SCANCODE_N
    O = 18, // SDL_SCANCODE_O
    P = 19, // SDL_SCANCODE_P
    Q = 20, // SDL_SCANCODE_Q
    R = 21, // SDL_SCANCODE_R
    S = 22, // SDL_SCANCODE_S
    T = 23, // SDL_SCANCODE_T
    U = 24, // SDL_SCANCODE_U
    V = 25, // SDL_SCANCODE_V
    W = 26, // SDL_SCANCODE_W
    X = 27, // SDL_SCANCODE_X
    Y = 28, // SDL_SCANCODE_Y
    Z = 29, // SDL_SCANCODE_Z

    // Numbers (Top row)
    Num1 = 30, // SDL_SCANCODE_1
    Num2 = 31, // SDL_SCANCODE_2
    Num3 = 32, // SDL_SCANCODE_3
    Num4 = 33, // SDL_SCANCODE_4
    Num5 = 34, // SDL_SCANCODE_5
    Num6 = 35, // SDL_SCANCODE_6
    Num7 = 36, // SDL_SCANCODE_7
    Num8 = 37, // SDL_SCANCODE_8
    Num9 = 38, // SDL_SCANCODE_9
    Num0 = 39, // SDL_SCANCODE_0

    // Control keys
    Enter = 40,       // SDL_SCANCODE_RETURN
    Escape = 41,      // SDL_SCANCODE_ESCAPE
    Backspace = 42,   // SDL_SCANCODE_BACKSPACE
    Tab = 43,         // SDL_SCANCODE_TAB
    Space = 44,       // SDL_SCANCODE_SPACE
    Minus = 45,       // SDL_SCANCODE_MINUS
    Equals = 46,      // SDL_SCANCODE_EQUALS
    LeftBracket = 47, // SDL_SCANCODE_LEFTBRACKET
    RightBracket = 48,// SDL_SCANCODE_RIGHTBRACKET
    Backslash = 49,   // SDL_SCANCODE_BACKSLASH (Might be #~ for UK keyboards)
    NonUsHash = 50,   // SDL_SCANCODE_NONUSHASH (#~ for Non-US keyboards)
    Semicolon = 51,   // SDL_SCANCODE_SEMICOLON
    Apostrophe = 52,  // SDL_SCANCODE_APOSTROPHE
    Grave = 53,       // SDL_SCANCODE_GRAVE (Accent grave `)
    Comma = 54,       // SDL_SCANCODE_COMMA
    Period = 55,      // SDL_SCANCODE_PERIOD
    Slash = 56,       // SDL_SCANCODE_SLASH
    CapsLock = 57,    // SDL_SCANCODE_CAPSLOCK

    // Function keys
    F1 = 58,  // SDL_SCANCODE_F1
    F2 = 59,  // SDL_SCANCODE_F2
    F3 = 60,  // SDL_SCANCODE_F3
    F4 = 61,  // SDL_SCANCODE_F4
    F5 = 62,  // SDL_SCANCODE_F5
    F6 = 63,  // SDL_SCANCODE_F6
    F7 = 64,  // SDL_SCANCODE_F7
    F8 = 65,  // SDL_SCANCODE_F8
    F9 = 66,  // SDL_SCANCODE_F9
    F10 = 67, // SDL_SCANCODE_F10
    F11 = 68, // SDL_SCANCODE_F11
    F12 = 69, // SDL_SCANCODE_F12

    PrintScreen = 70, // SDL_SCANCODE_PRINTSCREEN
    ScrollLock = 71,  // SDL_SCANCODE_SCROLLLOCK
    Pause = 72,       // SDL_SCANCODE_PAUSE
    Insert = 73,      // SDL_SCANCODE_INSERT
    Home = 74,        // SDL_SCANCODE_HOME
    PageUp = 75,      // SDL_SCANCODE_PAGEUP
    Delete = 76,      // SDL_SCANCODE_DELETE
    End = 77,         // SDL_SCANCODE_END
    PageDown = 78,    // SDL_SCANCODE_PAGEDOWN

    // Arrow keys
    Right = 79, // SDL_SCANCODE_RIGHT
    Left = 80,  // SDL_SCANCODE_LEFT
    Down = 81,  // SDL_SCANCODE_DOWN
    Up = 82,    // SDL_SCANCODE_UP

    NumLockClear = 83, // SDL_SCANCODE_NUMLOCKCLEAR

    // Keypad
    KpDivide = 84,   // SDL_SCANCODE_KP_DIVIDE
    KpMultiply = 85, // SDL_SCANCODE_KP_MULTIPLY
    KpMinus = 86,    // SDL_SCANCODE_KP_MINUS
    KpPlus = 87,     // SDL_SCANCODE_KP_PLUS
    KpEnter = 88,    // SDL_SCANCODE_KP_ENTER
    Kp1 = 89,        // SDL_SCANCODE_KP_1
    Kp2 = 90,        // SDL_SCANCODE_KP_2
    Kp3 = 91,        // SDL_SCANCODE_KP_3
    Kp4 = 92,        // SDL_SCANCODE_KP_4
    Kp5 = 93,        // SDL_SCANCODE_KP_5
    Kp6 = 94,        // SDL_SCANCODE_KP_6
    Kp7 = 95,        // SDL_SCANCODE_KP_7
    Kp8 = 96,        // SDL_SCANCODE_KP_8
    Kp9 = 97,        // SDL_SCANCODE_KP_9
    Kp0 = 98,        // SDL_SCANCODE_KP_0
    KpPeriod = 99,   // SDL_SCANCODE_KP_PERIOD

    NonUsBackslash = 100, // SDL_SCANCODE_NONUSBACKSLASH
    Application = 101,    // SDL_SCANCODE_APPLICATION (Context Menu Key)
    Power = 102,          // SDL_SCANCODE_POWER

    KpEquals = 103, // SDL_SCANCODE_KP_EQUALS
    F13 = 104,      // SDL_SCANCODE_F13
    F14 = 105,      // SDL_SCANCODE_F14
    F15 = 106,      // SDL_SCANCODE_F15
    F16 = 107,      // SDL_SCANCODE_F16
    F17 = 108,      // SDL_SCANCODE_F17
    F18 = 109,      // SDL_SCANCODE_F18
    F19 = 110,      // SDL_SCANCODE_F19
    F20 = 111,      // SDL_SCANCODE_F20
    F21 = 112,      // SDL_SCANCODE_F21
    F22 = 113,      // SDL_SCANCODE_F22
    F23 = 114,      // SDL_SCANCODE_F23
    F24 = 115,      // SDL_SCANCODE_F24

    Execute = 116, // SDL_SCANCODE_EXECUTE
    Help = 117,    // SDL_SCANCODE_HELP
    Menu = 118,    // SDL_SCANCODE_MENU
    Select = 119,  // SDL_SCANCODE_SELECT
    Stop = 120,    // SDL_SCANCODE_STOP
    Again = 121,   // SDL_SCANCODE_AGAIN
    Undo = 122,    // SDL_SCANCODE_UNDO
    Cut = 123,     // SDL_SCANCODE_CUT
    Copy = 124,    // SDL_SCANCODE_COPY
    Paste = 125,   // SDL_SCANCODE_PASTE
    Find = 126,    // SDL_SCANCODE_FIND
    Mute = 127,    // SDL_SCANCODE_MUTE
    VolumeUp = 128,   // SDL_SCANCODE_VOLUMEUP
    VolumeDown = 129, // SDL_SCANCODE_VOLUMEDOWN

    // Skipping some less common international and special keys for brevity,
    // but they can be added if needed by referring to SDL_Scancode.

    KpComma = 133, // SDL_SCANCODE_KP_COMMA

    // Modifier keys
    LeftCtrl = 224,   // SDL_SCANCODE_LCTRL
    LeftShift = 225,  // SDL_SCANCODE_LSHIFT
    LeftAlt = 226,    // SDL_SCANCODE_LALT (Option key on Mac)
    LeftSuper = 227,  // SDL_SCANCODE_LGUI (Windows key, Command key)
    RightCtrl = 228,  // SDL_SCANCODE_RCTRL
    RightShift = 229, // SDL_SCANCODE_RSHIFT
    RightAlt = 230,   // SDL_SCANCODE_RALT (Option key on Mac, Alt Gr)
    RightSuper = 231, // SDL_SCANCODE_RGUI (Windows key, Command key)

    Mode = 257, // SDL_SCANCODE_MODE (AltGr, Multi_key)

    // Media keys (subset)
    MediaPlay = 262,        // SDL_SCANCODE_MEDIA_PLAY
    MediaPause = 263,       // SDL_SCANCODE_MEDIA_PAUSE
    MediaRecord = 264,      // SDL_SCANCODE_MEDIA_RECORD
    MediaFastForward = 265, // SDL_SCANCODE_MEDIA_FAST_FORWARD
    MediaRewind = 266,      // SDL_SCANCODE_MEDIA_REWIND
    MediaNextTrack = 267,   // SDL_SCANCODE_MEDIA_NEXT_TRACK
    MediaPreviousTrack = 268, // SDL_SCANCODE_MEDIA_PREVIOUS_TRACK
    MediaStop = 269,        // SDL_SCANCODE_MEDIA_STOP
    MediaEject = 270,       // SDL_SCANCODE_MEDIA_EJECT
    MediaPlayPause = 271,   // SDL_SCANCODE_MEDIA_PLAY_PAUSE
    MediaSelect = 272,      // SDL_SCANCODE_MEDIA_SELECT

    // Application control keys (subset)
    AppSearch = 280,     // SDL_SCANCODE_AC_SEARCH
    AppHome = 281,       // SDL_SCANCODE_AC_HOME
    AppBack = 282,       // SDL_SCANCODE_AC_BACK
    AppForward = 283,    // SDL_SCANCODE_AC_FORWARD
    AppStop = 284,       // SDL_SCANCODE_AC_STOP
    AppRefresh = 285,    // SDL_SCANCODE_AC_REFRESH
    AppBookmarks = 286,  // SDL_SCANCODE_AC_BOOKMARKS

    // Total number of scancodes. Not a key itself.
    // SDL_SCANCODE_COUNT = 512
  }

  /// <summary>
  /// Represents mouse buttons.
  /// </summary>
  public enum MouseButton
  {
    Unknown,
    Left,
    Middle,
    Right,
    X1, // Typically the first extra mouse button (e.g., "back")
    X2  // Typically the second extra mouse button (e.g., "forward")
  }

  /// <summary>
  /// Represents a color with Red, Green, Blue, and Alpha components.
  /// </summary>
  public struct Color
  {
    public byte R;
    public byte G;
    public byte B;
    public byte A;

    public Color(byte r, byte g, byte b, byte a = 255)
    {
      R = r;
      G = g;
      B = b;
      A = a;
    }

    // Common color presets
    public static readonly Color Black = new(0, 0, 0);
    public static readonly Color White = new(255, 255, 255);
    public static readonly Color Red = new(255, 0, 0);
    public static readonly Color Green = new(0, 255, 0);
    public static readonly Color Blue = new(0, 0, 255);
    public static readonly Color Yellow = new(255, 255, 0);
    public static readonly Color Magenta = new(255, 0, 255);
    public static readonly Color Cyan = new(0, 255, 255);
    public static readonly Color Transparent = new(0, 0, 0, 0);
  }

  /// <summary>
  /// Represents a rectangle with position (X, Y) and dimensions (Width, Height).
  /// </summary>
  public struct Rectangle
  {
    public int X;
    public int Y;
    public int Width;
    public int Height;

    public Rectangle(int x, int y, int width, int height)
    {
      X = x;
      Y = y;
      Width = width;
      Height = height;
    }
  }

  /// <summary>
  /// Specifies window creation flags. Values correspond to SDL_WindowFlags.
  /// </summary>
  /// <remarks>
  /// See SDL_video.h for the full list of SDL_WindowFlags.
  /// </remarks>
  [System.Flags]
  public enum WindowFlags : uint
  {
    None = 0,
    Fullscreen = 0x00000001U,    // SDL_WINDOW_FULLSCREEN
    OpenGL = 0x00000002U,        // SDL_WINDOW_OPENGL
    Shown = 0x00000004U,         // SDL_WINDOW_SHOWN
    Hidden = 0x00000008U,        // SDL_WINDOW_HIDDEN
    Borderless = 0x00000010U,    // SDL_WINDOW_BORDERLESS
    Resizable = 0x00000020U,     // SDL_WINDOW_RESIZABLE
    Minimized = 0x00000040U,     // SDL_WINDOW_MINIMIZED
    Maximized = 0x00000080U,     // SDL_WINDOW_MAXIMIZED
                                 // MouseGrabbed = 0x00000100U, // SDL_WINDOW_MOUSE_GRABBED (Consider if needed for Night API)
                                 // InputFocus = 0x00000200U,   // SDL_WINDOW_INPUT_FOCUS (Managed by SDL)
                                 // MouseFocus = 0x00000400U,   // SDL_WINDOW_MOUSE_FOCUS (Managed by SDL)
    HighDpi = 0x00002000U,       // SDL_WINDOW_HIGH_PIXEL_DENSITY
                                 // MouseCapture = 0x00004000U, // SDL_WINDOW_MOUSE_CAPTURE (Consider if needed for Night API)
                                 // AlwaysOnTop = 0x00008000U,  // SDL_WINDOW_ALWAYS_ON_TOP (Consider if useful)
    Vulkan = 0x10000000U,        // SDL_WINDOW_VULKAN
    Metal = 0x20000000U,         // SDL_WINDOW_METAL
                                 // Transparent = 0x40000000U, // SDL_WINDOW_TRANSPARENT (Consider if useful)
                                 // NotFocusable = 0x80000000U // SDL_WINDOW_NOT_FOCUSABLE (Consider if useful)
  }

  /// <summary>
  /// Represents a 2D sprite.
  /// </summary>
  /// <remarks>
  /// This is a placeholder structure. It will be expanded in Epic 5.
  /// It might include texture references, source rectangles, etc.
  /// </remarks>
  public class Sprite
  {
    // Placeholder for texture identifier (e.g., an IntPtr or a managed object)
    // internal object? _textureHandle; // Example, to be refined

    // Placeholder for dimensions, if not derived from texture
    // public int Width { get; internal set; }
    // public int Height { get; internal set; }

    // Placeholder for source rectangle within a texture atlas
    // public Rectangle? SourceRectangle { get; internal set; }

    /// <summary>
    /// Initializes a new instance of the <see cref="Sprite"/> class.
    /// </summary>
    /// <remarks>
    /// Constructor is internal or protected if creation is managed by the engine.
    /// For now, public for flexibility during early prototyping.
    /// </remarks>
    public Sprite()
    {
      // Initialization logic will be added in Epic 5.
    }
  }

  /// <summary>
  /// Interface for a game that can be run by the Night Engine.
  /// Game developers will implement this interface in their main game class.
  /// </summary>
  public interface IGame
  {
    /// <summary>
    /// Called once when the game starts, for loading resources.
    /// </summary>
    void Load();

    /// <summary>
    /// Called repeatedly every frame, for updating game logic.
    /// </summary>
    /// <param name="deltaTime">The time elapsed since the last frame, in seconds.</param>
    void Update(double deltaTime);

    /// <summary>
    /// Called repeatedly every frame, for drawing the game state.
    /// </summary>
    void Draw();

    // Optional input handlers can be added here later as per PRD Feature 4.
    // For example:
    // void KeyPressed(KeyCode key, bool isRepeat);
    // void MousePressed(int x, int y, MouseButton button, int presses);
  }
}



================================================
File: src/Night.Engine/Modules/Graphics.cs
================================================
using System;

using Night.Types; // For Color, Sprite

namespace Night;

/// <summary>
/// Provides functionality for drawing graphics.
/// Mimics Love2D's love.graphics module.
/// </summary>
public static class Graphics
{
  /// <summary>
  /// Creates a new image (Sprite) from a file.
  /// </summary>
  /// <param name="filePath">The path to the image file.</param>
  /// <returns>A new Sprite object.</returns>
  public static Sprite NewImage(string filePath)
  {
    throw new NotImplementedException();
  }

  /// <summary>
  /// Draws a sprite to the screen.
  /// </summary>
  /// <param name="sprite">The sprite to draw.</param>
  /// <param name="x">The x-coordinate to draw the sprite at.</param>
  /// <param name="y">The y-coordinate to draw the sprite at.</param>
  /// <param name="rotation">The rotation of the sprite (in radians).</param>
  /// <param name="scaleX">The horizontal scale factor.</param>
  /// <param name="scaleY">The vertical scale factor.</param>
  /// <param name="offsetX">The x-offset for the sprite's origin.</param>
  /// <param name="offsetY">The y-offset for the sprite's origin.</param>
  public static void Draw(
      Sprite sprite,
      float x,
      float y,
      float rotation = 0,
      float scaleX = 1,
      float scaleY = 1,
      float offsetX = 0,
      float offsetY = 0)
  {
    throw new NotImplementedException();
  }

  /// <summary>
  /// Clears the screen to a specific color.
  /// </summary>
  /// <param name="color">The color to clear the screen with.</param>
  public static void Clear(Color color)
  {
    throw new NotImplementedException();
  }

  /// <summary>
  /// Presents the drawn graphics to the screen (swaps buffers).
  /// </summary>
  public static void Present()
  {
    throw new NotImplementedException();
  }
}



================================================
File: src/Night.Engine/Modules/Keyboard.cs
================================================
using System;
using System.Runtime.InteropServices; // For Marshal

using Night.Types; // For KeyCode

using static SDL3.SDL; // For direct access to SDL functions

namespace Night;

/// <summary>
/// Provides functionality for handling keyboard input.
/// Mimics Love2D's love.keyboard module.
/// </summary>
public static class Keyboard
{
  // TODO: Task 4.4 - Create a comprehensive mapping for all KeyCodes.
  private static SDL_Scancode MapKeyCodeToScancode(KeyCode key)
  {
    switch (key)
    {
      // Letters
      case KeyCode.A: return SDL_Scancode.SDL_SCANCODE_A;
      case KeyCode.B: return SDL_Scancode.SDL_SCANCODE_B;
      case KeyCode.C: return SDL_Scancode.SDL_SCANCODE_C;
      case KeyCode.D: return SDL_Scancode.SDL_SCANCODE_D;
      case KeyCode.E: return SDL_Scancode.SDL_SCANCODE_E;
      case KeyCode.F: return SDL_Scancode.SDL_SCANCODE_F;
      case KeyCode.G: return SDL_Scancode.SDL_SCANCODE_G;
      case KeyCode.H: return SDL_Scancode.SDL_SCANCODE_H;
      case KeyCode.I: return SDL_Scancode.SDL_SCANCODE_I;
      case KeyCode.J: return SDL_Scancode.SDL_SCANCODE_J;
      case KeyCode.K: return SDL_Scancode.SDL_SCANCODE_K;
      case KeyCode.L: return SDL_Scancode.SDL_SCANCODE_L;
      case KeyCode.M: return SDL_Scancode.SDL_SCANCODE_M;
      case KeyCode.N: return SDL_Scancode.SDL_SCANCODE_N;
      case KeyCode.O: return SDL_Scancode.SDL_SCANCODE_O;
      case KeyCode.P: return SDL_Scancode.SDL_SCANCODE_P;
      case KeyCode.Q: return SDL_Scancode.SDL_SCANCODE_Q;
      case KeyCode.R: return SDL_Scancode.SDL_SCANCODE_R;
      case KeyCode.S: return SDL_Scancode.SDL_SCANCODE_S;
      case KeyCode.T: return SDL_Scancode.SDL_SCANCODE_T;
      case KeyCode.U: return SDL_Scancode.SDL_SCANCODE_U;
      case KeyCode.V: return SDL_Scancode.SDL_SCANCODE_V;
      case KeyCode.W: return SDL_Scancode.SDL_SCANCODE_W;
      case KeyCode.X: return SDL_Scancode.SDL_SCANCODE_X;
      case KeyCode.Y: return SDL_Scancode.SDL_SCANCODE_Y;
      case KeyCode.Z: return SDL_Scancode.SDL_SCANCODE_Z;

      // Numbers
      case KeyCode.Num0: return SDL_Scancode.SDL_SCANCODE_0;
      case KeyCode.Num1: return SDL_Scancode.SDL_SCANCODE_1;
      case KeyCode.Num2: return SDL_Scancode.SDL_SCANCODE_2;
      case KeyCode.Num3: return SDL_Scancode.SDL_SCANCODE_3;
      case KeyCode.Num4: return SDL_Scancode.SDL_SCANCODE_4;
      case KeyCode.Num5: return SDL_Scancode.SDL_SCANCODE_5;
      case KeyCode.Num6: return SDL_Scancode.SDL_SCANCODE_6;
      case KeyCode.Num7: return SDL_Scancode.SDL_SCANCODE_7;
      case KeyCode.Num8: return SDL_Scancode.SDL_SCANCODE_8;
      case KeyCode.Num9: return SDL_Scancode.SDL_SCANCODE_9;

      // Function keys
      case KeyCode.F1: return SDL_Scancode.SDL_SCANCODE_F1;
      case KeyCode.F2: return SDL_Scancode.SDL_SCANCODE_F2;
      case KeyCode.F3: return SDL_Scancode.SDL_SCANCODE_F3;
      case KeyCode.F4: return SDL_Scancode.SDL_SCANCODE_F4;
      case KeyCode.F5: return SDL_Scancode.SDL_SCANCODE_F5;
      case KeyCode.F6: return SDL_Scancode.SDL_SCANCODE_F6;
      case KeyCode.F7: return SDL_Scancode.SDL_SCANCODE_F7;
      case KeyCode.F8: return SDL_Scancode.SDL_SCANCODE_F8;
      case KeyCode.F9: return SDL_Scancode.SDL_SCANCODE_F9;
      case KeyCode.F10: return SDL_Scancode.SDL_SCANCODE_F10;
      case KeyCode.F11: return SDL_Scancode.SDL_SCANCODE_F11;
      case KeyCode.F12: return SDL_Scancode.SDL_SCANCODE_F12;

      // Control keys
      case KeyCode.LeftShift: return SDL_Scancode.SDL_SCANCODE_LSHIFT;
      case KeyCode.RightShift: return SDL_Scancode.SDL_SCANCODE_RSHIFT;
      case KeyCode.LeftCtrl: return SDL_Scancode.SDL_SCANCODE_LCTRL;
      case KeyCode.RightCtrl: return SDL_Scancode.SDL_SCANCODE_RCTRL;
      case KeyCode.LeftAlt: return SDL_Scancode.SDL_SCANCODE_LALT;
      case KeyCode.RightAlt: return SDL_Scancode.SDL_SCANCODE_RALT;
      case KeyCode.LeftSuper: return SDL_Scancode.SDL_SCANCODE_LGUI; // GUI key often maps to Super/Windows/Command
      case KeyCode.RightSuper: return SDL_Scancode.SDL_SCANCODE_RGUI;
      case KeyCode.Enter: return SDL_Scancode.SDL_SCANCODE_RETURN;
      case KeyCode.Escape: return SDL_Scancode.SDL_SCANCODE_ESCAPE;
      case KeyCode.Space: return SDL_Scancode.SDL_SCANCODE_SPACE;
      case KeyCode.Tab: return SDL_Scancode.SDL_SCANCODE_TAB;
      case KeyCode.Backspace: return SDL_Scancode.SDL_SCANCODE_BACKSPACE;
      case KeyCode.Delete: return SDL_Scancode.SDL_SCANCODE_DELETE;
      case KeyCode.Insert: return SDL_Scancode.SDL_SCANCODE_INSERT;
      case KeyCode.Home: return SDL_Scancode.SDL_SCANCODE_HOME;
      case KeyCode.End: return SDL_Scancode.SDL_SCANCODE_END;
      case KeyCode.PageUp: return SDL_Scancode.SDL_SCANCODE_PAGEUP;
      case KeyCode.PageDown: return SDL_Scancode.SDL_SCANCODE_PAGEDOWN;

      // Arrow keys
      case KeyCode.Up: return SDL_Scancode.SDL_SCANCODE_UP;
      case KeyCode.Down: return SDL_Scancode.SDL_SCANCODE_DOWN;
      case KeyCode.Left: return SDL_Scancode.SDL_SCANCODE_LEFT;
      case KeyCode.Right: return SDL_Scancode.SDL_SCANCODE_RIGHT;

      case KeyCode.Unknown:
      default:
        return SDL_Scancode.SDL_SCANCODE_UNKNOWN;
    }
  }

  /// <summary>
  /// Checks if a specific key is currently pressed down.
  /// </summary>
  /// <param name="key">The key to check.</param>
  /// <returns>True if the key is down, false otherwise.</returns>
  public static bool IsDown(KeyCode key)
  {
    if (!Framework.IsInputInitialized)
    {
      Console.WriteLine("Warning: Night.Keyboard.IsDown called before input system is initialized. Returning false.");
      return false;
    }

    // The SDL_PumpEvents function should be called in the main event loop
    // to update the keyboard state. Assuming Engine.Run() handles this.

    nint keyboardStatePtr = SDL_GetKeyboardState(out int numKeys);

    if (keyboardStatePtr == nint.Zero)
    {
      // This case should ideally not happen if SDL is initialized correctly.
      // Log a warning or handle as per engine's error strategy.
      Console.WriteLine("Warning: SDL_GetKeyboardState returned a null pointer.");
      return false;
    }

    SDL_Scancode sdlScancode = MapKeyCodeToScancode(key);

    if (sdlScancode == SDL_Scancode.SDL_SCANCODE_UNKNOWN)
    {
      return false; // Unknown or unmapped key
    }

    // Ensure scancode is within bounds. numKeys represents the number of scancodes.
    if ((int)sdlScancode >= numKeys)
    {
      Console.WriteLine($"Warning: Scancode {(int)sdlScancode} is out of bounds (numKeys: {numKeys}).");
      return false;
    }

    // The array is indexed by SDL_Scancode values.
    // SDL_GetKeyboardState returns a pointer to an array of Uint8.
    // A value of 1 means pressed, 0 means not pressed.
    byte byteKeyState = Marshal.ReadByte(keyboardStatePtr, (int)sdlScancode);
    return byteKeyState == 1;
  }
}



================================================
File: src/Night.Engine/Modules/Mouse.cs
================================================
using System;

using Night.Types; // For MouseButton

using static SDL3.SDL; // For direct access to SDL functions

namespace Night;

/// <summary>
/// Provides functionality for handling mouse input.
/// Mimics Love2D's love.mouse module.
/// </summary>
public static class Mouse
{
  /// <summary>
  /// Checks if a specific mouse button is currently pressed down.
  /// </summary>
  /// <param name="button">The mouse button to check.</param>
  /// <returns>True if the button is down, false otherwise.</returns>
  public static bool IsDown(MouseButton button)
  {
    if (!Framework.IsInputInitialized)
    {
      Console.WriteLine("Warning: Night.Mouse.IsDown called before input system is initialized. Returning false.");
      return false;
    }

    SDL_MouseButtonFlags mouseState = SDL_GetMouseState(out float _, out float _);

    SDL_MouseButtonFlags buttonMask;
    switch (button)
    {
      case MouseButton.Left:
        buttonMask = SDL_MouseButtonFlags.SDL_BUTTON_LMASK;
        break;
      case MouseButton.Middle:
        buttonMask = SDL_MouseButtonFlags.SDL_BUTTON_MMASK;
        break;
      case MouseButton.Right:
        buttonMask = SDL_MouseButtonFlags.SDL_BUTTON_RMASK;
        break;
      case MouseButton.X1:
        buttonMask = SDL_MouseButtonFlags.SDL_BUTTON_X1MASK;
        break;
      case MouseButton.X2:
        buttonMask = SDL_MouseButtonFlags.SDL_BUTTON_X2MASK;
        break;
      case MouseButton.Unknown:
      default:
        return false; // Unknown or unmapped button
    }

    return (mouseState & buttonMask) != 0;
  }

  /// <summary>
  /// Gets the current position of the mouse cursor.
  /// </summary>
  /// <returns>A tuple (int x, int y) representing the mouse coordinates.</returns>
  public static (int x, int y) GetPosition()
  {
    if (!Framework.IsInputInitialized)
    {
      Console.WriteLine("Warning: Night.Mouse.GetPosition called before input system is initialized. Returning (0,0).");
      return (0, 0);
    }

    float mouseX, mouseY;
    SDL_GetMouseState(out mouseX, out mouseY); // This SDL3-CS function returns uint for button state, but we only need x, y
    return ((int)mouseX, (int)mouseY);
  }
}



================================================
File: src/Night.Engine/Modules/SDL.cs
================================================
using System;

// No 'using static SDL3.SDL;' here as SDL3.SDL members are fully qualified.
// No 'using Night.Types;' as no Night.Types are used in this specific class.

namespace Night;

/// <summary>
/// Provides direct access to SDL3 functions using SDL3-CS bindings.
/// This is an internal-facing or low-level API for the engine.
/// </summary>
public static class SDL
{
  /// <summary>
  /// Initializes the SDL library. This must be called before any other SDL functions.
  /// </summary>
  /// <param name="flags">Initialization flags for SDL.</param>
  /// <returns>0 on success or a negative error code on failure.</returns>
  public static int Init(SDL3.SDL.SDL_InitFlags flags)
  {
    // SDL3.SDL.SDL_Init returns an SDLBool, which implicitly converts to bool.
    // We convert this to 0 for success, <0 for failure.
    return SDL3.SDL.SDL_Init(flags) ? 0 : -1;
  }

  /// <summary>
  /// Cleans up all initialized subsystems. You should call this function on application exit.
  /// </summary>
  public static void Quit()
  {
    SDL3.SDL.SDL_Quit();
  }

  /// <summary>
  /// Gets the version of SDL that is linked against.
  /// The SDL3-CS binding for SDL_GetVersion returns a packed int.
  /// </summary>
  /// <returns>A string representing the SDL version "major.minor.patch".</returns>
  public static string GetVersion()
  {
    int sdl_version = SDL3.SDL.SDL_GetVersion();
    int major = sdl_version / 1000000;
    int minor = (sdl_version / 1000) % 1000;
    int patch = sdl_version % 1000;
    return $"{major}.{minor}.{patch}";
  }

  // Expose SDL_InitFlags enum for convenience if needed by calling code for Init()
  public static SDL3.SDL.SDL_InitFlags InitVideo => SDL3.SDL.SDL_InitFlags.SDL_INIT_VIDEO;
  public static SDL3.SDL.SDL_InitFlags InitAudio => SDL3.SDL.SDL_InitFlags.SDL_INIT_AUDIO;
  public static SDL3.SDL.SDL_InitFlags InitTimer => SDL3.SDL.SDL_InitFlags.SDL_INIT_TIMER;
  public static SDL3.SDL.SDL_InitFlags InitEvents => SDL3.SDL.SDL_InitFlags.SDL_INIT_EVENTS;
  // Add other flags as needed or expect the caller to use SDL3.SDL.SDL_InitFlags directly.
}



================================================
File: src/Night.Engine/Modules/Window.cs
================================================
using System;

using Night.Types;

using static SDL3.SDL; // For direct access to SDL functions

namespace Night;

/// <summary>
/// Provides functionality for managing the application window.
/// Mimics Love2D's love.window module.
/// </summary>
public static class Window
{
  private static nint _window = nint.Zero;
  private static nint _renderer = nint.Zero;
  private static bool _isVideoInitialized = false;
  private static bool _isWindowOpen = false; // Added for IsOpen()

  /// <summary>
  /// Sets the display mode of the window.
  /// </summary>
  /// <param name="width">The width of the window.</param>
  /// <param name="height">The height of the window.</param>
  /// <param name="flags">Window flags to apply.</param>
  public static void SetMode(int width, int height, WindowFlags flags)
  {
    if (!_isVideoInitialized)
    {
      if (!SDL_InitSubSystem(SDL_InitFlags.SDL_INIT_VIDEO)) // Corrected: SDLBool check
      {
        string sdlError = SDL_GetError();
        Console.WriteLine($"Error initializing SDL video subsystem: {sdlError}");
        throw new Exception($"SDL Error initializing video subsystem: {sdlError}");
      }
      _isVideoInitialized = true;
    }

    // If a window already exists, destroy it before creating a new one
    if (_window != nint.Zero)
    {
      if (_renderer != nint.Zero)
      {
        SDL_DestroyRenderer(_renderer);
        _renderer = nint.Zero;
      }
      SDL_DestroyWindow(_window);
      _window = nint.Zero;
      _isWindowOpen = false; // Window closed
    }

    SDL_WindowFlags sdlFlags = (SDL_WindowFlags)flags;

    _window = SDL_CreateWindow("Night Engine", width, height, sdlFlags);
    if (_window == nint.Zero)
    {
      string sdlError = SDL_GetError();
      Console.WriteLine($"Error creating SDL window: {sdlError}");
      _isWindowOpen = false; // Window creation failed
      throw new Exception($"SDL Error creating window: {sdlError}");
    }

    // Create a renderer. Passing null for the name lets SDL choose the best available driver.
    // Hardware acceleration is generally preferred and often default.
    // VSync (PRESENTVSYNC) would typically be set via renderer properties in SDL3 if not default.
    // For simplicity in this step, we use the basic SDL_CreateRenderer.
    _renderer = SDL_CreateRenderer(_window, null);
    if (_renderer == nint.Zero)
    {
      string sdlError = SDL_GetError();
      Console.WriteLine($"Error creating SDL renderer: {sdlError}");
      // Clean up window if renderer creation fails
      SDL_DestroyWindow(_window);
      _window = nint.Zero;
      _isWindowOpen = false; // Renderer creation failed, so window is not usable
      throw new Exception($"SDL Error creating renderer: {sdlError}");
    }
    _isWindowOpen = true; // Window and renderer successfully created
  }

  /// <summary>
  /// Sets the title of the window.
  /// </summary>
  /// <param name="title">The new window title.</param>
  public static void SetTitle(string title)
  {
    if (_window == nint.Zero)
    {
      string errorMsg = "Error in Night.Window.SetTitle: Window handle is null. Was SetMode called successfully?";
      Console.WriteLine(errorMsg);
      throw new InvalidOperationException(errorMsg);
    }
    if (!SDL_SetWindowTitle(_window, title))
    {
      string sdlError = SDL_GetError();
      Console.WriteLine($"Error in Night.Window.SetTitle: {sdlError}");
      throw new Exception($"SDL Error in Night.Window.SetTitle: {sdlError}");
    }
  }

  /// <summary>
  /// Checks if the window is currently open.
  /// </summary>
  /// <returns>True if the window is open, false otherwise.</returns>
  public static bool IsOpen()
  {
    return _isWindowOpen && _window != nint.Zero;
  }

  /// <summary>
  /// Signals that the window should close.
  /// This is typically called by the engine when a quit event is received.
  /// </summary>
  public static void Close()
  {
    _isWindowOpen = false;
    // Actual window destruction is handled by SetMode re-call or application exit for now.
    // Or could be SDL_DestroyWindow(_window); _window = nint.Zero; if Engine.Run doesn't own it.
  }
}





================================================
File: src/Night.SampleGame/Night.SampleGame.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <LangVersion>13.0</LangVersion>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\Night.Engine\Night.Engine.csproj" />
  </ItemGroup>

  <ItemGroup>
    <Content Include="..\..\lib\SDL3-Prebuilt\win64\SDL3.dll" Condition="$([MSBuild]::IsOSPlatform('Windows'))">
      <Link>SDL3.dll</Link>
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
    <Content Include="..\..\lib\SDL3-Prebuilt\macos\libSDL3.0.dylib" Condition="$([MSBuild]::IsOSPlatform('OSX'))">
      <Link>libSDL3.dylib</Link>
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
    <Content Include="..\..\lib\SDL3-Prebuilt\lib64\libSDL3.so.0" Condition="$([MSBuild]::IsOSPlatform('Linux'))">
      <Link>libSDL3.so.0</Link>
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
  </ItemGroup>

</Project>



================================================
File: src/Night.SampleGame/Program.cs
================================================
﻿using Night.Types;

namespace Night.SampleGame;

public class Game : IGame
{
  // Fields to store the previous state of keys for change detection
  private bool _wasSpaceDown = false;
  private bool _wasADown = false;
  private bool _wasEscapeDown = false;

  // Fields to store the previous state of mouse buttons for change detection
  private bool _wasLeftMouseDown = false;
  private bool _wasRightMouseDown = false;
  private bool _wasMiddleMouseDown = false;

  public void Load()
  {
    // Placeholder for loading game assets and initial setup
    Night.Window.SetMode(800, 600, WindowFlags.Shown | WindowFlags.Resizable);
    Night.Window.SetTitle("Night Sample Game");
  }

  public void Update(double deltaTime)
  {
    // Placeholder for game logic updates
    // System.Console.WriteLine($"SampleGame: Update, DeltaTime: {deltaTime}");

    // Test for Space key state change
    bool isSpaceCurrentlyDown = Night.Keyboard.IsDown(Night.Types.KeyCode.Space);
    if (isSpaceCurrentlyDown && !_wasSpaceDown)
    {
      System.Console.WriteLine("Key Pressed: Space");
    }
    else if (!isSpaceCurrentlyDown && _wasSpaceDown)
    {
      System.Console.WriteLine("Key Released: Space");
    }
    _wasSpaceDown = isSpaceCurrentlyDown;

    // Test for A key state change
    bool isACurrentlyDown = Night.Keyboard.IsDown(Night.Types.KeyCode.A);
    if (isACurrentlyDown && !_wasADown)
    {
      System.Console.WriteLine("Key Pressed: A");
    }
    else if (!isACurrentlyDown && _wasADown)
    {
      System.Console.WriteLine("Key Released: A");
    }
    _wasADown = isACurrentlyDown;

    // Test for Escape key state change
    bool isEscapeCurrentlyDown = Night.Keyboard.IsDown(Night.Types.KeyCode.Escape);
    if (isEscapeCurrentlyDown && !_wasEscapeDown)
    {
      System.Console.WriteLine("Key Pressed: Escape. (Consider closing window)");
      // Example of how it might be used to close on press:
      // Night.Window.Close();
    }
    else if (!isEscapeCurrentlyDown && _wasEscapeDown)
    {
      System.Console.WriteLine("Key Released: Escape");
    }
    _wasEscapeDown = isEscapeCurrentlyDown;

    // Test for Left Mouse Button state change
    bool isLeftMouseCurrentlyDown = Night.Mouse.IsDown(Night.Types.MouseButton.Left);
    if (isLeftMouseCurrentlyDown && !_wasLeftMouseDown)
    {
      System.Console.WriteLine("Mouse Button Pressed: Left");
    }
    else if (!isLeftMouseCurrentlyDown && _wasLeftMouseDown)
    {
      System.Console.WriteLine("Mouse Button Released: Left");
    }
    _wasLeftMouseDown = isLeftMouseCurrentlyDown;

    // Test for Right Mouse Button state change
    bool isRightMouseCurrentlyDown = Night.Mouse.IsDown(Night.Types.MouseButton.Right);
    if (isRightMouseCurrentlyDown && !_wasRightMouseDown)
    {
      System.Console.WriteLine("Mouse Button Pressed: Right");
    }
    else if (!isRightMouseCurrentlyDown && _wasRightMouseDown)
    {
      System.Console.WriteLine("Mouse Button Released: Right");
    }
    _wasRightMouseDown = isRightMouseCurrentlyDown;

    // Test for Middle Mouse Button state change
    bool isMiddleMouseCurrentlyDown = Night.Mouse.IsDown(Night.Types.MouseButton.Middle);
    if (isMiddleMouseCurrentlyDown && !_wasMiddleMouseDown)
    {
      System.Console.WriteLine("Mouse Button Pressed: Middle");
    }
    else if (!isMiddleMouseCurrentlyDown && _wasMiddleMouseDown)
    {
      System.Console.WriteLine("Mouse Button Released: Middle");
    }
    _wasMiddleMouseDown = isMiddleMouseCurrentlyDown;

    // Test Mouse Position
    (int mouseX, int mouseY) = Night.Mouse.GetPosition();
    System.Console.WriteLine($"Mouse Position: ({mouseX}, {mouseY})");
  }

  public void Draw()
  {
    // Placeholder for drawing game elements
    // System.Console.WriteLine("SampleGame: Draw");
  }
}

public class Program
{
  public static void Main()
  {
    Night.Framework.Run<Game>();
  }
}






================================================
File: .github/CODEOWNERS
================================================
# This is a CODEOWNERS file.
#
# Lines starting with '#' are comments.
# Each line is a file pattern followed by one or more owners.
# These patterns follow the same rules as .gitignore.
#
# Owners can be:
# - A GitHub username (e.g., @octocat)
# - A GitHub team name (e.g., @my-org/my-team)
# - An email address (e.g., user@example.com)
#
# Order matters: the last matching pattern takes the most precedence.
#
# Example:
# *       @global-owner1 @global-owner2  # All files are owned by these users/teams
# *.js    @js-owner                      # .js files are owned by @js-owner
# /docs/  docs@example.com               # Files in the /docs/ directory are owned by docs@example.com

# All files in the repository are owned by nightconcept
* @nightconcept dark@nightconcept.net

# You can add more specific rules below if needed.
# For example, if different parts of the project have different owners:
#
# /cmd/      @nightconcept
# /internal/ @nightconcept
# /scripts/  dark@nightconcept.net



================================================
File: .github/copilot-instructions.md
================================================
# AI Project Guidelines (Condensed)

**Objective:** Define mandatory process, coding, testing, and interaction standards for AI assistance.

## 1. Preparation

* **Project Context (Session Start):** ALWAYS review key project docs: `docs/PRD.md` (architecture, goals, tech stack, versions, structure, style guide), `docs/digest.txt` (current state summary), `docs/TASKS.md` (assignments).
* **Task Prep (Before Work):**
    * ALWAYS consult `docs/TASKS.md` for your assignment. If missing, add it (concise description, `YYYY-MM-DD`).
    * ALWAYS review relevant existing code *before* suggesting changes.

## 2. Implementation Planning

**Present this plan before providing code for a task:**

* Problem description (brief).
* Solution overview (high-level).
* Implementation steps (list).
* Risks/Challenges (foreseen).

## 3. Development Workflow

* **Plan First:** Present plan (Sec 2) before coding.
* **Focus:** Target the specific task from `TASKS.md`. No unrelated refactoring unless tasked.
* **Modification Approach:**
    * Prioritize minimal, incremental, clean, elegant, idiomatic changes.
    * Explain significant suggestions (Sec 5.4).
    * Propose beneficial low-risk refactoring.
    * Avoid duplication; use helpers/modules.
    * Explain use of language strengths/pitfalls if relevant.
* **Dependencies:** No new/updated external dependencies without explicit maintainer approval (check `docs/PRD.md` for approved stack/versions). Use only approved dependencies.
* **Commits (User Task):** Follow Conventional Commits (`https://www.conventionalcommits.org/en/v1.0.0/`).
* **Manual Testing:** Provide clear user instructions for manually testing the task's changes.

## 4. Folder Structure

* **Strict Adherence:** Follow structure defined in `docs/PRD.md`.
* **Changes:** No adding/removing/relocating files/dirs without prior maintainer approval. Approved structure changes require updating `docs/PRD.md` *before* implementation.
* **Source Location:** All source code must be in `src/`.
* **Precedence:** This rule is foundational.

## 5. Coding Standards

### 5.1. General & Robustness

* Follow language best practices unless overridden by `docs/PRD.md` or these guidelines.
* Prioritize: Clarity, maintainability, efficiency.
* Consider performance & basic security.
* Implement robust error handling (language norms or `PRD.md` spec); handle errors gracefully.

### 5.2. Modularity & Structure

* Keep files focused (ideally < 500 lines); refactor large ones.
* Prefer small, single-purpose functions.
* Structure code logically (per `docs/PRD.md`) into modules.
* Use clear, consistent imports (relative for local packages). Verify paths.

### 5.3. Style & Formatting

* **Priority:** 1) `docs/PRD.md`, 2) These rules, 3) Language common practices.
* **Type Hinting:** Mandatory for functions/classes/modules (dynamic languages).
* **Indentation:** 2 spaces.
* **Function Calls:** No space: `func()` not `func ()`.
* **Line Structure:** Avoid collapsing statements if clarity suffers.
* **Scope:** Default local. More descriptive names for wider scope. Avoid single-letter vars (except iterators/tiny scope; `i` only for loops). Use `_` for ignored vars.
* **Casing:** Match current file style; else language common style. `UPPER_CASE` for constants only.
* **Booleans:** Prefer `is_` prefix for boolean functions.
* **File Headers:** Top comment: Title (descriptive, not filename) + brief purpose. No version/OS info.

### 5.4. Documentation & Comments

* **Docstrings:** Required for public functions, classes, modules (standard format).
* **Code Comments:** Explain non-obvious logic, complex algorithms, decisions (*why*, not *what*).
* **Reasoning Comments:** Use `# Reason:` for complex block rationale.
* **README Updates:** Update `docs/README.md` for core features, dependency changes, or setup/build modifications.

## 6. Testing

* **Goal:** Tests are living documentation specifying behavior. Use common language framework.
* **Behavior Specification:** Tests specify behavior. Type/scope/timing (e.g., E2E, Unit, Integration) defined in `docs/PRD.md` per project phase.
* **Location:** Place tests in `/src/test` (Lua: `/src/spec`), mirroring `src/` structure (Sec 4).
    * Ex: Tests for `src/engine/mod.js` -> `src/test/engine/mod_test.js`.
    * Ex: Lua spec for `src/engine/mod.lua` -> `src/spec/engine/mod_spec.lua`.
* **Content:** Tests clearly describe expected behavior per `PRD.md` goals for the current phase.
    * **Prototype Phase:** Primary focus on automated E2E tests validating core functionality.
* **Strategy & Coverage:** Defined in `PRD.md`, evolves with phases.
    * **Prototype Phase:** E2E priority. Comprehensive unit tests & code coverage metrics (e.g., 100% statement coverage) are **not** the focus *unless* specified in `docs/PRD.md` for a later phase demanding them.
* **Updating Tests:** Review/update tests with code changes to reflect *current* expected behavior. Fix failing/outdated tests promptly.

## 7. AI Interaction Protocols

### 7.1. Engineering Role & Audience

* **Role:** Act as a **Senior Software Engineer**.
* **Audience:** Target **Mid-Level Software Engineers** (code = best practices, clear, documented; explanations thorough; justify complex choices).

### 7.2. Interaction Guidelines

* Ask clarifying questions if needed; do not assume.
* Verify facts (libs, APIs, file paths); do not invent. Use MCP servers if available.
* Do not delete/overwrite code unless instructed or part of the defined task.
* Report significant blockers/errors *during* implementation promptly with context and suggestions.
* If a task seems complex, state potential benefit from a more advanced model **boldly** at the start (e.g., "**Suggestion: This complex refactoring might benefit from a more advanced model.**").
* Be friendly, helpful, collaborative.
* Explicitly state when task requirements are met. Mark task complete in `docs/TASKS.md`.



================================================
File: .github/dependabot.yml
================================================
version: 2
updates:
  - package-ecosystem: "github-actions"
    directory: "/"
    schedule:
      # Check for updates to GitHub Actions every week
      interval: "weekly"



================================================
File: .github/deactivated/build-sdl3.yml
================================================
name: Build Night.Platform + SDL3

on:
  workflow_dispatch:
  push:
    branches:
      - 'main'
    paths:
      - 'Platform/**'
      - '!Platform/libs/**'
  pull_request:
    paths:
      - 'Platform/**'
      - '!Platform/libs/**'
jobs:
  Build:
    strategy:
      matrix:
        include:
          - os: windows-latest
            arch: x64
            target: win-x64
            ext: .dll
          - os: macos-latest
            arch: x64-arm64
            target: osx
            ext: .dylib
          - os: ubuntu-latest
            arch: x64
            target: linux-x64
            ext: .so
    runs-on: ${{matrix.os}}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Get CMake
        uses: lukka/get-cmake@v3.29.4
      - name: Setup Linux dependencies
        if: ${{ runner.os == 'Linux' }}
        run: |
          sudo apt-get update
          sudo apt-get install build-essential git make \
            pkg-config cmake ninja-build gnome-desktop-testing libasound2-dev libpulse-dev \
            libaudio-dev libjack-dev libsndio-dev libx11-dev libxext-dev \
            libxrandr-dev libxcursor-dev libxfixes-dev libxi-dev libxss-dev \
            libxkbcommon-dev libdrm-dev libgbm-dev libgl1-mesa-dev libgles2-mesa-dev \
            libegl1-mesa-dev libdbus-1-dev libibus-1.0-dev libudev-dev fcitx-libs-dev
      - name: CMake Configure
        run: cmake -B build -S Platform -DNIGHT_OVERRIDE_TARGET=${{matrix.target}} -D CMAKE_SYSTEM_VERSION=10.0.26100.0
      - name: CMake Build
        run: cmake --build build --config Release
      - name: Publish Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{matrix.os}}-${{matrix.arch}}-build
          path: Platform/libs/${{matrix.target}}/*${{matrix.ext}}*
  UpdateLibs:
    if: github.ref == 'refs/heads/main'
    needs: [Build]
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Download windows x64 libs
        uses: actions/download-artifact@v4
        with:
          name: windows-latest-x64-build
          path: Platform/libs/win-x64
      - name: Download macos libs
        uses: actions/download-artifact@v4
        with:
          name: macos-latest-x64-arm64-build
          path: Platform/libs/osx
      - name: Download ubuntu libs
        uses: actions/download-artifact@v4
        with:
          name: ubuntu-latest-x64-build
          path: Platform/libs/linux-x64
      - name: Display structure of libs
        run: ls -R
        working-directory: Platform/libs
      - name: Commit changes
        uses: EndBug/add-and-commit@v9.1.3
        with:
          message: Updated platform libs
          committer_name: GitHub Actions
          committer_email: actions@github.com



================================================
File: .github/deactivated/ci.yml
================================================
name: Go CI
permissions:
  contents: read
  security-events: write

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    name: Test on Go ${{ matrix.go-version }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        go-version: [ '1.24' ]
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
        with:
          egress-policy: audit

      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 2

      - name: Set up Go
        uses: actions/setup-go@d35c59abb061a4a6fb18e82ac0862c26744d6ab5 # v5.5.0
        with:
          go-version: ${{ matrix.go-version }}

      - name: Install Go tools
        run: |
          go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
          go install github.com/mattn/goveralls@latest

      - name: Download Go modules
        run: |
          go mod download
          go mod verify

      - name: Run govulncheck
        uses: golang/govulncheck-action@b625fbe08f3bccbe446d94fbf87fcc875a4f50ee # v1.0.4

      - name: Lint source
        run: golangci-lint run ./...

      - name: Run tests with coverage
        run: go test -v ./... -race -coverprofile=coverage.out -covermode=atomic

      - name: Upload coverage to Coveralls
        if: matrix.go-version == '1.24' # Only upload from one Go version
        env:
          COVERALLS_TOKEN: ${{ secrets.COVERALLS_REPO_TOKEN }}
        run: |
          goveralls -coverprofile=coverage.out -service=github -repotoken $COVERALLS_TOKEN



================================================
File: .github/deactivated/codeql.yml
================================================
# For most projects, this workflow file will not need changing; you simply need
# to commit it to your repository.
#
# You may wish to alter this file to override the set of languages analyzed,
# or to provide custom queries or build logic.
#
# ******** NOTE ********
# We have attempted to detect the languages in your repository. Please check
# the `language` matrix defined below to confirm you have the correct set of
# supported CodeQL languages.
#
name: "CodeQL"

on:
  push:
    branches: ["main"]
  pull_request:
    # The branches below must be a subset of the branches above
    branches: ["main"]
  schedule:
    - cron: "0 0 * * 1"

permissions:
  contents: read

jobs:
  analyze:
    name: Analyze
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
      security-events: write

    strategy:
      fail-fast: false
      matrix:
        language: ["go"]
        # CodeQL supports [ $supported-codeql-languages ]
        # Learn more about CodeQL language support at https://aka.ms/codeql-docs/language-support

    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
        with:
          egress-policy: audit

      - name: Checkout repository
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      # Initializes the CodeQL tools for scanning.
      - name: Initialize CodeQL
        uses: github/codeql-action/init@60168efe1c415ce0f5521ea06d5c2062adbeed1b # v3.28.17
        with:
          languages: ${{ matrix.language }}
          # If you wish to specify custom queries, you can do so here or in a config file.
          # By default, queries listed here will override any specified in a config file.
          # Prefix the list here with "+" to use these queries and those in the config file.

      # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).
      # If this step fails, then you should remove it and run the build manually (see below)
      - name: Autobuild
        uses: github/codeql-action/autobuild@60168efe1c415ce0f5521ea06d5c2062adbeed1b # v3.28.17

      # ℹ️ Command-line programs to run using the OS shell.
      # 📚 See https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsrun

      #   If the Autobuild fails above, remove it and uncomment the following three lines.
      #   modify them (or add more) to build your code if your project, please refer to the EXAMPLE below for guidance.

      # - run: |
      #   echo "Run, Build Application using script"
      #   ./location_of_script_within_repo/buildscript.sh

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@60168efe1c415ce0f5521ea06d5c2062adbeed1b # v3.28.17
        with:
          category: "/language:${{matrix.language}}"



================================================
File: .github/deactivated/dependency-review.yml
================================================
# Dependency Review Action
#
# This Action will scan dependency manifest files that change as part of a Pull Request,
# surfacing known-vulnerable versions of the packages declared or updated in the PR.
# Once installed, if the workflow run is marked as required,
# PRs introducing known-vulnerable packages will be blocked from merging.
#
# Source repository: https://github.com/actions/dependency-review-action
name: 'Dependency Review'
on: [pull_request]

permissions:
  contents: read

jobs:
  dependency-review:
    runs-on: ubuntu-latest
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
        with:
          egress-policy: audit

      - name: 'Checkout Repository'
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
      - name: 'Dependency Review'
        uses: actions/dependency-review-action@38ecb5b593bf0eb19e335c03f97670f792489a8b # v4.7.0



================================================
File: .github/deactivated/release.yml
================================================
name: Create Release

on:
  workflow_dispatch:
    inputs:
      bump_type:
        description: "Type of version bump (alpha, beta, rc, promote_to_final, patch, minor, major)"
        required: true
        default: "alpha"
        type: choice
        options:
          - alpha
          - beta
          - rc
          - promote_to_final
          - patch
          - minor
          - major
      draft_release:
        description: "Create as a draft release?"
        required: true
        default: "false"
        type: boolean

permissions:
  contents: read

jobs:
  determine_version:
    runs-on: ubuntu-latest
    outputs:
      next_version: ${{ steps.get_version.outputs.next_version }}
      is_prerelease: ${{ steps.get_version.outputs.is_prerelease }}
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
        with:
          egress-policy: audit

      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 0 # Required to fetch all tags

      - name: Set up Python
        uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065 # v5.6.0
        with:
          python-version: '3.x'

      - name: Install dependencies
        run: pip install semver

      - name: Determine next version
        id: get_version
        env:
          BUMP_TYPE: ${{ github.event.inputs.bump_type }}
        run: python .github/scripts/determine_next_version.py

  build_and_release:
    needs: determine_version
    if: needs.determine_version.outputs.next_version != ''
    runs-on: ubuntu-latest
    permissions:
      contents: write # Required to create releases and tags
    strategy:
      matrix:
        goos: [linux, windows, darwin]
        goarch: [amd64, arm64]
        exclude: # Add exclusions if some combinations are not needed/supported
          - goos: windows
            goarch: arm64 # Example: if windows arm64 is not a target

    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
        with:
          egress-policy: audit

      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Set up Go
        uses: actions/setup-go@d35c59abb061a4a6fb18e82ac0862c26744d6ab5 # v5.5.0
        with:
          go-version: '1.21' # As per PRD

      - name: Set version output
        id: version_output
        run: |
          echo "NEXT_VERSION=${{ needs.determine_version.outputs.next_version }}" >> $GITHUB_ENV
          echo "IS_PRERELEASE=${{ needs.determine_version.outputs.is_prerelease }}" >> $GITHUB_ENV

      - name: Build application
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
          VERSION: ${{ env.NEXT_VERSION }}
        run: |
          echo "Building for $GOOS/$GOARCH with version $VERSION"
          BINARY_NAME="almd"
          if [ "$GOOS" == "windows" ]; then
            BINARY_NAME="almd.exe"
          fi
          go build -v -o $BINARY_NAME -ldflags="-X 'main.version=$VERSION'" ./cmd/almd
          ls -la $BINARY_NAME # Verify binary exists

      - name: Archive binary
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
          VERSION_NO_V: ${{ env.NEXT_VERSION }} # Assuming NEXT_VERSION has 'v' prefix
        run: |
          VERSION_TAG=${VERSION_NO_V#v} # Remove 'v' prefix for filename
          ARCHIVE_NAME="almd_${VERSION_TAG}_${GOOS}_${GOARCH}"
          BINARY_NAME="almd"
          if [ "$GOOS" == "windows" ]; then
            BINARY_NAME="almd.exe"
            zip "${ARCHIVE_NAME}.zip" $BINARY_NAME
            echo "ASSET_NAME=${ARCHIVE_NAME}.zip" >> $GITHUB_ENV
            echo "ASSET_PATH=${ARCHIVE_NAME}.zip" >> $GITHUB_ENV
          else
            tar -czvf "${ARCHIVE_NAME}.tar.gz" $BINARY_NAME
            echo "ASSET_NAME=${ARCHIVE_NAME}.tar.gz" >> $GITHUB_ENV
            echo "ASSET_PATH=${ARCHIVE_NAME}.tar.gz" >> $GITHUB_ENV
          fi
          ls -la $ASSET_PATH # Verify archive exists

      - name: Upload artifact for this job
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: almd-binaries-${{ matrix.goos }}-${{ matrix.goarch }}
          path: ${{ env.ASSET_PATH }}

  create_release_tag:
    needs: [determine_version, build_and_release] # Ensure build_and_release completes for all platforms
    runs-on: ubuntu-latest
    if: needs.determine_version.outputs.next_version != ''
    permissions:
      contents: write
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
        with:
          egress-policy: audit

      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 0

      - name: Create Git Tag
        env:
          NEXT_VERSION: ${{ needs.determine_version.outputs.next_version }}
        run: |
          echo "Creating tag $NEXT_VERSION"
          git tag $NEXT_VERSION
          git push origin $NEXT_VERSION

      - name: Download all artifacts
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
        with:
          path: release-artifacts # Download all artifacts to this directory
          # No specific name means download all artifacts from the run

      - name: List downloaded artifacts
        run: |
          ls -R release-artifacts

      - name: Create GitHub Release
        id: create_release
        uses: softprops/action-gh-release@da05d552573ad5aba039eaac05058a918a7bf631 # v2.2.2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.determine_version.outputs.next_version }}
          name: Release ${{ needs.determine_version.outputs.next_version }}
          body: |
            Automated release for version ${{ needs.determine_version.outputs.next_version }}.
            See CHANGELOG.md for details (if available).
          draft: ${{ github.event.inputs.draft_release == 'true' }}
          prerelease: ${{ needs.determine_version.outputs.is_prerelease == 'true' }}
          files: |
            release-artifacts/almd-binaries-linux-amd64/*.tar.gz
            release-artifacts/almd-binaries-linux-arm64/*.tar.gz
            release-artifacts/almd-binaries-windows-amd64/*.zip
            release-artifacts/almd-binaries-darwin-amd64/*.tar.gz
            release-artifacts/almd-binaries-darwin-arm64/*.tar.gz



================================================
File: .github/deactivated/scorecard.yml
================================================
# This workflow uses actions that are not certified by GitHub. They are provided
# by a third-party and are governed by separate terms of service, privacy
# policy, and support documentation.

name: Scorecard supply-chain security
on:
  # For Branch-Protection check. Only the default branch is supported. See
  # https://github.com/ossf/scorecard/blob/main/docs/checks.md#branch-protection
  branch_protection_rule:
  # To guarantee Maintained check is occasionally updated. See
  # https://github.com/ossf/scorecard/blob/main/docs/checks.md#maintained
  schedule:
    - cron: '26 19 * * 2'
  push:
    branches: [ "main" ]

# Declare default permissions as read only.
permissions: read-all

jobs:
  analysis:
    name: Scorecard analysis
    runs-on: ubuntu-latest
    # `publish_results: true` only works when run from the default branch. conditional can be removed if disabled.
    if: github.event.repository.default_branch == github.ref_name || github.event_name == 'pull_request'
    permissions:
      # Needed to upload the results to code-scanning dashboard.
      security-events: write
      # Needed to publish results and get a badge (see publish_results below).
      id-token: write
      # Uncomment the permissions below if installing in a private repository.
      # contents: read
      # actions: read

    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
        with:
          egress-policy: audit

      - name: "Checkout code"
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          persist-credentials: false

      - name: "Run analysis"
        uses: ossf/scorecard-action@f49aabe0b5af0936a0987cfb85d86b75731b0186 # v2.4.1
        with:
          results_file: results.sarif
          results_format: sarif
          # (Optional) "write" PAT token. Uncomment the `repo_token` line below if:
          # - you want to enable the Branch-Protection check on a *public* repository, or
          # - you are installing Scorecard on a *private* repository
          # To create the PAT, follow the steps in https://github.com/ossf/scorecard-action?tab=readme-ov-file#authentication-with-fine-grained-pat-optional.
          # repo_token: ${{ secrets.SCORECARD_TOKEN }}

          # Public repositories:
          #   - Publish results to OpenSSF REST API for easy access by consumers
          #   - Allows the repository to include the Scorecard badge.
          #   - See https://github.com/ossf/scorecard-action#publishing-results.
          # For private repositories:
          #   - `publish_results` will always be set to `false`, regardless
          #     of the value entered here.
          publish_results: true

          # (Optional) Uncomment file_mode if you have a .gitattributes with files marked export-ignore
          # file_mode: git

      # Upload the results as artifacts (optional). Commenting out will disable uploads of run results in SARIF
      # format to the repository Actions tab.
      - name: "Upload artifact"
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: SARIF file
          path: results.sarif
          retention-days: 5

      # Upload the results to GitHub's code scanning dashboard (optional).
      # Commenting out will disable upload of results to your repo's Code Scanning dashboard
      - name: "Upload to code-scanning"
        uses: github/codeql-action/upload-sarif@60168efe1c415ce0f5521ea06d5c2062adbeed1b # v3.28.17
        with:
          sarif_file: results.sarif



================================================
File: .github/scripts/determine_next_version.py
================================================
import os
import subprocess
import semver
import sys

def get_tags():
    try:
        result = subprocess.run(['git', 'tag', '-l', 'v*', '--sort=v:refname'], capture_output=True, text=True, check=True)
        tags = result.stdout.strip().split('\n')
        return [tag for tag in tags if tag] # Filter out empty strings if any
    except subprocess.CalledProcessError as e:
        print(f"Error fetching tags: {e}", file=sys.stderr)
        return []

def get_latest_semver(tags):
    latest_v = None
    for tag_str in reversed(tags): # Iterate from newest to oldest based on git sort
        try:
            v = semver.VersionInfo.parse(tag_str[1:]) # Remove 'v' prefix
            if latest_v is None or v > latest_v:
                latest_v = v
        except ValueError:
            # Not a valid semver tag, skip
            continue
    return latest_v

def get_latest_prerelease_for_base(tags, base_version, token):
    """
    Finds the latest prerelease tag for a given base version and token.
    Example: base_version = 0.2.0, token = 'alpha' -> finds latest v0.2.0-alpha.N
    Returns a semver.VersionInfo object or None.
    """
    latest_prerelease_v = None
    for tag_str in reversed(tags): # Assumes tags are sorted v:refname
        try:
            v = semver.VersionInfo.parse(tag_str[1:])
            if v.major == base_version.major and \
               v.minor == base_version.minor and \
               v.patch == base_version.patch and \
               v.prerelease and len(v.prerelease) == 2 and v.prerelease[0] == token:
                # Compare numeric part of the prerelease
                if latest_prerelease_v is None or v.prerelease[1] > latest_prerelease_v.prerelease[1]:
                    latest_prerelease_v = v
        except ValueError:
            # Not a valid semver tag or unexpected prerelease format
            continue
        except TypeError:
            # Handle cases where prerelease[1] might not be comparable (e.g., not an int)
            print(f"Warning: Prerelease part of tag {tag_str} is not as expected for comparison.", file=sys.stderr)
            continue
    return latest_prerelease_v

def main():
    bump_type = os.environ.get('BUMP_TYPE')
    if not bump_type:
        print("Error: BUMP_TYPE environment variable not set.", file=sys.stderr)
        sys.exit(1)

    tags = get_tags()
    latest_v = get_latest_semver(tags)

    next_v_str = ""
    is_prerelease = "true"

    if not latest_v:
        if bump_type == 'alpha':
            next_v = semver.VersionInfo(0, 2, 0, prerelease='alpha.1')
            # Check for existing tags and bump if necessary
            temp_next_v_tag = f"v{str(next_v)}"
            while temp_next_v_tag in tags: # 'tags' contains all existing v* tags
                next_v = next_v.bump_prerelease(token='alpha')
                temp_next_v_tag = f"v{str(next_v)}"
            next_v_str = str(next_v)
        else:
            print(f"Error: No existing tags found. Initial bump must be 'alpha' to start with 0.2.0-alpha.1.", file=sys.stderr)
            sys.exit(1)
    else:
        current_v = latest_v
        if bump_type == 'alpha':
            if current_v.prerelease and current_v.prerelease[0] == 'alpha':
                next_v = current_v.bump_prerelease(token='alpha')
            else: # New alpha series for current major.minor.patch or next patch
                # If current is final (e.g. 0.1.0), new alpha is 0.1.0-alpha.1
                # If current is rc (e.g. 0.1.0-rc.1), new alpha is 0.1.0-alpha.1
                # If current is beta (e.g. 0.1.0-beta.1), new alpha is 0.1.0-alpha.1
                next_v = semver.VersionInfo(current_v.major, current_v.minor, current_v.patch, prerelease='alpha.1')

            # Check for existing tags and bump if necessary
            temp_next_v_tag = f"v{str(next_v)}"
            while temp_next_v_tag in tags:
                next_v = next_v.bump_prerelease(token='alpha') # Bumps 'alpha.1' to 'alpha.2', etc.
                temp_next_v_tag = f"v{str(next_v)}"
            next_v_str = str(next_v)
        elif bump_type == 'beta':
            if current_v.prerelease and current_v.prerelease[0] == 'beta':
                next_v = current_v.bump_prerelease(token='beta')
            else: # New beta series, must come from alpha or be a new beta for a version
                # e.g., 0.1.0-alpha.2 -> 0.1.0-beta.1
                next_v = semver.VersionInfo(current_v.major, current_v.minor, current_v.patch, prerelease='beta.1')

            # Check for existing tags and bump if necessary
            temp_next_v_tag = f"v{str(next_v)}"
            while temp_next_v_tag in tags:
                next_v = next_v.bump_prerelease(token='beta')
                temp_next_v_tag = f"v{str(next_v)}"
            next_v_str = str(next_v)
        elif bump_type == 'rc':
            if current_v.prerelease and current_v.prerelease[0] == 'rc':
                next_v = current_v.bump_prerelease(token='rc')
            else: # New RC series
                next_v = semver.VersionInfo(current_v.major, current_v.minor, current_v.patch, prerelease='rc.1')

            # Check for existing tags and bump if necessary
            temp_next_v_tag = f"v{str(next_v)}"
            while temp_next_v_tag in tags:
                next_v = next_v.bump_prerelease(token='rc')
                temp_next_v_tag = f"v{str(next_v)}"
            next_v_str = str(next_v)
        elif bump_type == 'promote_to_final':
            if not current_v.prerelease:
                print(f"Error: Version {current_v} is already final. Cannot promote.", file=sys.stderr)
                sys.exit(1)
            next_v = current_v.finalize_version()
            next_v_str = str(next_v)
            is_prerelease = "false"
        elif bump_type == 'patch':
            # For patch, minor, major, we always bump from the finalized version of the *overall* latest tag.
            base_v = current_v.finalize_version()
            next_v = base_v.bump_patch()
            next_v_str = str(next_v)
            is_prerelease = "false"
        elif bump_type == 'minor':
            base_v = current_v.finalize_version()
            next_v = base_v.bump_minor()
            next_v_str = str(next_v)
            is_prerelease = "false"
        elif bump_type == 'major':
            base_v = current_v.finalize_version()
            next_v = base_v.bump_major()
            next_v_str = str(next_v)
            is_prerelease = "false"
        else:
            print(f"Error: Unknown BUMP_TYPE '{bump_type}'", file=sys.stderr)
            sys.exit(1)

    if not next_v_str.startswith('v'):
        next_v_tag = f"v{next_v_str}"
    else:
        next_v_tag = next_v_str


    print(f"Calculated next version: {next_v_tag}", file=sys.stderr)
    print(f"::set-output name=next_version::{next_v_tag}")
    print(f"::set-output name=is_prerelease::{is_prerelease}")

if __name__ == "__main__":
    main()




